<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>swift 集合协议 | Skybrim</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="swift 集合协议">
<meta property="og:type" content="article">
<meta property="og:title" content="swift 集合协议">
<meta property="og:url" content="https://skybrim.top/2020/07/07/ios/swift-collection-protocol/index.html">
<meta property="og:site_name" content="Skybrim">
<meta property="og:description" content="swift 集合协议">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/swift-collection-protocol-1.jpg">
<meta property="article:published_time" content="2020-07-07T06:15:41.000Z">
<meta property="article:modified_time" content="2020-12-10T02:48:42.068Z">
<meta property="article:author" content="Wiley">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="swift">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/swift-collection-protocol-1.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Skybrim" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Skybrim</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Practice makes perfect. Always.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://skybrim.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ios/swift-collection-protocol" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/07/ios/swift-collection-protocol/" class="article-date">
  <time datetime="2020-07-07T06:15:41.000Z" itemprop="datePublished">2020-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      swift 集合协议
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>swift 集合协议</p>
<a id="more"></a>

<h2 id="标准库中的结合协议架构"><a href="#标准库中的结合协议架构" class="headerlink" title="标准库中的结合协议架构"></a>标准库中的结合协议架构</h2><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/swift-collection-protocol-1.jpg" alt="标准库中的结合协议架构"></p>
<ul>
<li><p>Sequence</p>
<p>  提供了迭代的能力，允许创建一个迭代器</p>
</li>
<li><p>Collection</p>
<p>  支持多次遍历</p>
<p>  提供通过索引访问元素</p>
<p>  通过 SubSequence 提供了集合切片的能力，切片自身也是一个集合</p>
</li>
<li><p>MutableCollection</p>
<p>  提供了常数时间内，通过下标更改集合的能力</p>
<p>  <strong>不允许向集合中添加和删除元素</strong></p>
</li>
<li><p>RangeReplaceableCollection</p>
<p>  提供了替换集合中一个连续区间的元素的能力。</p>
<p>  通过扩展，衍生出 append 和 remove 等方法</p>
<p>  Array/String 支持</p>
<p>  Set/Dictionary 不支持</p>
</li>
<li><p>BidirectionalCollection</p>
<p>  提供了从集合尾部想集合头部遍历的能力</p>
</li>
<li><p>RandomAccessCollection</p>
<p>  提供了更高效的索引计算能力：计算索引的距离或者移动索引位置都是常数时间操作。</p>
<p>  举例：Array 是随机访问的集合，但是 String 不是，因为计算两个字符之间的举例是一个线性时间的操作。</p>
</li>
<li><p>LazySequenceProtocol</p>
<p>  定义了一个只有在开始遍历时才计算其中元素的<strong>序列</strong>。</p>
<p>  可以接受一个无穷序列，从中筛选元素，然后读取结果中的前几个记录。</p>
</li>
<li><p>LazyCollectionProtocol</p>
<p>  与 LazySequenceProtocol 类似，定义一个只有在开始遍历时才计算其中元素的<strong>集合类型</strong></p>
</li>
</ul>
<h2 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h2><p>Sequence 1: 有一个关联类型 Element; 2: 有一个创建迭代器的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的 Sequence 定义</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span> <span class="keyword">where</span> <span class="type">Self</span>.<span class="type">Element</span> == <span class="type">Self</span>.<span class="type">Iterator</span>.<span class="type">Element</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span>:  <span class="type">IteratorProtocol</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Self</span>.<span class="type">Iterator</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Iterator（迭代器）</li>
</ul>
<p>序列通过创建迭代器来提供对元素的访问。</p>
<p>迭代器每次产生序列中的一个值，并对序列的遍历状态管理。</p>
<p>迭代器遵循 IteratorProtocol。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IteratorProtocol 的关联类型 Element 指定了迭代器产生的值得类型。<br>同时在 Sequence 协议中，通过序列的关联类型 ELement 的类型约束<code>where Self.Element == Self.Iterator.Element</code>，指定迭代器及对应序列的元素相同</p>
<p>IteratorProtocol 协议唯一的方法 next() ，这个方法在每次被调用时返回序列的下一个值，当序列结束，返回 nil。</p>
<p>迭代器作用：for 循环是通过迭代器实现的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for 循环的实质</span></span><br><span class="line"><span class="keyword">var</span> iterator = someSequence.makeIterator()</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> element = iterator.next() &#123;</span><br><span class="line">    doSomething(whit:element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器特点：</p>
<p>单向结构，只能按照增加的方向前进，不能后退或重置。</p>
<p>通过迭代器不断迭代，可以创建一个无限的序列。</p>
<ul>
<li>遵循 Sequence 创建序列</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PrefixIterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> string: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> offset: <span class="type">String</span>.<span class="type">Index</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(string: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.string = string</span><br><span class="line">        offset = string.startIndex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Substring?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> offset &lt; string.endIndex <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        offset = string.index(after: offset)</span><br><span class="line">        <span class="keyword">return</span> string[...&lt;offset]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PrefixSequence</span>: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> string: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">PrefixIterator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">PrefixIterator</span>(string: string)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">prefix</span> <span class="keyword">in</span> <span class="type">PrefixSequence</span>(string: <span class="string">"abc"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">prefix</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">ab</span></span><br><span class="line"><span class="comment">abc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一些特性</li>
</ul>
<ol>
<li><p>迭代器与值语义：<br>标准库中大部分迭代器都具有值语义，复制后所有状态都会被复制，而且相互独立；</p>
<p>AnyIterator 是一个队别的迭代器进行封装的迭代器，封装原理是将另外的迭代器包装到一个内部的盒子对象中，而这个对象是引用类型。<br>因此 AnyIterator 对象的复制，可能会导致多个迭代器共享同一个引用。</p>
</li>
<li><p>基于函数的迭代器和序列<br>AnyIterator 有可以接受 next 函数作为参数的初始化方法。</p>
<p>配合 AnySequence，可以在不定义新的类型的情况下，创建迭代器和序列。</p>
</li>
<li><p>单词遍历序列<br>Sequence 文档指出，序列并不能保证可以被多次遍历（如网络包流），collection 协议才能保证多次迭代是安全的</p>
</li>
<li><p>序列与迭代器关系<br>支持多次遍历的序列，需要独立的遍历状态，所以分离迭代器与序列</p>
<p>迭代器也可以视为由他们返回的元素所组成的单次遍历序列。<br>只要声明迭代器遵循 Sequence 协议，它就是一个序列类型，Sequence 会为迭代器提供一个默认的 makeIterator 实现，这个方法返回的 self 本身。</p>
</li>
</ol>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>集合类型（Collection）指的是那些可以被多次遍历且保持一致的序列。</p>
<p>除了线性遍历意外，集合中的元素也可以通过下标索引的方式访问。</p>
<p>集合类型不能是无限的。</p>
<p>每一个集合类型都有一个关联类型 SubSequence，表示集合中一段连续内容的切片。</p>
<p>Collection 继承了 Sequence。</p>
<p>实现 Collection 协议，最难的是选取合适的索引类型来表达集合类型中的位置。</p>
<p>实现 Collection 的类型:</p>
<p>swift 标准库：Array/Dictionary/Set/String/[Closed]Range/UnsafeBufferPointer</p>
<p>Foundation: Data/IndexSet</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除了 Index 和 Element 意外，其他关联类型都是有默认值得，大部分方法、属性、下标也是如此。</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Collection</span> : <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 继承自 Sequence</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span> = <span class="type">IndexingIterator</span>&lt;<span class="type">Self</span>&gt;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Self</span>.<span class="type">Iterator</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Index</span> : <span class="type">Comparable</span> <span class="comment">// 省略大量的 where 语句</span></span><br><span class="line">    <span class="keyword">var</span> startIndex: <span class="type">Self</span>.<span class="type">Index</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> endIndex: <span class="type">Self</span>.<span class="type">Index</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用递归约束表明 SubSequence 自身也是一个集合类型</span></span><br><span class="line">    <span class="comment">// 且 Collection 元素与 SubSequence 元素相同</span></span><br><span class="line">    <span class="comment">// 且 SubSequence 中的 SubSequence 类型与自身相同</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">SubSequence</span> : <span class="type">Collection</span> = <span class="type">Slice</span>&lt;<span class="type">Self</span>&gt; <span class="keyword">where</span> <span class="type">Self</span>.<span class="type">Element</span> == <span class="type">Self</span>.<span class="type">SubSequence</span>.<span class="type">Element</span>, <span class="type">Self</span>.<span class="type">SubSequence</span> == <span class="type">Self</span>.<span class="type">SubSequence</span>.<span class="type">SubSequence</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(position: <span class="type">Self</span>.<span class="type">Index</span>) -&gt; <span class="type">Self</span>.<span class="type">Element</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(bounds: <span class="type">Range</span>&lt;<span class="type">Self</span>.<span class="type">Index</span>&gt;) -&gt; <span class="type">Self</span>.<span class="type">SubSequence</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indices 也是集合类型</span></span><br><span class="line">    <span class="comment">// Collection 中的 Index 是这个 Indices 的元素类型、索引类型以及 Indices.SubSequence 中的索引类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Indices</span> : <span class="type">Collection</span> = <span class="type">DefaultIndices</span>&lt;<span class="type">Self</span>&gt; <span class="keyword">where</span> <span class="type">Self</span>.<span class="type">Indices</span> == <span class="type">Self</span>.<span class="type">Indices</span>.<span class="type">SubSequence</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">indices</span>: <span class="type">Self</span>.<span class="type">Indices</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(<span class="number">_</span> i: <span class="keyword">Self</span>.Index, offsetBy <span class="built_in">distance</span>: Int)</span></span> -&gt; <span class="type">Self</span>.<span class="type">Index</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(<span class="number">_</span> i: <span class="keyword">Self</span>.Index, offsetBy <span class="built_in">distance</span>: Int, limitedBy limit: <span class="keyword">Self</span>.Index)</span></span> -&gt; <span class="type">Self</span>.<span class="type">Index?</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">distance</span><span class="params">(from start: <span class="keyword">Self</span>.Index, to end: <span class="keyword">Self</span>.Index)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: <span class="keyword">Self</span>.Index)</span></span> -&gt; <span class="type">Self</span>.<span class="type">Index</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">formIndex</span><span class="params">(after i: <span class="keyword">inout</span> <span class="keyword">Self</span>.Index)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义集合类型</li>
</ul>
<p>实现一个队列（Queue），遵循 Collection</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先展示一个简单的先进先出队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FIFOQueue</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">left</span>: [<span class="type">Element</span>] = []</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">right</span>: [<span class="type">Element</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素添加到队列最后 O(1)</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">enqueue</span><span class="params">(<span class="number">_</span> newElement: Element)</span></span> &#123;</span><br><span class="line">        <span class="keyword">right</span>.append(newElement)</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列前端移除一个元素，队列为空时返回 nil O(1)</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">left</span>.isEmpty &#123;</span><br><span class="line">            <span class="keyword">left</span> = <span class="keyword">right</span>.reversed()</span><br><span class="line">            <span class="keyword">right</span>.removeAll()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span>.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面 Collection 协议的源码分析，我们最后需要实现如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Collection</span>: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个表示序列中元素的类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个表示集合中位置的类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Index</span>: <span class="type">Comparable</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个非空集合中首个元素的位置</span></span><br><span class="line">    <span class="keyword">var</span> startIndex: <span class="type">Index</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比最后一个有效下标大 1 的值</span></span><br><span class="line">    <span class="keyword">var</span> endIndex: <span class="type">Index</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回在给定索引之后的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: Index)</span></span> -&gt; <span class="type">Index</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下标访问特定位置的元素</span></span><br><span class="line">    <span class="keyword">subscript</span>(position: <span class="type">Index</span>) -&gt; <span class="type">Element</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，实现 FIFOQueue，满足 Collection，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FIFOQueue</span>: <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> startIndex: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> endIndex: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="keyword">left</span>.<span class="built_in">count</span> + <span class="keyword">right</span>.<span class="built_in">count</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="built_in">precondition</span>( i &gt;= startIndex &amp;&amp; i &lt; endIndex, <span class="string">"Index out of bounds"</span>)</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">subscript</span>(position: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="built_in">precondition</span>((startIndex..&lt;endIndex).<span class="built_in">contains</span>(position), <span class="string">"Index out of bounds"</span>)</span><br><span class="line">        <span class="keyword">if</span> position &lt; <span class="keyword">left</span>.endIndex &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">left</span>[<span class="keyword">left</span>.<span class="built_in">count</span> - position - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">right</span>[position - <span class="keyword">left</span>.<span class="built_in">count</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数组字面量</li>
</ul>
<p>让队列实现 ExpressibleByArrayLiteral 协议，这样可以通过字面量来创建一个队列</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FIFOQueue</span>: <span class="title">ExpressibleByArrayLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(arrayLiteral elements: <span class="type">Element</span>...) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="keyword">left</span>:elements.reversed(), <span class="keyword">right</span>:[])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo: <span class="type">FIFOQueue</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>索引（Index），表示了集合中的位置，集合类型的索引，必须实现 Comparable 协议，即索引必须要有确定的顺序。</p>
<p>使用字典举例：</p>
<p>Dictionary，它的索引是 DictionaryIndex 类型，是一个指向字典内部存储缓冲区的不透明值。</p>
<p>平时使用建访问字典的 subscript(_ key: Key) 方法，是对定义在 Dictionary 中的 subscript 方法的重载。</p>
<p>字典的 <code>subscript(key: Key) -&gt; Value?</code> ，返回的是一个可选值</p>
<p>集合类型的 subscript 方法，在 Collection 中，返回的是非可选值 <code>subscript(position: Index) -&gt; Element { get }</code></p>
<p>注意，Element 类型在字典中是一个元组：(key: Key, value: Value)，所以，Dictionary 的下标访问返回的是一个键值对，也因此对 Dictionary 遍历我们得到的是键值对。</p>
<ul>
<li>索引失效</li>
</ul>
<p>当集合发生改变时，索引可能会失效：</p>
<ol>
<li>索引本身仍然有效，但是指向了另外的元素</li>
<li>索引本身无效，通过索引访问集合将造成崩溃</li>
</ol>
<ul>
<li>索引步进</li>
</ul>
<p>当前 swift 版本，通过给定索引计算新的索引，由集合本身负责。</p>
<p>这样可以提高性能：</p>
<p>String ，由于 Character 在 Swift 中的尺寸是可以改变的，因此计算 String 的索引，必须考虑 Character 的实际内容。</p>
<ul>
<li>自定义集合索引</li>
</ul>
<p>分割集合类型，<code>split</code>方法通常最合适，但是这个方法会计算整个数组。如果数组很大，但是只需要前几个元素，这样做效率低。</p>
<p>下面用 String(英文) 举例：</p>
<p>目标是，构建一个 words 集合，它能够让我们不一次性计算出所有单词，而是可以用延迟加载的方式进行迭代。</p>
<p>首先，从 SubString 中寻找第一个单词的范围。</p>
<p>使用空格作为单词的边界。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Substring</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nextWordRange: <span class="type">Range</span>&lt;<span class="type">Index</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// 移除所有前置的空格</span></span><br><span class="line">        <span class="keyword">let</span> start = drop(<span class="keyword">while</span>: &#123; $<span class="number">0</span> == <span class="string">" "</span>&#125; )</span><br><span class="line">        <span class="comment">// 寻找结束空格，如果没有，则使用 endIndex</span></span><br><span class="line">        <span class="keyword">let</span> end = start.firstIndex(<span class="keyword">where</span>: &#123; $<span class="number">0</span> == <span class="string">" "</span>&#125;) ?? endIndex</span><br><span class="line">        <span class="keyword">return</span> start.startIndex..&lt;end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二，定义索引的类型。</p>
<p>通过索引下标访问某个元素，应该是一个 O(1) 的操作，因此封装 Range&lt;Substring.Index&gt; 来作为索引类型。</p>
<p>索引类型需要满足 Comparable(继承自 Equatable)，此时我们采用 range 的下边界作为比较对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WordsIndex</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">let</span> range: <span class="type">Range</span>&lt;<span class="type">Substring</span>.<span class="type">Index</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">init</span>(<span class="number">_</span> value: <span class="type">Range</span>&lt;<span class="type">Substring</span>.<span class="type">Index</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.range = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;(lhs: Words.Index, rhs: Words.Index) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.range.lowerBound &lt; rhs.range.lowerBound</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Words.Index, rhs: Words.Index)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.range == rhs.range</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三，构建 Words 集合类型。</p>
<p>在底层将 String 视为 SubString 存储；</p>
<p>提供两个属性： startIndex 、 endIndex；</p>
<p>同时，需要遵循 Collection 协议，并实现 subscript 下标方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Words</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> string: <span class="type">Substring</span></span><br><span class="line">    <span class="keyword">let</span> startIndex: <span class="type">WordsIndex</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> endIndex: <span class="type">WordsIndex</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> e = string.endIndex</span><br><span class="line">        <span class="keyword">return</span> <span class="type">WordsIndex</span>(e..&lt;e)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> s: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(s[...])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>(<span class="number">_</span> s: <span class="type">Substring</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.string = s</span><br><span class="line">        <span class="keyword">self</span>.startIndex = <span class="type">WordsIndex</span>(string.nextWordRange)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Words</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">WordsIndex</span>) -&gt; <span class="type">Substring</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> string[index.range]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Words</span>: <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: WordsIndex)</span></span> -&gt; <span class="type">WordsIndex</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> i.range.upperBound &lt; string.endIndex <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> endIndex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> remainder = string[i.range.upperBound...]</span><br><span class="line">        <span class="keyword">return</span> <span class="type">WordsIndex</span>(remainder.nextWordRange)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，使用自定义索引</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Array</span>(<span class="type">Words</span>(<span class="string">"hello world test"</span>)) <span class="comment">// ["hello", "world", "test"]</span></span><br><span class="line"></span><br><span class="line"><span class="type">Array</span>(<span class="type">Words</span>(<span class="string">"Hello world test"</span>).<span class="keyword">prefix</span>(<span class="number">2</span>)) <span class="comment">// ["hello", "world"]</span></span><br></pre></td></tr></table></figure>

<p>补充：创建自定义集合类型时，优先考虑能否使用其本身作为自己的 SubSequence 使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Words</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重载 subscript(range:Range&lt;Index&gt;)</span></span><br><span class="line">    <span class="keyword">subscript</span>(range:<span class="type">Range</span>&lt;<span class="type">WordsIndex</span>&gt;) -&gt; <span class="type">Words</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> start = range.lowerBound.range.lowerBound</span><br><span class="line">        <span class="keyword">let</span> end = range.upperBound.range.upperBound</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Words</span>(string[start..&lt;end])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SubSequence"><a href="#SubSequence" class="headerlink" title="SubSequence"></a>SubSequence</h2><p>在 Swift5 中，SubSequence 被定义到了 Collection 协议中，是一个关联类型，表示集合中一个连续的子区间。</p>
<p>默认情况下，Collection 把 Slice<Self> 作为自己的 SubSequence 类型。</p>
<p>子序列和原始的集合类型共享内部存储。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">SubSequence</span>: <span class="type">Collection</span> = <span class="type">Slice</span>&lt;<span class="type">Self</span>&gt; </span><br><span class="line">        <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">SubSequence</span>.<span class="type">Element</span>, <span class="type">SubSequence</span> == <span class="type">SubSequence</span>.<span class="type">SubSequence</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展：以每 n 个元素切割集合</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(batchSize: Int)</span></span> -&gt; [<span class="type">SubSequence</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> result: [<span class="type">SubSequence</span>] = []</span><br><span class="line">        <span class="keyword">var</span> batchStart = startIndex</span><br><span class="line">        <span class="keyword">while</span> batchStart &lt; endIndex &#123;</span><br><span class="line">            <span class="keyword">let</span> batchEnd = index(batchStart, offsetBy: batchSize, limitedBy: endIndex) ?? endIndex</span><br><span class="line">            <span class="keyword">let</span> batch = <span class="keyword">self</span>[batchStart..&lt;batchEnd]</span><br><span class="line">            result.append(batch)</span><br><span class="line">            batchStart = batchEnd</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> letters = <span class="string">"abcdefg"</span></span><br><span class="line"><span class="keyword">let</span> batches = letters.<span class="built_in">split</span>(batchSize: <span class="number">3</span>) <span class="comment">// ["abc", "def", "g"]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>切片</li>
</ul>
<p>所有集合类型，都有切片操作的默认实现，并有一个下标方法：<code>subscript(range:Range&lt;Index&gt;) -&gt; Slice&lt;Base&gt;</code></p>
<p>Slice 非常适合作为默认的切片类型，不过当创建自定义集合时，优先考虑集合本身作为切片类型。详见 <a href="#Index">Index</a>。</p>
<p>Slice 是基于任意集合类型的一个轻量级封装：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Slice</span>&lt;<span class="title">Base</span>: <span class="title">Collection</span>&gt;: <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Index</span> = <span class="type">Base</span>.<span class="type">Index</span></span><br><span class="line">    <span class="keyword">let</span> collection: <span class="type">Base</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> startIndex: <span class="type">Index</span></span><br><span class="line">    <span class="keyword">var</span> endIndex: <span class="type">Index</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(base: <span class="type">Base</span>, bounds: <span class="type">Range</span>&lt;<span class="type">Index</span>&gt;) &#123;</span><br><span class="line">        collection = base</span><br><span class="line">        startIndex = bounds.lowerBound</span><br><span class="line">        endIndex = bounds.upperBound</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i:Index)</span></span> -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> collection.index(after: i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(position: <span class="type">Index</span>) -&gt; <span class="type">Base</span>.<span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> collection[position]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(bounds: <span class="type">Range</span>&lt;<span class="type">Index</span>&gt;) -&gt; <span class="type">Slice</span>&lt;<span class="type">Base</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Slice</span>(base: collection, bounds: bounds)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>切片与原集合共享索引</li>
</ul>
<p>Collection 协议要求切片的索引和原集合的索引互换使用</p>
<p>集合类型和它的切片拥有相同的索引。</p>
<p>只要集合和它的切片在切片被创建后没有改变，切片中的某个索引位置上的元素，应当也存在于原集合中同样的索引位置上。</p>
<p>推荐使用索引的方式： <code>for index in collection.indices</code>，但不要在迭代时修改集合。</p>
<h2 id="专门的集合类型"><a href="#专门的集合类型" class="headerlink" title="专门的集合类型"></a>专门的集合类型</h2><p>Collection 有两个限制：</p>
<ol>
<li>无法往回移动索引；</li>
<li>没有提供像插入、移除或替换元素这样的改变集合内容的功能。</li>
</ol>
<ul>
<li>BidirectionalCollection</li>
</ul>
<p>一个既支持向前又支持向后遍历的集合，继承 Collection</p>
<p>提供<code>index(before:)</code>方法把索引往回移动一个位置</p>
<p>有了向前遍历集合的能力，BidirectionalCollection 实现了一些可以高效执行的方法:suffix，removeLast，reversed</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BidirectionalCollection</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 集合中的最后一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> last: <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty ? <span class="literal">nil</span> : <span class="keyword">self</span>[index(before: endIndex)]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  返回一个表达集合中元素逆序排列的视图，复杂度 O(1)</span></span><br><span class="line">    <span class="comment">// ReversedCollection 并不会真的把元素逆序排列，而是会持有原来的集合</span></span><br><span class="line">    <span class="comment">// 并使用一个定制的索引类型实现逆序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">reversed</span><span class="params">()</span></span> -&gt; <span class="type">ReversedCollection</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ReversedCollection</span>(<span class="number">_</span> base: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RandomAccessCollection</li>
</ul>
<p>一个支持高效随机访问索引进行遍历的集合，继承 BidirectionalCollecton</p>
<p>可以在常数时间内跳转到任意索引，需要在常数时间内完成两个操作：第一，可以任意距离移动一个索引；第二，测量任意两个索引之间的距离。</p>
<p>实现<code>index(_:offsetBy:)</code>和<code>distance(from:to:)</code>，或者 Index 类型满足 Strideable(比如 Int)</p>
<p>RandomAccessCollection 以更严格的约束重新声明了关联的 Indices 和 SubSequence 类型，这两个类型自身也必须是可以进行随机存取的。</p>
<p>补充：二分搜索算法，必须搭配随机存取集合。</p>
<ul>
<li>MutableCollection</li>
</ul>
<p>一个支持下标赋值的集合，继承自 Collection</p>
<p>要求：单个元素的下标访问方法<code>subscript</code>现在必须提供一个 setter：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 FIFOQueue 的协议由 Collection 扩展为 MutableCollection</span></span><br><span class="line"><span class="comment">// 队列支持原地的元素更改</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FIFOQueue</span>: <span class="title">MutableCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> startIndex: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> endIndex: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="keyword">left</span>.<span class="built_in">count</span> + <span class="keyword">right</span>.<span class="built_in">count</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="built_in">precondition</span>( i &gt;= startIndex &amp;&amp; i &lt; endIndex, <span class="string">"Index out of bounds"</span>)</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">subscript</span>(position: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">precondition</span>((<span class="number">0</span>..&lt;endIndex).<span class="built_in">contains</span>(position), <span class="string">"Index out of bounds"</span>)</span><br><span class="line">            <span class="keyword">if</span> position &lt; <span class="keyword">left</span>.endIndex &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">left</span>[<span class="keyword">left</span>.<span class="built_in">count</span> - position - <span class="number">1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">right</span>[position - <span class="keyword">left</span>.<span class="built_in">count</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="built_in">precondition</span>((<span class="number">0</span>..&lt;endIndex).<span class="built_in">contains</span>(position), <span class="string">"Index out of bounds"</span>)</span><br><span class="line">            <span class="keyword">if</span> position &lt; <span class="keyword">left</span>.endIndex &#123;</span><br><span class="line">                <span class="keyword">left</span>[<span class="keyword">left</span>.<span class="built_in">count</span> - position - <span class="number">1</span>] = newValue</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">right</span>[position - <span class="keyword">left</span>.<span class="built_in">count</span>] = newValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RangeReplaceableCollection</li>
</ul>
<p>一个支持将任意范围的元素用别的集合中的元素进行替换的集合，继承自 Collection</p>
<p>此协议两个要求：</p>
<ol>
<li>一个空的初始化方法；（在泛型函数中很有用，允许一个函数创建相同类型的空集合）</li>
<li>一个 replaceSubrange(_:with:)方法。（接受一个要替换的范围以及一个用来进行替换的集合）</li>
</ol>
<p>只需要实现一个灵活的 replaceSubrange(_:with:)方法，协议扩展就可以引申一系列有用的方法：</p>
<ol>
<li>append(_:) 和 append(contentsOf:)</li>
<li>remove(at:) 和 removeSubrange(_:)</li>
<li>insert(at:) 和 insert(contentsOf:at:)</li>
<li>removeAll</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例 FIFOQueue</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FIFOQueue</span>: <span class="title">RangeReplaceableCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">replaceSubrange</span>&lt;C:Collection&gt; <span class="params">(<span class="number">_</span> subrange: Range&lt;Int&gt;, with newElements: C)</span></span></span><br><span class="line">        <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">            <span class="keyword">right</span> = <span class="keyword">left</span>.reversed() + <span class="keyword">right</span></span><br><span class="line">            <span class="keyword">left</span>.removeAll()</span><br><span class="line">            <span class="keyword">right</span>.replaceSubrange(subrange, with: newElements)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>组合能力</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MutableCollection</span> </span></span><br><span class="line"><span class="class">    <span class="title">where</span> <span class="title">Self</span>: <span class="title">RandomAccessCollection</span>, <span class="title">Element</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原地对集合进行排序</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="延迟序列"><a href="#延迟序列" class="headerlink" title="延迟序列"></a>延迟序列</h2><p>LazySequenceProtocol 和 LazyCollectionProtocol。</p>
<p>延迟编程：结果只有在真正需要的时候才会计算出来。</p>
<p>swift 标准库为支持延迟编程，提供了两个协议：LazySequenceProtocol 和 LazyCollectionProtocol。</p>
<p>LazySequenceProtocol 继承自 Sequence。</p>
<p>LazyCollectionProtocol 继承自 LazySequenceProtocol。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要标准输入收到 EOF 信号才会显示</span></span><br><span class="line"><span class="keyword">let</span> filtered = standardIn.<span class="built_in">filter</span> &#123;</span><br><span class="line">    $<span class="number">0</span>.<span class="built_in">split</span>(separator: <span class="string">" "</span>).<span class="built_in">count</span> &gt; <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> filtered &#123; <span class="built_in">print</span>(line) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每读一行符合条件的结果，就打印一个消息</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> standardIn &#123;</span><br><span class="line">    <span class="keyword">guard</span> line.<span class="built_in">split</span>(separator: <span class="string">" "</span>).<span class="built_in">count</span> &gt; <span class="number">3</span> <span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想保留函数式风格，需要在获取到值得时候就生成筛选后的结果</span></span><br><span class="line"><span class="comment">// .lazy 返回值类型是 LazySequence&lt;Self&gt;</span></span><br><span class="line"><span class="comment">// LazySequence 的 filter 方法会返回一个 LazyFilterSequence&lt;AnySequence&lt;String&gt;&gt;</span></span><br><span class="line"><span class="keyword">let</span> filtered = standardIn.<span class="built_in">lazy</span>.<span class="built_in">filter</span> &#123;</span><br><span class="line">    $<span class="number">0</span>.solit(separator: <span class="string">" "</span>).<span class="built_in">count</span> &gt; <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> filtered &#123; <span class="built_in">print</span>(line) &#125;</span><br></pre></td></tr></table></figure>

<p>风格比较</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="type">Array</span>(standardIn.<span class="built_in">lazy</span>.<span class="built_in">filter</span> &#123;</span><br><span class="line">    $<span class="number">0</span>.<span class="built_in">split</span>(separator: <span class="string">" "</span>).<span class="built_in">count</span> &gt; <span class="number">3</span></span><br><span class="line">&#125;.<span class="keyword">prefix</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令式</span></span><br><span class="line"><span class="keyword">var</span> result: [<span class="type">String</span>] = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> standardIn &#123;</span><br><span class="line">    <span class="keyword">guard</span> line.<span class="built_in">split</span>(separator: <span class="string">" "</span>).<span class="built_in">count</span> &gt; <span class="number">3</span> <span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">    result.append(line)</span><br><span class="line">    <span class="keyword">if</span> result.<span class="built_in">count</span> == <span class="number">2</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>集合的延迟处理</li>
</ul>
<p>当在一个常规集合类型（Array）上，串联多个操作时，可以延迟处理的序列，会更效率。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>..&lt;<span class="number">100</span>).<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;.<span class="built_in">filter</span> &#123;$<span class="number">0</span> &gt; <span class="number">10</span> &#125;.<span class="built_in">map</span> &#123; <span class="string">"\($0)"</span> &#125;</span><br></pre></td></tr></table></figure>

<p>函数式编程，代码清晰易于理解，但是存在效率不佳的问题：</p>
<p>每一次调用 map 和 filter，都会创建一个新的包含中间结果的数组，这个数组在返回的时候就被销毁了。</p>
<p>通过在这个调用链的开始，插入 .lazy，就不会产生任何保存中间结果的数组，更有效率</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>..&lt;<span class="number">100</span>).<span class="built_in">lazy</span>.<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;.<span class="built_in">filter</span> &#123;$<span class="number">0</span> &gt; <span class="number">10</span> &#125;.<span class="built_in">map</span> &#123; <span class="string">"\($0)"</span> &#125;</span><br></pre></td></tr></table></figure>

<p>LazyCollectionProtocol 扩展了 LazySequence，它要求实现它的类型也是一个实现了 Collection 的类型。</p>
<p>在 LazySquence 中，我们只能逐个生成 Sequence 中的每个元素。</p>
<p>在 LazyCollection 中，我们可以直接按需生成指定的某个元素。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当对一个延迟加载的集合，应用 map 方法</span></span><br><span class="line"><span class="comment">// 通过下标访问其中的元素</span></span><br><span class="line"><span class="comment">// map 只会对你访问的那个结果执行变换。 O(1)</span></span><br><span class="line"><span class="keyword">let</span> allNumbers = <span class="number">1</span>..&lt;<span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">let</span> allSquares = allNumbers.<span class="built_in">lazy</span>.<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(allSquares[<span class="number">50</span>]) <span class="comment">// 2500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意</span></span><br><span class="line"><span class="comment">// 当使用下标访问元素的时候，每一次的结果都是计算出来的</span></span><br><span class="line"><span class="comment">// 比如下面的代码， 50 已经被过滤掉了</span></span><br><span class="line"><span class="comment">// 为了获取值，需要计算前 50 个的值，然后才能获取到 50 的值（第 51 个）</span></span><br><span class="line"><span class="comment">// 显然这是一个 O(n) 的操作</span></span><br><span class="line"><span class="keyword">let</span> largeSquares = allNumbers.<span class="built_in">lazy</span>.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &gt; <span class="number">1000</span> &#125;.<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(largeSquares[<span class="number">50</span>]) <span class="comment">// 2500</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://skybrim.top/2020/07/07/ios/swift-collection-protocol/" data-id="ckiia424n003umobm9lyt0ufs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/swift/" rel="tag">swift</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/07/09/ios/swift-str/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          swift string
        
      </div>
    </a>
  
  
    <a href="/2020/07/06/ios/swift-collection/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">swift 集合类型</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ffmpeg/" rel="tag">ffmpeg</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/homebrew/" rel="tag">homebrew</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inbox/" rel="tag">inbox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kindle/" rel="tag">kindle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/proxy/" rel="tag">proxy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raspberry-pi/" rel="tag">raspberry-pi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swift/" rel="tag">swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/travel/" rel="tag">travel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/algorithm/" style="font-size: 16px;">algorithm</a> <a href="/tags/css/" style="font-size: 14px;">css</a> <a href="/tags/ffmpeg/" style="font-size: 16px;">ffmpeg</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hexo/" style="font-size: 12px;">hexo</a> <a href="/tags/homebrew/" style="font-size: 10px;">homebrew</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/inbox/" style="font-size: 18px;">inbox</a> <a href="/tags/kindle/" style="font-size: 10px;">kindle</a> <a href="/tags/proxy/" style="font-size: 10px;">proxy</a> <a href="/tags/raspberry-pi/" style="font-size: 14px;">raspberry-pi</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/swift/" style="font-size: 16px;">swift</a> <a href="/tags/travel/" style="font-size: 10px;">travel</a> <a href="/tags/vim/" style="font-size: 14px;">vim</a> <a href="/tags/web/" style="font-size: 16px;">web</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/24/web/css-layout/">css 布局</a>
          </li>
        
          <li>
            <a href="/2020/09/24/web/css-box-model/">css 盒模型</a>
          </li>
        
          <li>
            <a href="/2020/09/23/web/react-useReducer-useContext/">react-useReducer-useContext</a>
          </li>
        
          <li>
            <a href="/2020/09/23/web/css-selectors/">css-selectors</a>
          </li>
        
          <li>
            <a href="/2020/08/08/inbox/homebrew-source/">homebrew-source</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Wiley<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>