<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Skybrim</title>
  
  <subtitle>Practice makes perfect. Always.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://skybrim.top/"/>
  <updated>2020-12-10T02:48:42.069Z</updated>
  <id>https://skybrim.top/</id>
  
  <author>
    <name>Wiley</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>css 布局</title>
    <link href="https://skybrim.top/2020/09/24/web/css-layout/"/>
    <id>https://skybrim.top/2020/09/24/web/css-layout/</id>
    <published>2020-09-24T07:04:08.000Z</published>
    <updated>2020-12-10T02:48:42.069Z</updated>
    
    <content type="html"><![CDATA[<p>简单备忘<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Introduction" target="_blank" rel="noopener">css布局</a></p><a id="more"></a><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display: block; &#x2F;&#x2F; 块</span><br></pre></td></tr></table></figure><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display: inline; &#x2F;&#x2F; 内联</span><br></pre></td></tr></table></figure><h3 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display: inline-block; &#x2F;&#x2F; 中间状态</span><br></pre></td></tr></table></figure><p>一个元素使用 display: inline-block，实现我们需要的块级的部分效果：</p><p>设置width 和height 属性会生效；padding, margin, 以及border 会推开其他元素。</p><p>但是，它不会跳转到新行，如果显式添加 width 和 height 属性，它只会变得比其内容更大。</p><h3 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br></pre></td></tr></table></figure><p>Flexbox用于设计横向或纵向的布局</p><p>在想要进行flex布局的父元素上应用display: flex ，所有直接子元素都将会按照flex进行布局</p><h3 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display: grid;</span><br></pre></td></tr></table></figure><p>Grid布局则被设计用于同时在两个维度上把元素按行和列排列整齐。</p><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display: table;</span><br></pre></td></tr></table></figure><p>被用于兼容一些不支持Flexbox和Grid的浏览器。</p><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float: left;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; left — 将元素浮动到左侧。</span><br><span class="line">&#x2F;&#x2F; right — 将元素浮动到右侧。</span><br><span class="line">&#x2F;&#x2F; none — 默认值, 不浮动。</span><br><span class="line">&#x2F;&#x2F; inherit — 继承父元素的浮动属性。</span><br></pre></td></tr></table></figure><p>把一个元素“浮动”(float)起来，会改变该元素本身和在正常布局流（normal flow）中跟随它的其他元素的行为。</p><p>这一元素会浮动到左侧或右侧，并且从正常布局流(normal flow)中移除，这时候其他的周围内容就会在这个被设置浮动(float)的元素周围环绕。</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="静态定位"><a href="#静态定位" class="headerlink" title="静态定位"></a>静态定位</h3><p>将元素放在文档布局流的默认位置</p><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: relative;</span><br></pre></td></tr></table></figure><p>相对定位(relative positioning)让你能够把一个正常布局流(normal flow)中的元素从它的默认位置按坐标进行相对移动</p><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br></pre></td></tr></table></figure><p>将元素移出正常布局流(normal flow)，以坐标的形式相对于它的容器定位到web页面的任何位置，以创建复杂的布局。</p><h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: fixed;</span><br></pre></td></tr></table></figure><p>固定定位(fixed positioning)同绝对定位(absolute positioning)一样，将元素从文档流(document flow)当中移出了。</p><p>但是，定位的坐标不会应用于”容器”边框来计算元素的位置，而是会应用于视口(viewport)边框。</p><p>利用这一特性，我们可以轻松搞出一个固定位置的菜单，而不受底下的页面滚动的影响。</p><h3 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: sticky;</span><br></pre></td></tr></table></figure><p>将默认的静态定位(static positioning)和固定定位(fixed positioning)相混合。</p><p>当一个元素被指定了position: sticky时，它会在正常布局流中滚动，直到它出现在了我们给它设定的相对于容器的位置，这时候它就会停止随滚动移动，就像它被应用了position: fixed一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单备忘&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Introduction&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;css布局&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="web" scheme="https://skybrim.top/tags/web/"/>
    
      <category term="css" scheme="https://skybrim.top/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css 盒模型</title>
    <link href="https://skybrim.top/2020/09/24/web/css-box-model/"/>
    <id>https://skybrim.top/2020/09/24/web/css-box-model/</id>
    <published>2020-09-24T02:28:02.000Z</published>
    <updated>2020-12-10T02:48:42.069Z</updated>
    
    <content type="html"><![CDATA[<p>css 盒模型</p><a id="more"></a><h2 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h2><ul><li>Content box: 这个区域是用来显示内容，大小可以通过设置 width 和 height.</li><li>Padding box: 包围在内容区域外部的空白区域； 大小通过 padding 相关属性设置。</li><li>Border box: 边框盒包裹内容和内边距。大小通过 border 相关属性设置。</li><li>Margin box: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 margin 相关属性设置。</li></ul><p>在标准模型中，如果你给盒设置 width 和 height，实际设置的是 content box。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。</p><p>margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。盒子的范围到边框为止 —— 不会延伸到margin。</p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/css-box-mode.png" alt=""></p><h2 id="替代盒模型"><a href="#替代盒模型" class="headerlink" title="替代盒模型"></a>替代盒模型</h2><p>box-sizing: border-box;</p><p>使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分</p><h2 id="外边距-margin"><a href="#外边距-margin" class="headerlink" title="外边距 margin"></a>外边距 margin</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">margin-top</span><br><span class="line">margin-right</span><br><span class="line">margin-bottom</span><br><span class="line">margin-left</span><br></pre></td></tr></table></figure><p>外边距是盒子周围一圈看不到的空间。它会把其他元素从盒子旁边推开。 </p><p>外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。</p><p>无论使用标准模型还是替代模型，外边距总是在计算可见部分后额外添加。</p><p>如果你有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小。</p><p>在下面的例子中，我们有两个段落。<br>顶部段落的页 margin-bottom为50px。第二段的margin-top 为30px。<br>因为外边距折叠的概念，所以框之间的实际外边距是50px，而不是两个外边距的总和。</p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/css-fold-margin.png" alt=""></p><h2 id="边框-border"><a href="#边框-border" class="headerlink" title="边框 border"></a>边框 border</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">border-top</span><br><span class="line">border-right</span><br><span class="line">border-bottom</span><br><span class="line">border-left</span><br><span class="line"></span><br><span class="line">border-width</span><br><span class="line">border-style</span><br><span class="line">border-color</span><br><span class="line"></span><br><span class="line">border-top-width</span><br><span class="line">border-top-style</span><br><span class="line">border-top-color</span><br><span class="line">border-right-width</span><br><span class="line">border-right-style</span><br><span class="line">border-right-color</span><br><span class="line">border-bottom-width</span><br><span class="line">border-bottom-style</span><br><span class="line">border-bottom-color</span><br><span class="line">border-left-width</span><br><span class="line">border-left-style</span><br><span class="line">border-left-color</span><br></pre></td></tr></table></figure><p>边框是在边距和填充框之间绘制的。</p><p>如果您正在使用标准的盒模型，边框的大小将添加到框的宽度和高度。</p><p>如果您使用的是替代盒模型，那么边框的大小会使内容框更小，因为它会占用一些可用的宽度和高度。</p><h2 id="内边距-padding"><a href="#内边距-padding" class="headerlink" title="内边距 padding"></a>内边距 padding</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">padding-top</span><br><span class="line">padding-right</span><br><span class="line">padding-bottom</span><br><span class="line">padding-left</span><br></pre></td></tr></table></figure><p>内边距位于边框和内容区域之间。</p><p>与外边距不同，您不能有负数量的内边距，所以值必须是0或正的值。</p><p>应用于元素的任何背景都将显示在内边距后面，内边距通常用于将内容推离边框。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css 盒模型&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="web" scheme="https://skybrim.top/tags/web/"/>
    
      <category term="css" scheme="https://skybrim.top/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>react-useReducer-useContext</title>
    <link href="https://skybrim.top/2020/09/23/web/react-useReducer-useContext/"/>
    <id>https://skybrim.top/2020/09/23/web/react-useReducer-useContext/</id>
    <published>2020-09-23T08:19:44.000Z</published>
    <updated>2020-12-10T02:48:42.069Z</updated>
    
    <content type="html"><![CDATA[<p>react 通过使用 useReducer和useContext，实现类似 redux 的效果</p><a id="more"></a><h2 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h2><p>利用 useContext，将 state 和 dispatch 升格共享出去</p><p>利用 useMemo 和 useCallback 优化</p><h2 id="使用时机"><a href="#使用时机" class="headerlink" title="使用时机"></a>使用时机</h2><ol><li>如果页面的 state 很简单，直接使用 useState</li><li>如果页面的 state 比较复杂，使用 useReducer</li><li>如果页面的层级比较深，并且需要子组件触发 state 的变化，使用 useReducer + useContext</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 state</span></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">    name: <span class="string">''</span>,</span><br><span class="line">    pwd: <span class="string">''</span>,</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">    error: <span class="string">''</span>,</span><br><span class="line">    isLoggedIn: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 reducer 函数</span></span><br><span class="line"><span class="keyword">const</span> loginReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'changeUserName'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                name: action.value,</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'changePassword'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                pwd: action.value,</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'login'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                isLoading: <span class="literal">true</span>,</span><br><span class="line">                error: <span class="string">''</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'success'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                isLoading: <span class="literal">false</span>,</span><br><span class="line">                isLoggedIn: <span class="literal">true</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'error'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                error: action.payload.error,</span><br><span class="line">                name: <span class="string">''</span>,</span><br><span class="line">                pwd: <span class="string">''</span>,</span><br><span class="line">                isLoading: <span class="literal">false</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 context</span></span><br><span class="line"><span class="keyword">const</span> LoginContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// component</span></span><br><span class="line"><span class="keyword">const</span> LoginPage = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [state, dispatch] = useReducer(loginReducer, initState);</span><br><span class="line">    <span class="comment">// 背景色，改变背景色，不会导致子组件重新渲染</span></span><br><span class="line">    <span class="keyword">const</span> [color, setColor] = useState(<span class="string">'blue'</span>);</span><br><span class="line">    <span class="keyword">const</span> changeUserName = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: <span class="string">'changeUserName'</span>,</span><br><span class="line">            value: e.target.value,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> changePassword = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: <span class="string">'changePassword'</span>,</span><br><span class="line">            value: e.target.value,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;LoginContext.Provider value=&#123;&#123;state, dispatch&#125;&#125;&gt;</span><br><span class="line">            &lt;div className=<span class="string">'background'</span> style=&#123;&#123;<span class="attr">backgroundColor</span>:color&#125;&#125;&gt;</span><br><span class="line">                &lt;input placeholder=<span class="string">'username'</span> value=&#123;state.name&#125; onChange=&#123;changeUserName&#125;/&gt;</span><br><span class="line">                &lt;br/&gt;</span><br><span class="line">                &lt;input placeholder=<span class="string">'password'</span> value=&#123;state.pwd&#125; onChange=&#123;changePassword&#125;/&gt;</span><br><span class="line">                &lt;LoginButton /&gt;</span><br><span class="line">                &lt;button onClick=&#123;()=&gt;&#123;setColor(color === <span class="string">'blue'</span> ? <span class="string">'red'</span>:<span class="string">'blue'</span>)&#125;&#125;&gt;Change Color&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/LoginContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> LoginButton = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 共享出来的 state 和 dispatch</span></span><br><span class="line">    <span class="keyword">const</span> &#123;state, dispatch&#125; = useContext(LoginContext)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// useCallback</span></span><br><span class="line">    <span class="keyword">const</span> login = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;<span class="attr">type</span>: <span class="string">'login'</span>&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'======'</span>, state.name, state.pwd);</span><br><span class="line">        <span class="comment">//发起请求</span></span><br><span class="line">        <span class="comment">// Axios.post()</span></span><br><span class="line">        <span class="comment">//     .then(() =&gt; &#123;</span></span><br><span class="line">        <span class="comment">//         dispatch(&#123;type: 'success'&#125;);</span></span><br><span class="line">        <span class="comment">//     &#125;)</span></span><br><span class="line">        <span class="comment">//     .catch((error) =&gt; &#123;</span></span><br><span class="line">        <span class="comment">//         dispatch(&#123;</span></span><br><span class="line">        <span class="comment">//             type: 'error',</span></span><br><span class="line">        <span class="comment">//             payload: &#123;error: error.message&#125;</span></span><br><span class="line">        <span class="comment">//         &#125;);</span></span><br><span class="line">        <span class="comment">//     &#125;);</span></span><br><span class="line">    &#125;, [state.name, state.pwd, dispatch]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// useMemo</span></span><br><span class="line">    <span class="keyword">return</span> useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'LoginButton is rendering.'</span>)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;login&#125;&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;, [login]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;react 通过使用 useReducer和useContext，实现类似 redux 的效果&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="web" scheme="https://skybrim.top/tags/web/"/>
    
      <category term="react" scheme="https://skybrim.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>css-selectors</title>
    <link href="https://skybrim.top/2020/09/23/web/css-selectors/"/>
    <id>https://skybrim.top/2020/09/23/web/css-selectors/</id>
    <published>2020-09-23T08:14:00.000Z</published>
    <updated>2020-12-10T02:48:42.069Z</updated>
    
    <content type="html"><![CDATA[<p>css selectors 备忘</p><a id="more"></a><p>基础</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* id选择器 */</span></span><br><span class="line"><span class="selector-id">#unique</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* class选择器 */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tag选择器 */</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>延伸写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* space 后代选择器 */</span></span><br><span class="line"><span class="comment">/* 当使用 空格 连接两个元素时，</span></span><br><span class="line"><span class="comment">使得该选择器可以只匹配那些由第一个元素作为祖先元素的所有第二个元素(后代元素)，</span></span><br><span class="line"><span class="comment">不包含第一个元素 */</span></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;&#125; <span class="comment">/* 每一个 &lt;div&gt; 下的 &lt;span&gt; 元素 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &gt; 子选择器 */</span></span><br><span class="line"><span class="comment">/* 使用 &gt; 选择符分隔两个元素时,它只会匹配那些作为第一个元素的直接后代(子元素)的第二元素 */</span></span><br><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">span</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* + 相邻兄弟选择器  */</span></span><br><span class="line"><span class="comment">/* 使用 + 介于两个选择器之间，当第二个元素紧跟在第一个元素之后，</span></span><br><span class="line"><span class="comment">并且两个元素都是属于同一个父元素的子元素，则第二个元素将被选中。 */</span></span><br><span class="line"><span class="selector-tag">img</span> + <span class="selector-tag">p</span> &#123;&#125; <span class="comment">/* 图片后面紧跟着的段落将被选中 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ~ 兄弟选择器 */</span></span><br><span class="line"><span class="comment">/* 位置无须紧邻，只须同层级，A~B 选择A元素之后所有同层级B元素 */</span></span><br><span class="line"><span class="selector-tag">p</span> ~ <span class="selector-tag">span</span> &#123;&#125; <span class="comment">/* &lt;p&gt; 后面跟着的 &lt;span&gt; 被选中*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* * */</span></span><br><span class="line"><span class="comment">/* 所有的 html 元素，一般搭配其他符号进行筛选使用 */</span></span><br><span class="line"><span class="selector-class">.container</span> ~ * &#123;&#125; <span class="comment">/* class="container" 元素同层的所有 html 元素 */</span></span><br></pre></td></tr></table></figure><p>属性选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[title]</span> &#123;&#125; <span class="comment">/* 存在title属性的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">"https://example.com"</span>]</span> &#123;&#125; <span class="comment">/* 存在href属性并且属性值匹配"https://example.org"的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">"example"</span>]</span> &#123;&#125; <span class="comment">/* 存在href属性并且属性值包含"example"的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">"insensitive"</span> i]</span> &#123;&#125; <span class="comment">/* 包含 "insensitive" 的链接,不区分大小写 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">"cAsE"</span> s]</span> &#123;&#125; <span class="comment">/* 包含 "cAsE" 的链接，区分大小写 */</span> </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">"#"</span>]</span> &#123;&#125; <span class="comment">/* 以 "#" 开头的页面本地链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">".org"</span>]</span> &#123;&#125; <span class="comment">/* 存在href属性并且属性值结尾是".org"的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[class~=<span class="string">"logo"</span>]</span> &#123;&#125; <span class="comment">/* 存在class属性并且属性值包含以空格分隔的"logo"的&lt;a&gt;元素 */</span></span><br></pre></td></tr></table></figure><p>伪类选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 伪类选择器 */</span></span><br><span class="line"><span class="comment">/* 指定要选择的元素的特殊状态 */</span></span><br><span class="line"><span class="comment">/* https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes */</span></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;&#125; <span class="comment">/* 所有用户指针悬停的按钮 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;&#125; <span class="comment">/* 浏览过的 a 标签 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(2)</span> &#123;&#125; <span class="comment">/* 第 2 个子元素 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 伪元素选择器 */</span></span><br><span class="line"><span class="comment">/* 指定被选择元素的特定部分 */</span></span><br><span class="line"><span class="comment">/* https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;&#125; <span class="comment">/* 每一个 &lt;p&gt; 元素的第一行。 */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css selectors 备忘&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="web" scheme="https://skybrim.top/tags/web/"/>
    
      <category term="css" scheme="https://skybrim.top/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>homebrew-source</title>
    <link href="https://skybrim.top/2020/08/08/inbox/homebrew-source/"/>
    <id>https://skybrim.top/2020/08/08/inbox/homebrew-source/</id>
    <published>2020-08-08T04:23:38.000Z</published>
    <updated>2020-12-10T02:48:42.064Z</updated>
    
    <content type="html"><![CDATA[<p>Homebrew 换源</p><a id="more"></a><p><a href="https://lug.ustc.edu.cn/wiki/lug/services/mirrors" target="_blank" rel="noopener">中科大开源软件镜像服务</a></p><h2 id="切换中科大的镜像"><a href="#切换中科大的镜像" class="headerlink" title="切换中科大的镜像"></a>切换中科大的镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换brew.git:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换homebrew-core.git:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># Homebrew cask 软件仓库，提供 macOS 应用和大型二进制文件</span></span><br><span class="line"><span class="comment"># 替换homebrew-cask.git:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>"</span>/Library/Taps/homebrew/homebrew-cask</span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换 Homebrew Bottles，这是Homebrew提供的二进制代码包</span></span><br><span class="line"><span class="comment"># zsh</span></span><br><span class="line"><span class="built_in">export</span> HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles</span><br></pre></td></tr></table></figure><h2 id="切回官方"><a href="#切回官方" class="headerlink" title="切回官方"></a>切回官方</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重置brew.git:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://github.com/Homebrew/brew.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置homebrew-core.git:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://github.com/Homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置homebrew-cask.git:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>"</span>/Library/Taps/homebrew/homebrew-cask</span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://github.com/Homebrew/homebrew-cask</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Homebrew 换源&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="inbox" scheme="https://skybrim.top/tags/inbox/"/>
    
      <category term="homebrew" scheme="https://skybrim.top/tags/homebrew/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历</title>
    <link href="https://skybrim.top/2020/07/27/algorithm/tree-traversal/"/>
    <id>https://skybrim.top/2020/07/27/algorithm/tree-traversal/</id>
    <published>2020-07-27T01:53:37.000Z</published>
    <updated>2020-12-10T02:48:42.064Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树遍历</p><a id="more"></a><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    pre_order_traversal(root) <span class="comment"># 前序遍历</span></span><br><span class="line">    <span class="comment"># in_order_traversal(root) # 中序遍历</span></span><br><span class="line">    <span class="comment"># post_order_traversal(root) # 后续遍历</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_order_traversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    result += [root.val]</span><br><span class="line">    <span class="keyword">if</span> root.left:</span><br><span class="line">        pre_order_traversal(root.left)</span><br><span class="line">    <span class="keyword">if</span> root.right:</span><br><span class="line">        pre_order_traversal(root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_order_traversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> root.left:</span><br><span class="line">        in_order_traversal(root.left)</span><br><span class="line">    result += [root.val]</span><br><span class="line">    <span class="keyword">if</span> root.right:</span><br><span class="line">        in_order_traversal(root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_order_traversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> root.left:</span><br><span class="line">        post_order_traversal(root.left)</span><br><span class="line">    <span class="keyword">if</span> root.right:</span><br><span class="line">        post_order_traversal(root.right)</span><br><span class="line">    result += [root.val]</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    queue = deque()</span><br><span class="line">    result = []</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        result += [node.val]</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树遍历&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://skybrim.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://skybrim.top/2020/07/27/algorithm/sort/"/>
    <id>https://skybrim.top/2020/07/27/algorithm/sort/</id>
    <published>2020-07-27T01:46:17.000Z</published>
    <updated>2020-12-10T03:20:26.367Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, (<span class="keyword">int</span>)nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[l];</span><br><span class="line">        <span class="keyword">int</span> index = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                ++index;</span><br><span class="line">                swap(nums[i], nums[index]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[l], nums[index]);</span><br><span class="line">        quickSort(nums, l, index<span class="number">-1</span>);</span><br><span class="line">        quickSort(nums, index+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://skybrim.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>swift string</title>
    <link href="https://skybrim.top/2020/07/09/ios/swift-str/"/>
    <id>https://skybrim.top/2020/07/09/ios/swift-str/</id>
    <published>2020-07-09T08:49:40.000Z</published>
    <updated>2020-12-10T02:48:42.068Z</updated>
    
    <content type="html"><![CDATA[<p>swift string</p><a id="more"></a><p>Swift 中的 String 是 Character 值的集合，Character 是人在阅读文字时所理解的单个字符，与该字符由多少个 Unicode 标量组成无关。</p><p>因此，count、prefix(5) 等标准 Collection 操作也会在人所理解的字符上进行。</p><p>但是，也带来了一些性能问题：String 不支持随机访问，即跳到字符串某个随机的字符不是一个 O(1) 的操作，必须查看前面的所有字符，才能确定这个字符的位置。</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>下面列出 Unicode 的一些基本概念</p><p><strong>编码点（code point）</strong>：Unicode 中最基础的原件叫做编码点。举例：欧元符合（€）：U+20AC</p><p><strong>Unicode 标量（Unicode scalar）</strong>：编码点中除了 0xD800 - 0xDFFF 之外的值，都可以叫做 Unicode 标量。</p><p><strong>代理编码点（surrogate code points）</strong>：0xD800 - 0xDFFF 这 2048 个值叫做代理编码点，在 UTF-16 编码中用于表示值大于 65535 的字符。</p><p><strong>编码单元（code units）</strong>：Unicode 编码方式中使用的最小实体叫做编码单元。举例：UTF-8 的编码单元的宽度是 8 比特。</p><p><strong>（扩展）字位簇（(extended)grapheme cluster）</strong>：即用户在屏幕上看到的“单个字符”，可能是一个或者多个 Unicode 标量组合起来的。</p><p>Unicode 是一个可变长格式：</p><pre><code>1. 一个 Unicode 字符（扩展字位簇），由一个或多个 Unicode 标量组成2. 一个 Unicode 标量，可以被编码成一个或多个编码单元</code></pre><h2 id="标准等价"><a href="#标准等价" class="headerlink" title="标准等价"></a>标准等价</h2><ul><li>合并标记</li></ul><p>é，这个字位簇，在 Unicode 中可以使单一的标量（U+00E9），也可以是是普通字符 e 后面跟着（U+0301）。</p><p>Unicode 规范将上述称作<strong>标准等价</strong>。</p><p>Swift 中，Unicode 标量的形式如 \u{xxxx}，类型是 Unicode.Scalar，是一个 struct。举例：欧元符合（€）：\u{20AC}</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> single = <span class="string">"Pok\u&#123;00E9&#125;mon"</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="string">"Poke\u&#123;0301&#125;mon"</span></span><br><span class="line"><span class="comment">// 显示一样 都是 Pokémon</span></span><br><span class="line">(single, douuble)</span><br><span class="line"><span class="comment">// 字符数一样</span></span><br><span class="line">single.<span class="built_in">count</span> <span class="comment">// 7</span></span><br><span class="line">double.<span class="built_in">count</span> <span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 比较，结果相等</span></span><br><span class="line">single == double <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unicode 标量，不一样</span></span><br><span class="line">single.unicodeScalars.<span class="built_in">count</span> <span class="comment">// 7</span></span><br><span class="line">double.unicodeScalars.<span class="built_in">count</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>如果将两个字符串转为 Foundation 框架的 NSString，两个字符串<strong>不相等</strong>，length 也不相同。</p><p>因为 NSString（也包括其他语言大部分字符串 API），会在 UTF-16 编码单元的层面上，按照字面量比较，而不会将不同字符组合起来的等价性纳入考虑。优势就是<strong>速度快</strong>。如果按照标准等价比较，需要使用 NSString.compare(_:)方法。</p><ul><li>Emoji</li></ul><p>很多 Emoji 的 Unicode 标量，无法通过单个 UTF-16 编码单元来表示，因此 java 等其他语言会认为 😂 是两个“字符”长。</p><p>但是 swift 可以正确处理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oneEmoji = <span class="string">"😂"</span> <span class="comment">//U+1F602</span></span><br><span class="line">oneEmoji.<span class="built_in">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="字符串和集合"><a href="#字符串和集合" class="headerlink" title="字符串和集合"></a>字符串和集合</h2><p>Swift 4 后，String 重新成为了 Collection</p><ul><li>边界情况</li></ul><p>两个集合相连接，一般假设新集合的长度是两个相连集合的长度之和。</p><p>但是对于字符串，如果前集合的末尾和后集合的开头可以组成一个新的字位簇，则可能不相等。</p><ul><li>双向索引，而非随机访问</li></ul><p>String 不支持随机访问，因此 String 只实现了 BidirectionalCollection。</p><p>String 可以从字符串的头或者尾部开始，向后或者向前移动，每次只能迭代一个字符。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取字符串索引的集合 indices 是一个 O(n) 的操作</span></span><br><span class="line"><span class="comment">// 但是获取索引后的 map 中的下标操作就是 O(1) 了</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allPrefixes: [<span class="type">Substring</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">""</span>] + <span class="built_in">indices</span>.<span class="built_in">map</span>&#123; index <span class="keyword">in</span> <span class="keyword">self</span>[...index] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"Hello"</span>.allPrefixes <span class="comment">// ["", "H", "He", "Hel", "Hell", "Hello"]</span></span><br></pre></td></tr></table></figure><ul><li>范围可替换，而非可变</li></ul><p>String 还实现了 RangeReplaceableCollection 协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello, world!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> comma = greeting.index(of:<span class="string">","</span>) &#123;</span><br><span class="line">    greeting[..&lt;comma] <span class="comment">// hello</span></span><br><span class="line">    greeting.replaceSubrange(comma..., with:<span class="string">"again."</span>)</span><br><span class="line">&#125;</span><br><span class="line">greeting <span class="comment">// Hello again.</span></span><br></pre></td></tr></table></figure><p>注意，用于替换的字符串，可能与原字符串相邻字符形成新的字位簇</p><h2 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h2><p>String.Index 是 String 所使用的的索引类型，本质是一个存储了从字符串开头的字节偏移量的不透明值。</p><p>一旦有了有效的索引，可以通过索引下标以 O(1) 的时间对字符串进行访问，通过已有索引来寻找下一个索引也更高效。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"abcdef"</span></span><br><span class="line"><span class="keyword">let</span> second = s.index(after: s.startIndex)</span><br><span class="line">s[second] <span class="comment">//b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//步进 4 个字符</span></span><br><span class="line"><span class="keyword">let</span> sixth = s.index(second, offsetBy: <span class="number">4</span>)</span><br><span class="line">s[sixth] <span class="comment">// f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> safeIdx = s.index(s.startIndex, offsetBy: <span class="number">400</span>, limitedBy: s.endIndex)</span><br><span class="line">safeIdx <span class="comment">// nil</span></span><br><span class="line"></span><br><span class="line">s[..&lt;s.index(s.startIndex, offsetBy: <span class="number">4</span>)] <span class="comment">// abcd</span></span><br><span class="line">s.<span class="keyword">prefix</span>(<span class="number">4</span>) <span class="comment">// abcd</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="string">"2020-07-01"</span></span><br><span class="line">date.<span class="built_in">split</span>(separator: <span class="string">"-"</span>)[<span class="number">1</span>] <span class="comment">// 09</span></span><br><span class="line">date.<span class="built_in">dropFirst</span>(<span class="number">5</span>).<span class="keyword">prefix</span>(<span class="number">2</span>) <span class="comment">// 09</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">"Hello!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> idx = hello.firstIndex(of: <span class="string">"!"</span>) &#123;</span><br><span class="line">    hello.insert(contentsOf: <span class="string">", world"</span>, at: idx)</span><br><span class="line">&#125;</span><br><span class="line">hello <span class="comment">// Hello, world!</span></span><br></pre></td></tr></table></figure><h2 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h2><p>String 的 SubSequence 类型：Substring。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展一个接受含有多个分隔符的序列作为参数的 spilt 方法</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">split</span>&lt;S: Sequence&gt;<span class="params">(separators: S)</span></span> -&gt; [<span class="type">SubSequence</span>]</span><br><span class="line">        <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">S</span>.<span class="type">Element</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">split</span> &#123; separators.<span class="built_in">contains</span>($<span class="number">0</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>StringProtocol</li></ul><p>String 和 Substring 都遵守 StringProtocol 协议，字符串几乎所有 API 都定义在这个协议里。</p><p>不建议长期持有子字符串，这是因为子字符串会一直持有整个原始字符串。</p><p>通常，在一个操作内部使用子字符串，而只在结束时创建新字符串，将赋值操作推迟到最后一刻，这样可以确保是最低开销。</p><p>如果想扩展 String，可以将这个扩展放在 StringProtocol，可以保持 String 和 Substring 的 API 统一性。</p><h2 id="String-与-NSString"><a href="#String-与-NSString" class="headerlink" title="String 与 NSString"></a>String 与 NSString</h2><p>任意的 String 实例，可以通过 as 操作桥接为 NSString，那些接受或者返回 NSString 的 Objective-C API 也会把类型自动转换为 String。</p><p>Swift 中 String 的编译器优化：引入 Foundation 后，NSString 成员可以在 String 的实例上进行访问。</p><p>由于 Swift String 在内存中的原生编码是 UTF-8，而 NSString 是 UTF-16，因此频繁的在 string 和 NSString 之间桥接会有额外性能开销。</p><p>举例：</p><p>NSAttributeString 的 API <code>attributes(at: Int, effectiveRange: NSRangePointer?)</code> </p><p>接受的是一个整数索引（UTF-16 测量），非 String.Index</p><p>通过指针返回的 effectiveRange，是一个 NSRange 结构体，而非 Range&lt;String.Index&gt;</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为字符串中的 “Click here” 添加一个链接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">"👉 Click here for more info."</span></span><br><span class="line"><span class="keyword">let</span> linkTarget = <span class="type">URL</span>(string: <span class="string">"https://www.baidu.com"</span>)!</span><br><span class="line"><span class="keyword">let</span> formatter = <span class="type">NSMutableAttributedString</span>(string: text)</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改文本的部分属性</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> linkRange = formatted.string.range(of: <span class="string">"Click here"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> nsRange = <span class="type">NSRange</span>(linkRange, <span class="keyword">in</span>: formatted.string) <span class="comment">// &#123;3, 10&#125;</span></span><br><span class="line">    formatted.addAttribute(.link, value:linkTarget, range: nsRange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> queryRange = formatted.string.range(of: <span class="string">"here"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> nsRange = <span class="type">NSRange</span>(queryRange, <span class="keyword">in</span>: formatted.string)</span><br><span class="line">    <span class="keyword">var</span> attributesRange = <span class="type">NSRange</span>()</span><br><span class="line">    <span class="keyword">let</span> attributes = formatted.attributes(at: nsRange.location, effectiveRange: &amp;attributesRange)</span><br><span class="line"></span><br><span class="line">    attributesRange <span class="comment">// &#123;3, 10&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 NSRange 转为 Range&lt;String.Index&gt;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> effectiveRange = <span class="type">Range</span>(attributesRange, <span class="keyword">in</span>: formatted.string) &#123;</span><br><span class="line">        formatted.string[effectiveRange] <span class="comment">// Click here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CharacterSet</li></ul><p>CharacterSet 是 Foundation 中的类型，实际上它表示一系列 Unicode 标量的数据结构体，和 Character 类型不兼容。</p><p>CharacterSet 提供了一些工厂初始化方法，.alphanumerics 、 .whitespacesAndNewlines。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为 emoji 中，女人 + ZWJ + 消防车 = 女消防员</span></span><br><span class="line"><span class="comment">// ZWJ 零连接符:U+200D</span></span><br><span class="line"><span class="keyword">let</span>  favoriteEmoji = <span class="type">CharacterSet</span>(<span class="string">"👩‍🚒"</span>.unicodeScalars)</span><br><span class="line">favoriteEmoji.<span class="built_in">contains</span>(<span class="string">"🚒"</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Unicode-属性"><a href="#Unicode-属性" class="headerlink" title="Unicode 属性"></a>Unicode 属性</h2><ul><li>Unicode.Scalar</li></ul><p>Swift5 中，CharacterSet 的部分功能移植到了 Unicode.Scalar</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">"😀"</span> <span class="keyword">as</span> <span class="type">Unicode</span>.<span class="type">Scalar</span>).properties.isEmoji <span class="comment">// true</span></span><br><span class="line">(<span class="string">"∬"</span> <span class="keyword">as</span> <span class="type">Unicode</span>.<span class="type">Scalar</span>).properties.isMath <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="String-和-Character-的内部结构"><a href="#String-和-Character-的内部结构" class="headerlink" title="String 和 Character 的内部结构"></a>String 和 Character 的内部结构</h2><ul><li>String</li></ul><p>Swift5 里，原生字符串的内存是使用 UTF-8 格式表示的。因此遍历 UTF-8 视图会比遍历 UTF-16 或 Unicode标量 视图更快。</p><p>小于 16 个（32 位平台是 11 个）UTF-8 编码单元的小型字符串，Swift 不会为其创建专门的存储缓冲区，而是直接使用内连的方式存储。</p><ul><li>Character</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _str: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>(unchecked str: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>._str = str</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可知，一个 Character 在内部被表示为长度为 1 的字符串。</p><p>Swift5 之后，Character 的优化通过 String 自身的优化实现小字符串优化。</p><h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h2><p>“”是字符串字面量，通过 ExpressibleByStringLiteral 协议实现。</p><p>字符串字面量是 ExpressibleByStringLiteral，ExpressibleByExtendedGraphemeClusterLiteral 和 ExpressibleByUnicodeScalarLiteral 三个协议的一部分。其中，每个协议都约束了一个用它们各自表示的字面量 创建对象的 init方法。但除非你真的需要根据 Unicode标量还是字位族仔细调整初始化逻辑， 否则，只需要实现字符串的版本就好。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义类型 SafeHTML 支持字符串字面量创建。</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> htmlEscaped: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// 简单的 仅替换所有开闭尖括号</span></span><br><span class="line">        <span class="keyword">return</span> replacingOccurrences(of: <span class="string">"&lt;"</span>, with: <span class="string">"&amp;lt;"</span>).replacingOccurrences(of: <span class="string">"&gt;"</span>, with: <span class="string">"&amp;gt;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SafeHTML</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> value: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(unsafe html: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = html.htmlEscaped</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SafeHTML</span>: <span class="title">ExpressibleByStringLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(stringLiteral value: <span class="type">StringLiteralType</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> safe: <span class="type">SafeHTML</span> = <span class="string">"&lt;p&gt;Angle brackets in literals are not escaped&lt;/p&gt;"</span></span><br><span class="line"><span class="comment">// SafeHTML(value: "&lt;p&gt;Angle brackets in literals are not escaped&lt;/p&gt;")</span></span><br></pre></td></tr></table></figure><h2 id="定制字符串描述"><a href="#定制字符串描述" class="headerlink" title="定制字符串描述"></a>定制字符串描述</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SafeHTML</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SafeHTML</span>: <span class="title">CustomeDebugStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> debugDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"SafeHTML:\(value)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(safe)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;swift string&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
      <category term="swift" scheme="https://skybrim.top/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift 集合协议</title>
    <link href="https://skybrim.top/2020/07/07/ios/swift-collection-protocol/"/>
    <id>https://skybrim.top/2020/07/07/ios/swift-collection-protocol/</id>
    <published>2020-07-07T06:15:41.000Z</published>
    <updated>2020-12-10T02:48:42.068Z</updated>
    
    <content type="html"><![CDATA[<p>swift 集合协议</p><a id="more"></a><h2 id="标准库中的结合协议架构"><a href="#标准库中的结合协议架构" class="headerlink" title="标准库中的结合协议架构"></a>标准库中的结合协议架构</h2><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/swift-collection-protocol-1.jpg" alt="标准库中的结合协议架构"></p><ul><li><p>Sequence</p><p>  提供了迭代的能力，允许创建一个迭代器</p></li><li><p>Collection</p><p>  支持多次遍历</p><p>  提供通过索引访问元素</p><p>  通过 SubSequence 提供了集合切片的能力，切片自身也是一个集合</p></li><li><p>MutableCollection</p><p>  提供了常数时间内，通过下标更改集合的能力</p><p>  <strong>不允许向集合中添加和删除元素</strong></p></li><li><p>RangeReplaceableCollection</p><p>  提供了替换集合中一个连续区间的元素的能力。</p><p>  通过扩展，衍生出 append 和 remove 等方法</p><p>  Array/String 支持</p><p>  Set/Dictionary 不支持</p></li><li><p>BidirectionalCollection</p><p>  提供了从集合尾部想集合头部遍历的能力</p></li><li><p>RandomAccessCollection</p><p>  提供了更高效的索引计算能力：计算索引的距离或者移动索引位置都是常数时间操作。</p><p>  举例：Array 是随机访问的集合，但是 String 不是，因为计算两个字符之间的举例是一个线性时间的操作。</p></li><li><p>LazySequenceProtocol</p><p>  定义了一个只有在开始遍历时才计算其中元素的<strong>序列</strong>。</p><p>  可以接受一个无穷序列，从中筛选元素，然后读取结果中的前几个记录。</p></li><li><p>LazyCollectionProtocol</p><p>  与 LazySequenceProtocol 类似，定义一个只有在开始遍历时才计算其中元素的<strong>集合类型</strong></p></li></ul><h2 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h2><p>Sequence 1: 有一个关联类型 Element; 2: 有一个创建迭代器的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的 Sequence 定义</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span> <span class="keyword">where</span> <span class="type">Self</span>.<span class="type">Element</span> == <span class="type">Self</span>.<span class="type">Iterator</span>.<span class="type">Element</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span>:  <span class="type">IteratorProtocol</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Self</span>.<span class="type">Iterator</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Iterator（迭代器）</li></ul><p>序列通过创建迭代器来提供对元素的访问。</p><p>迭代器每次产生序列中的一个值，并对序列的遍历状态管理。</p><p>迭代器遵循 IteratorProtocol。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IteratorProtocol 的关联类型 Element 指定了迭代器产生的值得类型。<br>同时在 Sequence 协议中，通过序列的关联类型 ELement 的类型约束<code>where Self.Element == Self.Iterator.Element</code>，指定迭代器及对应序列的元素相同</p><p>IteratorProtocol 协议唯一的方法 next() ，这个方法在每次被调用时返回序列的下一个值，当序列结束，返回 nil。</p><p>迭代器作用：for 循环是通过迭代器实现的</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for 循环的实质</span></span><br><span class="line"><span class="keyword">var</span> iterator = someSequence.makeIterator()</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> element = iterator.next() &#123;</span><br><span class="line">    doSomething(whit:element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器特点：</p><p>单向结构，只能按照增加的方向前进，不能后退或重置。</p><p>通过迭代器不断迭代，可以创建一个无限的序列。</p><ul><li>遵循 Sequence 创建序列</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PrefixIterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> string: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> offset: <span class="type">String</span>.<span class="type">Index</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(string: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.string = string</span><br><span class="line">        offset = string.startIndex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Substring?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> offset &lt; string.endIndex <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        offset = string.index(after: offset)</span><br><span class="line">        <span class="keyword">return</span> string[...&lt;offset]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PrefixSequence</span>: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> string: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">PrefixIterator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">PrefixIterator</span>(string: string)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">prefix</span> <span class="keyword">in</span> <span class="type">PrefixSequence</span>(string: <span class="string">"abc"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">prefix</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">ab</span></span><br><span class="line"><span class="comment">abc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>一些特性</li></ul><ol><li><p>迭代器与值语义：<br>标准库中大部分迭代器都具有值语义，复制后所有状态都会被复制，而且相互独立；</p><p>AnyIterator 是一个队别的迭代器进行封装的迭代器，封装原理是将另外的迭代器包装到一个内部的盒子对象中，而这个对象是引用类型。<br>因此 AnyIterator 对象的复制，可能会导致多个迭代器共享同一个引用。</p></li><li><p>基于函数的迭代器和序列<br>AnyIterator 有可以接受 next 函数作为参数的初始化方法。</p><p>配合 AnySequence，可以在不定义新的类型的情况下，创建迭代器和序列。</p></li><li><p>单词遍历序列<br>Sequence 文档指出，序列并不能保证可以被多次遍历（如网络包流），collection 协议才能保证多次迭代是安全的</p></li><li><p>序列与迭代器关系<br>支持多次遍历的序列，需要独立的遍历状态，所以分离迭代器与序列</p><p>迭代器也可以视为由他们返回的元素所组成的单次遍历序列。<br>只要声明迭代器遵循 Sequence 协议，它就是一个序列类型，Sequence 会为迭代器提供一个默认的 makeIterator 实现，这个方法返回的 self 本身。</p></li></ol><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>集合类型（Collection）指的是那些可以被多次遍历且保持一致的序列。</p><p>除了线性遍历意外，集合中的元素也可以通过下标索引的方式访问。</p><p>集合类型不能是无限的。</p><p>每一个集合类型都有一个关联类型 SubSequence，表示集合中一段连续内容的切片。</p><p>Collection 继承了 Sequence。</p><p>实现 Collection 协议，最难的是选取合适的索引类型来表达集合类型中的位置。</p><p>实现 Collection 的类型:</p><p>swift 标准库：Array/Dictionary/Set/String/[Closed]Range/UnsafeBufferPointer</p><p>Foundation: Data/IndexSet</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除了 Index 和 Element 意外，其他关联类型都是有默认值得，大部分方法、属性、下标也是如此。</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Collection</span> : <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 继承自 Sequence</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span> = <span class="type">IndexingIterator</span>&lt;<span class="type">Self</span>&gt;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Self</span>.<span class="type">Iterator</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Index</span> : <span class="type">Comparable</span> <span class="comment">// 省略大量的 where 语句</span></span><br><span class="line">    <span class="keyword">var</span> startIndex: <span class="type">Self</span>.<span class="type">Index</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> endIndex: <span class="type">Self</span>.<span class="type">Index</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用递归约束表明 SubSequence 自身也是一个集合类型</span></span><br><span class="line">    <span class="comment">// 且 Collection 元素与 SubSequence 元素相同</span></span><br><span class="line">    <span class="comment">// 且 SubSequence 中的 SubSequence 类型与自身相同</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">SubSequence</span> : <span class="type">Collection</span> = <span class="type">Slice</span>&lt;<span class="type">Self</span>&gt; <span class="keyword">where</span> <span class="type">Self</span>.<span class="type">Element</span> == <span class="type">Self</span>.<span class="type">SubSequence</span>.<span class="type">Element</span>, <span class="type">Self</span>.<span class="type">SubSequence</span> == <span class="type">Self</span>.<span class="type">SubSequence</span>.<span class="type">SubSequence</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(position: <span class="type">Self</span>.<span class="type">Index</span>) -&gt; <span class="type">Self</span>.<span class="type">Element</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(bounds: <span class="type">Range</span>&lt;<span class="type">Self</span>.<span class="type">Index</span>&gt;) -&gt; <span class="type">Self</span>.<span class="type">SubSequence</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indices 也是集合类型</span></span><br><span class="line">    <span class="comment">// Collection 中的 Index 是这个 Indices 的元素类型、索引类型以及 Indices.SubSequence 中的索引类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Indices</span> : <span class="type">Collection</span> = <span class="type">DefaultIndices</span>&lt;<span class="type">Self</span>&gt; <span class="keyword">where</span> <span class="type">Self</span>.<span class="type">Indices</span> == <span class="type">Self</span>.<span class="type">Indices</span>.<span class="type">SubSequence</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">indices</span>: <span class="type">Self</span>.<span class="type">Indices</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(<span class="number">_</span> i: <span class="keyword">Self</span>.Index, offsetBy <span class="built_in">distance</span>: Int)</span></span> -&gt; <span class="type">Self</span>.<span class="type">Index</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(<span class="number">_</span> i: <span class="keyword">Self</span>.Index, offsetBy <span class="built_in">distance</span>: Int, limitedBy limit: <span class="keyword">Self</span>.Index)</span></span> -&gt; <span class="type">Self</span>.<span class="type">Index?</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">distance</span><span class="params">(from start: <span class="keyword">Self</span>.Index, to end: <span class="keyword">Self</span>.Index)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: <span class="keyword">Self</span>.Index)</span></span> -&gt; <span class="type">Self</span>.<span class="type">Index</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">formIndex</span><span class="params">(after i: <span class="keyword">inout</span> <span class="keyword">Self</span>.Index)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义集合类型</li></ul><p>实现一个队列（Queue），遵循 Collection</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先展示一个简单的先进先出队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FIFOQueue</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">left</span>: [<span class="type">Element</span>] = []</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">right</span>: [<span class="type">Element</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素添加到队列最后 O(1)</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">enqueue</span><span class="params">(<span class="number">_</span> newElement: Element)</span></span> &#123;</span><br><span class="line">        <span class="keyword">right</span>.append(newElement)</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列前端移除一个元素，队列为空时返回 nil O(1)</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">left</span>.isEmpty &#123;</span><br><span class="line">            <span class="keyword">left</span> = <span class="keyword">right</span>.reversed()</span><br><span class="line">            <span class="keyword">right</span>.removeAll()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span>.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面 Collection 协议的源码分析，我们最后需要实现如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Collection</span>: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个表示序列中元素的类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个表示集合中位置的类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Index</span>: <span class="type">Comparable</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个非空集合中首个元素的位置</span></span><br><span class="line">    <span class="keyword">var</span> startIndex: <span class="type">Index</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比最后一个有效下标大 1 的值</span></span><br><span class="line">    <span class="keyword">var</span> endIndex: <span class="type">Index</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回在给定索引之后的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: Index)</span></span> -&gt; <span class="type">Index</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下标访问特定位置的元素</span></span><br><span class="line">    <span class="keyword">subscript</span>(position: <span class="type">Index</span>) -&gt; <span class="type">Element</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，实现 FIFOQueue，满足 Collection，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FIFOQueue</span>: <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> startIndex: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> endIndex: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="keyword">left</span>.<span class="built_in">count</span> + <span class="keyword">right</span>.<span class="built_in">count</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="built_in">precondition</span>( i &gt;= startIndex &amp;&amp; i &lt; endIndex, <span class="string">"Index out of bounds"</span>)</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">subscript</span>(position: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="built_in">precondition</span>((startIndex..&lt;endIndex).<span class="built_in">contains</span>(position), <span class="string">"Index out of bounds"</span>)</span><br><span class="line">        <span class="keyword">if</span> position &lt; <span class="keyword">left</span>.endIndex &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">left</span>[<span class="keyword">left</span>.<span class="built_in">count</span> - position - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">right</span>[position - <span class="keyword">left</span>.<span class="built_in">count</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数组字面量</li></ul><p>让队列实现 ExpressibleByArrayLiteral 协议，这样可以通过字面量来创建一个队列</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FIFOQueue</span>: <span class="title">ExpressibleByArrayLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(arrayLiteral elements: <span class="type">Element</span>...) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="keyword">left</span>:elements.reversed(), <span class="keyword">right</span>:[])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo: <span class="type">FIFOQueue</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>索引（Index），表示了集合中的位置，集合类型的索引，必须实现 Comparable 协议，即索引必须要有确定的顺序。</p><p>使用字典举例：</p><p>Dictionary，它的索引是 DictionaryIndex 类型，是一个指向字典内部存储缓冲区的不透明值。</p><p>平时使用建访问字典的 subscript(_ key: Key) 方法，是对定义在 Dictionary 中的 subscript 方法的重载。</p><p>字典的 <code>subscript(key: Key) -&gt; Value?</code> ，返回的是一个可选值</p><p>集合类型的 subscript 方法，在 Collection 中，返回的是非可选值 <code>subscript(position: Index) -&gt; Element { get }</code></p><p>注意，Element 类型在字典中是一个元组：(key: Key, value: Value)，所以，Dictionary 的下标访问返回的是一个键值对，也因此对 Dictionary 遍历我们得到的是键值对。</p><ul><li>索引失效</li></ul><p>当集合发生改变时，索引可能会失效：</p><ol><li>索引本身仍然有效，但是指向了另外的元素</li><li>索引本身无效，通过索引访问集合将造成崩溃</li></ol><ul><li>索引步进</li></ul><p>当前 swift 版本，通过给定索引计算新的索引，由集合本身负责。</p><p>这样可以提高性能：</p><p>String ，由于 Character 在 Swift 中的尺寸是可以改变的，因此计算 String 的索引，必须考虑 Character 的实际内容。</p><ul><li>自定义集合索引</li></ul><p>分割集合类型，<code>split</code>方法通常最合适，但是这个方法会计算整个数组。如果数组很大，但是只需要前几个元素，这样做效率低。</p><p>下面用 String(英文) 举例：</p><p>目标是，构建一个 words 集合，它能够让我们不一次性计算出所有单词，而是可以用延迟加载的方式进行迭代。</p><p>首先，从 SubString 中寻找第一个单词的范围。</p><p>使用空格作为单词的边界。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Substring</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nextWordRange: <span class="type">Range</span>&lt;<span class="type">Index</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// 移除所有前置的空格</span></span><br><span class="line">        <span class="keyword">let</span> start = drop(<span class="keyword">while</span>: &#123; $<span class="number">0</span> == <span class="string">" "</span>&#125; )</span><br><span class="line">        <span class="comment">// 寻找结束空格，如果没有，则使用 endIndex</span></span><br><span class="line">        <span class="keyword">let</span> end = start.firstIndex(<span class="keyword">where</span>: &#123; $<span class="number">0</span> == <span class="string">" "</span>&#125;) ?? endIndex</span><br><span class="line">        <span class="keyword">return</span> start.startIndex..&lt;end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二，定义索引的类型。</p><p>通过索引下标访问某个元素，应该是一个 O(1) 的操作，因此封装 Range&lt;Substring.Index&gt; 来作为索引类型。</p><p>索引类型需要满足 Comparable(继承自 Equatable)，此时我们采用 range 的下边界作为比较对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WordsIndex</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">let</span> range: <span class="type">Range</span>&lt;<span class="type">Substring</span>.<span class="type">Index</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">init</span>(<span class="number">_</span> value: <span class="type">Range</span>&lt;<span class="type">Substring</span>.<span class="type">Index</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.range = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;(lhs: Words.Index, rhs: Words.Index) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.range.lowerBound &lt; rhs.range.lowerBound</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Words.Index, rhs: Words.Index)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.range == rhs.range</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三，构建 Words 集合类型。</p><p>在底层将 String 视为 SubString 存储；</p><p>提供两个属性： startIndex 、 endIndex；</p><p>同时，需要遵循 Collection 协议，并实现 subscript 下标方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Words</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> string: <span class="type">Substring</span></span><br><span class="line">    <span class="keyword">let</span> startIndex: <span class="type">WordsIndex</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> endIndex: <span class="type">WordsIndex</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> e = string.endIndex</span><br><span class="line">        <span class="keyword">return</span> <span class="type">WordsIndex</span>(e..&lt;e)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> s: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(s[...])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>(<span class="number">_</span> s: <span class="type">Substring</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.string = s</span><br><span class="line">        <span class="keyword">self</span>.startIndex = <span class="type">WordsIndex</span>(string.nextWordRange)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Words</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">WordsIndex</span>) -&gt; <span class="type">Substring</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> string[index.range]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Words</span>: <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: WordsIndex)</span></span> -&gt; <span class="type">WordsIndex</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> i.range.upperBound &lt; string.endIndex <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> endIndex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> remainder = string[i.range.upperBound...]</span><br><span class="line">        <span class="keyword">return</span> <span class="type">WordsIndex</span>(remainder.nextWordRange)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，使用自定义索引</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Array</span>(<span class="type">Words</span>(<span class="string">"hello world test"</span>)) <span class="comment">// ["hello", "world", "test"]</span></span><br><span class="line"></span><br><span class="line"><span class="type">Array</span>(<span class="type">Words</span>(<span class="string">"Hello world test"</span>).<span class="keyword">prefix</span>(<span class="number">2</span>)) <span class="comment">// ["hello", "world"]</span></span><br></pre></td></tr></table></figure><p>补充：创建自定义集合类型时，优先考虑能否使用其本身作为自己的 SubSequence 使用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Words</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重载 subscript(range:Range&lt;Index&gt;)</span></span><br><span class="line">    <span class="keyword">subscript</span>(range:<span class="type">Range</span>&lt;<span class="type">WordsIndex</span>&gt;) -&gt; <span class="type">Words</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> start = range.lowerBound.range.lowerBound</span><br><span class="line">        <span class="keyword">let</span> end = range.upperBound.range.upperBound</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Words</span>(string[start..&lt;end])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SubSequence"><a href="#SubSequence" class="headerlink" title="SubSequence"></a>SubSequence</h2><p>在 Swift5 中，SubSequence 被定义到了 Collection 协议中，是一个关联类型，表示集合中一个连续的子区间。</p><p>默认情况下，Collection 把 Slice<Self> 作为自己的 SubSequence 类型。</p><p>子序列和原始的集合类型共享内部存储。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">SubSequence</span>: <span class="type">Collection</span> = <span class="type">Slice</span>&lt;<span class="type">Self</span>&gt; </span><br><span class="line">        <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">SubSequence</span>.<span class="type">Element</span>, <span class="type">SubSequence</span> == <span class="type">SubSequence</span>.<span class="type">SubSequence</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展：以每 n 个元素切割集合</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(batchSize: Int)</span></span> -&gt; [<span class="type">SubSequence</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> result: [<span class="type">SubSequence</span>] = []</span><br><span class="line">        <span class="keyword">var</span> batchStart = startIndex</span><br><span class="line">        <span class="keyword">while</span> batchStart &lt; endIndex &#123;</span><br><span class="line">            <span class="keyword">let</span> batchEnd = index(batchStart, offsetBy: batchSize, limitedBy: endIndex) ?? endIndex</span><br><span class="line">            <span class="keyword">let</span> batch = <span class="keyword">self</span>[batchStart..&lt;batchEnd]</span><br><span class="line">            result.append(batch)</span><br><span class="line">            batchStart = batchEnd</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> letters = <span class="string">"abcdefg"</span></span><br><span class="line"><span class="keyword">let</span> batches = letters.<span class="built_in">split</span>(batchSize: <span class="number">3</span>) <span class="comment">// ["abc", "def", "g"]</span></span><br></pre></td></tr></table></figure><ul><li>切片</li></ul><p>所有集合类型，都有切片操作的默认实现，并有一个下标方法：<code>subscript(range:Range&lt;Index&gt;) -&gt; Slice&lt;Base&gt;</code></p><p>Slice 非常适合作为默认的切片类型，不过当创建自定义集合时，优先考虑集合本身作为切片类型。详见 <a href="#Index">Index</a>。</p><p>Slice 是基于任意集合类型的一个轻量级封装：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Slice</span>&lt;<span class="title">Base</span>: <span class="title">Collection</span>&gt;: <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Index</span> = <span class="type">Base</span>.<span class="type">Index</span></span><br><span class="line">    <span class="keyword">let</span> collection: <span class="type">Base</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> startIndex: <span class="type">Index</span></span><br><span class="line">    <span class="keyword">var</span> endIndex: <span class="type">Index</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(base: <span class="type">Base</span>, bounds: <span class="type">Range</span>&lt;<span class="type">Index</span>&gt;) &#123;</span><br><span class="line">        collection = base</span><br><span class="line">        startIndex = bounds.lowerBound</span><br><span class="line">        endIndex = bounds.upperBound</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i:Index)</span></span> -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> collection.index(after: i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(position: <span class="type">Index</span>) -&gt; <span class="type">Base</span>.<span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> collection[position]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(bounds: <span class="type">Range</span>&lt;<span class="type">Index</span>&gt;) -&gt; <span class="type">Slice</span>&lt;<span class="type">Base</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Slice</span>(base: collection, bounds: bounds)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>切片与原集合共享索引</li></ul><p>Collection 协议要求切片的索引和原集合的索引互换使用</p><p>集合类型和它的切片拥有相同的索引。</p><p>只要集合和它的切片在切片被创建后没有改变，切片中的某个索引位置上的元素，应当也存在于原集合中同样的索引位置上。</p><p>推荐使用索引的方式： <code>for index in collection.indices</code>，但不要在迭代时修改集合。</p><h2 id="专门的集合类型"><a href="#专门的集合类型" class="headerlink" title="专门的集合类型"></a>专门的集合类型</h2><p>Collection 有两个限制：</p><ol><li>无法往回移动索引；</li><li>没有提供像插入、移除或替换元素这样的改变集合内容的功能。</li></ol><ul><li>BidirectionalCollection</li></ul><p>一个既支持向前又支持向后遍历的集合，继承 Collection</p><p>提供<code>index(before:)</code>方法把索引往回移动一个位置</p><p>有了向前遍历集合的能力，BidirectionalCollection 实现了一些可以高效执行的方法:suffix，removeLast，reversed</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BidirectionalCollection</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 集合中的最后一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> last: <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty ? <span class="literal">nil</span> : <span class="keyword">self</span>[index(before: endIndex)]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  返回一个表达集合中元素逆序排列的视图，复杂度 O(1)</span></span><br><span class="line">    <span class="comment">// ReversedCollection 并不会真的把元素逆序排列，而是会持有原来的集合</span></span><br><span class="line">    <span class="comment">// 并使用一个定制的索引类型实现逆序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">reversed</span><span class="params">()</span></span> -&gt; <span class="type">ReversedCollection</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ReversedCollection</span>(<span class="number">_</span> base: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RandomAccessCollection</li></ul><p>一个支持高效随机访问索引进行遍历的集合，继承 BidirectionalCollecton</p><p>可以在常数时间内跳转到任意索引，需要在常数时间内完成两个操作：第一，可以任意距离移动一个索引；第二，测量任意两个索引之间的距离。</p><p>实现<code>index(_:offsetBy:)</code>和<code>distance(from:to:)</code>，或者 Index 类型满足 Strideable(比如 Int)</p><p>RandomAccessCollection 以更严格的约束重新声明了关联的 Indices 和 SubSequence 类型，这两个类型自身也必须是可以进行随机存取的。</p><p>补充：二分搜索算法，必须搭配随机存取集合。</p><ul><li>MutableCollection</li></ul><p>一个支持下标赋值的集合，继承自 Collection</p><p>要求：单个元素的下标访问方法<code>subscript</code>现在必须提供一个 setter：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 FIFOQueue 的协议由 Collection 扩展为 MutableCollection</span></span><br><span class="line"><span class="comment">// 队列支持原地的元素更改</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FIFOQueue</span>: <span class="title">MutableCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> startIndex: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> endIndex: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="keyword">left</span>.<span class="built_in">count</span> + <span class="keyword">right</span>.<span class="built_in">count</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="built_in">precondition</span>( i &gt;= startIndex &amp;&amp; i &lt; endIndex, <span class="string">"Index out of bounds"</span>)</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">subscript</span>(position: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">precondition</span>((<span class="number">0</span>..&lt;endIndex).<span class="built_in">contains</span>(position), <span class="string">"Index out of bounds"</span>)</span><br><span class="line">            <span class="keyword">if</span> position &lt; <span class="keyword">left</span>.endIndex &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">left</span>[<span class="keyword">left</span>.<span class="built_in">count</span> - position - <span class="number">1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">right</span>[position - <span class="keyword">left</span>.<span class="built_in">count</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="built_in">precondition</span>((<span class="number">0</span>..&lt;endIndex).<span class="built_in">contains</span>(position), <span class="string">"Index out of bounds"</span>)</span><br><span class="line">            <span class="keyword">if</span> position &lt; <span class="keyword">left</span>.endIndex &#123;</span><br><span class="line">                <span class="keyword">left</span>[<span class="keyword">left</span>.<span class="built_in">count</span> - position - <span class="number">1</span>] = newValue</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">right</span>[position - <span class="keyword">left</span>.<span class="built_in">count</span>] = newValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RangeReplaceableCollection</li></ul><p>一个支持将任意范围的元素用别的集合中的元素进行替换的集合，继承自 Collection</p><p>此协议两个要求：</p><ol><li>一个空的初始化方法；（在泛型函数中很有用，允许一个函数创建相同类型的空集合）</li><li>一个 replaceSubrange(_:with:)方法。（接受一个要替换的范围以及一个用来进行替换的集合）</li></ol><p>只需要实现一个灵活的 replaceSubrange(_:with:)方法，协议扩展就可以引申一系列有用的方法：</p><ol><li>append(_:) 和 append(contentsOf:)</li><li>remove(at:) 和 removeSubrange(_:)</li><li>insert(at:) 和 insert(contentsOf:at:)</li><li>removeAll</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例 FIFOQueue</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FIFOQueue</span>: <span class="title">RangeReplaceableCollection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">replaceSubrange</span>&lt;C:Collection&gt; <span class="params">(<span class="number">_</span> subrange: Range&lt;Int&gt;, with newElements: C)</span></span></span><br><span class="line">        <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">            <span class="keyword">right</span> = <span class="keyword">left</span>.reversed() + <span class="keyword">right</span></span><br><span class="line">            <span class="keyword">left</span>.removeAll()</span><br><span class="line">            <span class="keyword">right</span>.replaceSubrange(subrange, with: newElements)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>组合能力</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MutableCollection</span> </span></span><br><span class="line"><span class="class">    <span class="title">where</span> <span class="title">Self</span>: <span class="title">RandomAccessCollection</span>, <span class="title">Element</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原地对集合进行排序</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="延迟序列"><a href="#延迟序列" class="headerlink" title="延迟序列"></a>延迟序列</h2><p>LazySequenceProtocol 和 LazyCollectionProtocol。</p><p>延迟编程：结果只有在真正需要的时候才会计算出来。</p><p>swift 标准库为支持延迟编程，提供了两个协议：LazySequenceProtocol 和 LazyCollectionProtocol。</p><p>LazySequenceProtocol 继承自 Sequence。</p><p>LazyCollectionProtocol 继承自 LazySequenceProtocol。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要标准输入收到 EOF 信号才会显示</span></span><br><span class="line"><span class="keyword">let</span> filtered = standardIn.<span class="built_in">filter</span> &#123;</span><br><span class="line">    $<span class="number">0</span>.<span class="built_in">split</span>(separator: <span class="string">" "</span>).<span class="built_in">count</span> &gt; <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> filtered &#123; <span class="built_in">print</span>(line) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每读一行符合条件的结果，就打印一个消息</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> standardIn &#123;</span><br><span class="line">    <span class="keyword">guard</span> line.<span class="built_in">split</span>(separator: <span class="string">" "</span>).<span class="built_in">count</span> &gt; <span class="number">3</span> <span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想保留函数式风格，需要在获取到值得时候就生成筛选后的结果</span></span><br><span class="line"><span class="comment">// .lazy 返回值类型是 LazySequence&lt;Self&gt;</span></span><br><span class="line"><span class="comment">// LazySequence 的 filter 方法会返回一个 LazyFilterSequence&lt;AnySequence&lt;String&gt;&gt;</span></span><br><span class="line"><span class="keyword">let</span> filtered = standardIn.<span class="built_in">lazy</span>.<span class="built_in">filter</span> &#123;</span><br><span class="line">    $<span class="number">0</span>.solit(separator: <span class="string">" "</span>).<span class="built_in">count</span> &gt; <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> filtered &#123; <span class="built_in">print</span>(line) &#125;</span><br></pre></td></tr></table></figure><p>风格比较</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="type">Array</span>(standardIn.<span class="built_in">lazy</span>.<span class="built_in">filter</span> &#123;</span><br><span class="line">    $<span class="number">0</span>.<span class="built_in">split</span>(separator: <span class="string">" "</span>).<span class="built_in">count</span> &gt; <span class="number">3</span></span><br><span class="line">&#125;.<span class="keyword">prefix</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令式</span></span><br><span class="line"><span class="keyword">var</span> result: [<span class="type">String</span>] = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> standardIn &#123;</span><br><span class="line">    <span class="keyword">guard</span> line.<span class="built_in">split</span>(separator: <span class="string">" "</span>).<span class="built_in">count</span> &gt; <span class="number">3</span> <span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">    result.append(line)</span><br><span class="line">    <span class="keyword">if</span> result.<span class="built_in">count</span> == <span class="number">2</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>集合的延迟处理</li></ul><p>当在一个常规集合类型（Array）上，串联多个操作时，可以延迟处理的序列，会更效率。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>..&lt;<span class="number">100</span>).<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;.<span class="built_in">filter</span> &#123;$<span class="number">0</span> &gt; <span class="number">10</span> &#125;.<span class="built_in">map</span> &#123; <span class="string">"\($0)"</span> &#125;</span><br></pre></td></tr></table></figure><p>函数式编程，代码清晰易于理解，但是存在效率不佳的问题：</p><p>每一次调用 map 和 filter，都会创建一个新的包含中间结果的数组，这个数组在返回的时候就被销毁了。</p><p>通过在这个调用链的开始，插入 .lazy，就不会产生任何保存中间结果的数组，更有效率</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>..&lt;<span class="number">100</span>).<span class="built_in">lazy</span>.<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;.<span class="built_in">filter</span> &#123;$<span class="number">0</span> &gt; <span class="number">10</span> &#125;.<span class="built_in">map</span> &#123; <span class="string">"\($0)"</span> &#125;</span><br></pre></td></tr></table></figure><p>LazyCollectionProtocol 扩展了 LazySequence，它要求实现它的类型也是一个实现了 Collection 的类型。</p><p>在 LazySquence 中，我们只能逐个生成 Sequence 中的每个元素。</p><p>在 LazyCollection 中，我们可以直接按需生成指定的某个元素。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当对一个延迟加载的集合，应用 map 方法</span></span><br><span class="line"><span class="comment">// 通过下标访问其中的元素</span></span><br><span class="line"><span class="comment">// map 只会对你访问的那个结果执行变换。 O(1)</span></span><br><span class="line"><span class="keyword">let</span> allNumbers = <span class="number">1</span>..&lt;<span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">let</span> allSquares = allNumbers.<span class="built_in">lazy</span>.<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(allSquares[<span class="number">50</span>]) <span class="comment">// 2500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意</span></span><br><span class="line"><span class="comment">// 当使用下标访问元素的时候，每一次的结果都是计算出来的</span></span><br><span class="line"><span class="comment">// 比如下面的代码， 50 已经被过滤掉了</span></span><br><span class="line"><span class="comment">// 为了获取值，需要计算前 50 个的值，然后才能获取到 50 的值（第 51 个）</span></span><br><span class="line"><span class="comment">// 显然这是一个 O(n) 的操作</span></span><br><span class="line"><span class="keyword">let</span> largeSquares = allNumbers.<span class="built_in">lazy</span>.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &gt; <span class="number">1000</span> &#125;.<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(largeSquares[<span class="number">50</span>]) <span class="comment">// 2500</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;swift 集合协议&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
      <category term="swift" scheme="https://skybrim.top/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift 集合类型</title>
    <link href="https://skybrim.top/2020/07/06/ios/swift-collection/"/>
    <id>https://skybrim.top/2020/07/06/ios/swift-collection/</id>
    <published>2020-07-06T06:50:24.000Z</published>
    <updated>2020-12-10T02:48:42.068Z</updated>
    
    <content type="html"><![CDATA[<p>swift 集合类型</p><a id="more"></a><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array 方法</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="type">Int</span>]()</span><br><span class="line"><span class="comment">// 指定数组容量大小</span></span><br><span class="line">array.reserveCapacity(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// 数组是否为空</span></span><br><span class="line">array.isEmpty</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> array &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代除了第一个元素以外的数组</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> array.<span class="built_in">dropFirst</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代除了最后 5 个元素以外的数组</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> array.<span class="built_in">dropLast</span>(<span class="number">5</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代索引和元素</span></span><br><span class="line"><span class="keyword">for</span> (index, element) <span class="keyword">in</span> array.enumerated() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据匹配逻辑找指定内容</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> index = array.firstIndex&#123; someMatchingLogic($<span class="number">0</span>) &#125; &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> index = array.lastIndex &#123; someMatchingLogic($<span class="number">0</span>) &#125; &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> element = array.first &#123; someMatchingLogic($<span class="number">0</span>) &#125; &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> element = array.last &#123; someMatchingLogic($<span class="number">0</span>) &#125; &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> array.<span class="built_in">contains</span> &#123; someMatchingLogic($<span class="number">0</span>) &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组元素进行变形，生成新数组</span></span><br><span class="line">array.<span class="built_in">map</span> &#123; someTransformation($<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flatMap</span></span><br><span class="line"><span class="comment">// 场景 1：压平数组</span></span><br><span class="line"><span class="keyword">let</span> values = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="number">9</span>]]</span><br><span class="line"><span class="keyword">let</span> flattenResult = values.flatMap&#123; $<span class="number">0</span> &#125; <span class="comment">// [1, 3, 5, 7, 9]</span></span><br><span class="line"><span class="comment">// 场景 2：过滤 nil</span></span><br><span class="line"><span class="keyword">let</span> values:[<span class="type">Int?</span>] = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="literal">nil</span>]</span><br><span class="line"><span class="keyword">let</span> flattenResult = values.flatMap&#123; $<span class="number">0</span> &#125; <span class="comment">/// [1, 3, 5, 7, 9]</span></span><br><span class="line"><span class="comment">// 场景 3：不同数组合并</span></span><br><span class="line"><span class="keyword">let</span> words = [<span class="string">"a"</span>, <span class="string">"b"</span>]</span><br><span class="line"><span class="keyword">let</span> nums = [<span class="string">"1"</span>, <span class="string">"2"</span>]</span><br><span class="line"><span class="keyword">let</span> result = words.flatMap &#123; word <span class="keyword">in</span></span><br><span class="line">    nums.<span class="built_in">map</span> &#123; num <span class="keyword">in</span></span><br><span class="line">        (word, num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// [("a", "1"), ("a", "2"), ("b", "1"), ("b", "2")]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组中元素执行操作，不生成新数组</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> forEach 使用 return 时不会中断外部函数，此时请使用 for in 代替</span></span><br><span class="line">array.forEach &#123; doSomething($<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试所有元素</span></span><br><span class="line">array.allSatisfy &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选符合规定的元素</span></span><br><span class="line">array.<span class="built_in">filter</span> &#123; someCriteria($<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素聚合成一个值</span></span><br><span class="line">array.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123; total, num <span class="keyword">in</span> total + num &#125;</span><br><span class="line">array.<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="comment">// sort 无返回值，修改原数组</span></span><br><span class="line"><span class="built_in">sort</span>(by:)</span><br><span class="line"><span class="comment">// sorted 返回新的排好序的数组</span></span><br><span class="line">sorted(by:)</span><br><span class="line"><span class="comment">// 按照顺序比较两个集合元素的大小。</span></span><br><span class="line">lexicographicallyPrecedes(<span class="number">_</span>:by:)</span><br><span class="line"><span class="comment">// 根据条件把集合里的元素重新排序，符合条件的元素移动到最后，返回两个部分分界元素的索引</span></span><br><span class="line"><span class="built_in">partition</span>(by:)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大值和最小值</span></span><br><span class="line"><span class="built_in">min</span>(by:)</span><br><span class="line"><span class="built_in">max</span>(by:)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个队列的是否拥有相同的元素，并且顺序是一致的</span></span><br><span class="line">elementsEqual(<span class="number">_</span>:by:)</span><br><span class="line"><span class="comment">// 序列的前几个元素是否和另一个序列相同</span></span><br><span class="line">starts(with:)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割数组</span></span><br><span class="line"><span class="built_in">split</span>(whereSeparator:)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从头取元素知道条件不成立</span></span><br><span class="line"><span class="keyword">prefix</span>(<span class="keyword">while</span>:)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从头遍历，条件为真，丢弃元素；条件不成立，返回剩余元素</span></span><br><span class="line">drop(<span class="keyword">while</span>:)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有条件为真的元素</span></span><br><span class="line">removeAll(<span class="keyword">where</span>:)</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice，类型是 ArraySlice</span></span><br><span class="line"><span class="comment">// slice 和 array 使用相同索引来随机访问元素</span></span><br><span class="line"><span class="keyword">let</span> slice = array[<span class="number">1</span>...]</span><br></pre></td></tr></table></figure><p>自己实现一些不在标准库中的函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 累加，将所有元素合并到一个数组，保留合并时每一步的值</span></span><br><span class="line">    <span class="comment">// [1, 2, 3, 4].accumulate(0, +) // [1, 3, 6, 10]</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">accumulate</span>&lt;Result&gt;<span class="params">(<span class="number">_</span> initialResult: Result,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="number">_</span> nextPartialResult:<span class="params">(Result, Element)</span></span></span> -&gt; <span class="type">Result</span>) -&gt; [<span class="type">Result</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> running = initialResult</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span> &#123; next <span class="keyword">in</span></span><br><span class="line">            running = nextPartialResult(running, next)</span><br><span class="line">            <span class="keyword">return</span> running</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算满足条件的元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(<span class="keyword">where</span> predicate: <span class="params">(Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> predicate(element) &#123; result += <span class="number">1</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个满足某个条件的所有元素的索引列表</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">indices</span><span class="params">(<span class="keyword">where</span> predicate: <span class="params">(Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> result = [<span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">for</span> (index, element) <span class="keyword">in</span> <span class="keyword">self</span>.enumerated() &#123;</span><br><span class="line">            <span class="keyword">if</span> predicate(element) &#123; result.append(index) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dictionry"><a href="#Dictionry" class="headerlink" title="Dictionry"></a>Dictionry</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fooDic = [<span class="string">"a"</span>: <span class="number">1</span>, <span class="string">"b"</span>: <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据键值对创建字典</span></span><br><span class="line"><span class="keyword">let</span> temp = <span class="type">Dictionary</span>(<span class="string">"abb"</span>.<span class="built_in">map</span>&#123;(<span class="type">String</span>($<span class="number">0</span>), <span class="number">1</span>)&#125;, uniquingKeysWith: +) <span class="comment">// ["a": 1, "b": 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// merge</span></span><br><span class="line"><span class="comment">// 第一个参数：需要合并的字典</span></span><br><span class="line"><span class="comment">// 第二个参数：相同键的两个值如何合并的函数</span></span><br><span class="line">fooDic.merge([temp, uniquingKeysWith: &#123; $<span class="number">1</span> &#125;) <span class="comment">// fooDic = ["a": 1, "b": 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对字典的值做映射</span></span><br><span class="line"><span class="comment">// 保持字典结构，只对值进行变换</span></span><br><span class="line">fooDic.mapValues( &#123; doSomething() &#125; )</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算序列的频率</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> frequencies: [<span class="type">Element</span>: <span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Dictionary</span>(<span class="keyword">self</span>.<span class="built_in">map</span> &#123;($<span class="number">0</span>, <span class="number">1</span>)&#125;, uniquingKeysWith: +)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iPods: <span class="type">Set</span> = [<span class="string">"iPod touch"</span>, <span class="string">"iPod nano"</span>, <span class="string">"iPod mini"</span>, <span class="string">"iPod shuffle"</span>, <span class="string">"iPod Classic"</span>]</span><br><span class="line"><span class="keyword">let</span> discontinuedIPods: <span class="type">Set</span> = [<span class="string">"iPod mini"</span>, <span class="string">"iPod Classic"</span>, <span class="string">"iPod nano"</span>, <span class="string">"iPod shuffle"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 补集</span></span><br><span class="line"><span class="keyword">let</span> currentIPods = iPods.subtracting(discontinuedIPods) <span class="comment">// ["iPod touch"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> touchscreen: <span class="type">Set</span> = [<span class="string">"iPhone"</span>, <span class="string">"iPad"</span>, <span class="string">"iPod touch"</span>, <span class="string">"iPod nano"</span>]</span><br><span class="line"><span class="keyword">let</span> iPodsWithTouch = iPods.intersection(touchscreen)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">var</span> discontinued: <span class="type">Set</span> = [<span class="string">"iBook"</span>, <span class="string">"Powerbook"</span>, <span class="string">"Power Mac"</span>]</span><br><span class="line">discontinued.formUnion(discontinuedIPods) <span class="comment">// ["iPod mini", "iPod Classic", "iPod nano", "iPod shuffle", "iBook", "Powerbook", "Power Mac"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取序列中所有唯一的元素</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">unique</span><span class="params">()</span></span> -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> seen: <span class="type">Set</span>&lt;<span class="type">Element</span>&gt; = []</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">filter</span> &#123; element <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> seen.<span class="built_in">contains</span>(element) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                seen.insert(element)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 的标准库中，Set 和 OptionSet 实现了 SetAlgebra 协议。</p><p>Foundation 中， IndexSet 和 CharacterSet 也实现了 SetAlgebra 协议。</p><ul><li><p>IndexSet </p><p>  IndexSet 是一个正整数的集合。其内部使用了一组范围列表进行实现，比 Set<Int> 更高效。</p></li><li><p>CharacterSet</p><p>  CharacterSet 是一个高效存储 Unicode 编码的集合。</p></li></ul><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleDigitNumbers = <span class="number">0</span>..&lt;<span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> lowercaseLetters = <span class="type">Character</span>(<span class="string">"a"</span>)...<span class="type">Character</span>(<span class="string">"z"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 range 创建 array</span></span><br><span class="line"><span class="keyword">let</span> array = <span class="type">Array</span>(singleDigitNumbers) <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 半开 range 表示 空间隔</span></span><br><span class="line"><span class="number">5</span>..&lt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭合 range 可以包含 最大值</span></span><br><span class="line"><span class="number">0</span>...<span class="type">Int</span>.<span class="built_in">max</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 range 遍历</span></span><br><span class="line"><span class="comment">// Range 要满足 collection 协议，它的元素要满足 Strideable 协议，且 stride step 是整数</span></span><br><span class="line"><span class="comment">// Strideable 协议，可以通过增加偏移从一个元素移动到另一个元素</span></span><br><span class="line"><span class="comment">// Character 没有实现 Strideable 协议，所以 for c in lowercaseLetters 编译错误</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">    doSomething()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围表达式</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr[<span class="number">2</span>...] <span class="comment">// [3, 4]</span></span><br><span class="line">arr[..&lt;<span class="number">1</span>] <span class="comment">// [1]</span></span><br><span class="line">arr[<span class="number">1</span>...<span class="number">2</span>] <span class="comment">// [2, 3]</span></span><br><span class="line">arr[...] <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;swift 集合类型&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
      <category term="swift" scheme="https://skybrim.top/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift-source</title>
    <link href="https://skybrim.top/2020/07/05/ios/swift-source/"/>
    <id>https://skybrim.top/2020/07/05/ios/swift-source/</id>
    <published>2020-07-05T06:23:18.000Z</published>
    <updated>2020-12-10T02:48:42.068Z</updated>
    
    <content type="html"><![CDATA[<p>编译 Swift 源码</p><a id="more"></a><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>system macOS 10.15.5<br>Xcode 11.5</p><p>如果下面的命令，出现了一些 python 的错误，这是因为改动了系统的 python 环境。</p><p>请切换回系统自带的 python，或者虚拟一个新的 python2.7 的环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译工具</span></span><br><span class="line">brew install cmake ninja</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">mkdir swift-source</span><br><span class="line"><span class="built_in">cd</span> swift-source</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/apple/swift.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到最新的 release tag （写文是 5.2.4）</span></span><br><span class="line"><span class="built_in">cd</span> swift</span><br><span class="line">git checkout swift-5.2.4-RELEASE</span><br><span class="line">./utils/update-checkout --tag swift-5.2.4-RELEASE --<span class="built_in">clone</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译的最后一步是生成文档，如果没有安装 Sphinx 会报错</span></span><br><span class="line"><span class="comment"># 根据个人的 python 配置情况安装一下 Sphinx</span></span><br><span class="line"><span class="comment"># 我使用的是 conda 虚拟 python 环境</span></span><br><span class="line">conda install Sphinx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 </span></span><br><span class="line"><span class="comment"># 编译好的文件放在 swift-source/build/ 文件夹下</span></span><br><span class="line"><span class="comment"># 根据电脑不同，编译时间大概在 1~2 小时</span></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line"><span class="comment"># -x 使用 xcode 编译，生成一个 xcodeproj 文件</span></span><br><span class="line"><span class="comment"># -r --release-debuginfo</span></span><br><span class="line"><span class="comment"># --debug-swift-stdlib 对标准库开启 Debug 模式</span></span><br><span class="line">./utils/build-script -x -r --debug-swift-stdlib</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ol><li>首先运行 cmark 工程</li><li>再运行 swift 工程</li></ol><h2 id="更新源码"><a href="#更新源码" class="headerlink" title="更新源码"></a>更新源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> swift-source</span><br><span class="line">./swift/utils/update-checkout</span><br><span class="line">./swift/utils/build-script -x -r --debug-swift-stdlib</span><br></pre></td></tr></table></figure><h2 id="查找源码"><a href="#查找源码" class="headerlink" title="查找源码"></a>查找源码</h2><ul><li>如果知道源码具体位置，直接打开对应的文件查看</li><li>全局搜索 <code>public func xxx</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编译 Swift 源码&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
      <category term="swift" scheme="https://skybrim.top/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>鸡蛋掉落</title>
    <link href="https://skybrim.top/2020/06/15/algorithm/super-egg/"/>
    <id>https://skybrim.top/2020/06/15/algorithm/super-egg/</id>
    <published>2020-06-15T02:37:01.000Z</published>
    <updated>2020-12-10T02:48:42.063Z</updated>
    
    <content type="html"><![CDATA[<p>鸡蛋掉落问题，双蛋问题延伸</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。</p><p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p><p>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</p><p>你的目标是确切地知道 F 的值是多少。</p><p>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入：K = 1, N = 2</p><p>输出：2</p><p>解释：</p><p>鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。</p><p>否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。</p><p>如果它没碎，那么我们肯定知道 F = 2 。</p><p>因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</p><h2 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h2><p>思路：动态规划 + 二分搜索</p><h3 id="状态转移方程式"><a href="#状态转移方程式" class="headerlink" title="状态转移方程式"></a>状态转移方程式</h3><p>K 个鸡蛋，N 层楼，即 f(K, N)</p><p>假设从 X 层扔下，两种情况：</p><ol><li><p>鸡蛋不碎</p><p> 鸡蛋个数仍然是 K，楼层是 X 层到 N 层，即 N-X 层楼。</p><p> 状态为 f(K, N-X)</p></li><li><p>鸡蛋碎了</p><p> 鸡蛋个数为 K-1，楼层为 1 层到 X-1 层，即 X-1 层楼。</p><p> 状态为 f(K-1, X-1)</p></li></ol><p>若在 最坏情况下（也就是无论 F 的值如何） f(K, N) 的值最小</p><p>我们必须保证 <strong>鸡蛋碎了之后接下来需要的步数</strong> 和 <strong>鸡蛋没碎之后接下来需要的步数</strong> 二者的最大值是最小的</p><p>由于不知道具体的 F 值，X 取值范围是 1 到 N</p><p>f(K, N) = 1 + max[1&lt;=X&lt;=N](min(f(K, N-X), f(K-1, X-1)))</p><h3 id="寻找规律"><a href="#寻找规律" class="headerlink" title="寻找规律"></a>寻找规律</h3><ol><li><p>f(K, N)</p><p> 在鸡蛋数 K 固定的情况下，楼层数 N 越多，需要的步数一定不会变少</p><p> 所以，<strong>当 K 不变时，f(K, N) 随着 N 单调递增</strong></p></li><li><p>f(K, N-X)</p><p>  同上，K 和 N 不变时，<strong>f(K, N-X) 随 X 的增加而单调递减</strong></p></li><li><p>f(K-1, X-1)</p><p> 同上，K 和 N 不变时，<strong>f(K-1, X-1) 随 X 的增加而单调递增</strong></p></li></ol><p>由于我们相求的是 f(K, N-X) 和 f(K-1, X-1) 这两个函数的最小的最大值</p><p>根据上述函数特性可知，求得 f(K, N-X) 和 f(K-1, X-1) 的交点即可</p><p>由于 X 的取值只能是整数，所以我们需要取得这两个函数（想象中的）交点左右两侧最近的整数</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">super_egg_drop</span><span class="params">(K, N)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param K: int</span></span><br><span class="line"><span class="string">    @return: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    store = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(k, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (k, n) <span class="keyword">not</span> <span class="keyword">in</span> store:</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 0 层楼</span></span><br><span class="line">                result = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> k == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 1 个鸡蛋，需要扔 n 次</span></span><br><span class="line">                result = n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low, high = <span class="number">1</span>, n</span><br><span class="line">                <span class="comment"># 二分搜索</span></span><br><span class="line">                <span class="keyword">while</span> low + <span class="number">1</span> &lt; high:</span><br><span class="line">                    x = (low + high) // <span class="number">2</span></span><br><span class="line">                    t1 = dp(k<span class="number">-1</span>, x<span class="number">-1</span>)</span><br><span class="line">                    t2 = dp(k, n-x)</span><br><span class="line">                    <span class="keyword">if</span> t1 &lt; t2:</span><br><span class="line">                        low = x</span><br><span class="line">                    <span class="keyword">elif</span> t1 &gt; t2:</span><br><span class="line">                        hight = x</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        low = hight = x</span><br><span class="line">                result = <span class="number">1</span> + min(max(dp(k<span class="number">-1</span>, x<span class="number">-1</span>), dp(k, n-x)) <span class="keyword">for</span> x <span class="keyword">in</span> (low, high))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 记录已经算过的值</span></span><br><span class="line">            store[(k, n)] = result</span><br><span class="line">        <span class="keyword">return</span> store[(k, n)]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鸡蛋掉落问题，双蛋问题延伸&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://skybrim.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C runtime</title>
    <link href="https://skybrim.top/2020/05/22/ios/runtime/"/>
    <id>https://skybrim.top/2020/05/22/ios/runtime/</id>
    <published>2020-05-22T06:02:51.000Z</published>
    <updated>2020-12-10T02:48:42.067Z</updated>
    
    <content type="html"><![CDATA[<p>runtime<br>源码基于 <a href="https://opensource.apple.com/tarballs/objc4/objc4-781.tar.gz" target="_blank" rel="noopener">objc4-781</a></p><a id="more"></a><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/run_time-1.jpg" alt=""></p><ul><li><p>对象：objc_object 结构体，isa 指向类</p></li><li><p>类：  objc_class 结构体，继承自 objc_object，isa 指向元类</p></li><li><p>元类：objc_class 结构体，isa 指向<strong>根元类</strong>，</p></li><li><p><strong>根元类的 isa 指向自身</strong>，根元类的父类指向根类（NSObject），根类（NSObject）的父类指向 nil</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    Class ISA();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    Class getIsa();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略一些方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;          <span class="comment">// objec_class 类型的指针，指向父类的 objc_class</span></span><br><span class="line">    cache_t cache;             <span class="comment">// 已经调用过的方法的缓存</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// uintptr_t(unsigned long) 类型， 存储了 class_rw_t 的地址，objc_class 内部定义的一些函数，通过操作 bits 实现</span></span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略一些方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> method_t *Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> method_t &#123;</span><br><span class="line">    <span class="comment">// 函数名，本质是字符串</span></span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="comment">// 函数类型，返回值与参数的编码 </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;</span><br><span class="line">    <span class="comment">// 函数指针</span></span><br><span class="line">    IMP imp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> SortBySELAddress :</span><br><span class="line">        public std::binary_function&lt;<span class="keyword">const</span> method_t&amp;,</span><br><span class="line">                                    <span class="keyword">const</span> method_t&amp;, <span class="keyword">bool</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> operator() (<span class="keyword">const</span> method_t&amp; lhs,</span><br><span class="line">                         <span class="keyword">const</span> method_t&amp; rhs)</span><br><span class="line">        &#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">函数类型编码</a></p><h3 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> property_t *objc_property_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> property_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ivar_t *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ivar_t &#123;</span><br><span class="line">    int32_t *offset; <span class="comment">// 一个 int 指针，而不是 int，通过这样设计，即使父类新增变量，子类不需要重新编译</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    uint32_t alignment_raw;</span><br><span class="line">    uint32_t size;</span><br><span class="line"></span><br><span class="line">    uint32_t alignment() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (alignment_raw == ~(uint32_t)<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>U &lt;&lt; WORD_SHIFT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; alignment_raw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html" target="_blank" rel="noopener">Objective-C 类成员变量深度剖析</a></p><p>补充：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomething:(SomeClass *)obj</span><br><span class="line">&#123;</span><br><span class="line">    obj-&gt;ivar1 = <span class="number">42</span>;         <span class="comment">// 访问obj对象的public成员变量</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">self</span>-&gt;ivar2;     <span class="comment">// 访问当前类实例的成员变量</span></span><br><span class="line">    ivar2 = n + <span class="number">1</span>;           <span class="comment">// 访问当前类的成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为基类<strong>动态增加成员变量</strong>会导致所有已创建出的子类实例都无法使用，所以成员变量是在编译时决定的</p><p>但是可以<strong>动态添加方法和属性</strong>，因为方法和属性属于类，成员变量属于实例</p><h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> category_t *Category;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">    <span class="comment">// 所属的类名，而不是Category的名字</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">// 所属的类，这个类型是编译期的类，这时候类还没有被重映射</span></span><br><span class="line">    classref_t cls;</span><br><span class="line">    <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</span><br><span class="line">    <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</span><br><span class="line">    <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    <span class="comment">// 实例属性列表</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="comment">// 类属性列表</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(<span class="keyword">bool</span> isMeta, <span class="keyword">struct</span> header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> protocol_t : objc_object &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    method_list_t *instanceMethods;</span><br><span class="line">    method_list_t *classMethods;</span><br><span class="line">    method_list_t *optionalInstanceMethods;</span><br><span class="line">    method_list_t *optionalClassMethods;</span><br><span class="line">    property_list_t *instanceProperties;</span><br><span class="line">    uint32_t size;   <span class="comment">// sizeof(protocol_t)</span></span><br><span class="line">    uint32_t flags;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **_extendedMethodTypes;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *_demangledName;</span><br><span class="line">    property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *demangledName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *nameForLogging() &#123;</span><br><span class="line">        <span class="keyword">return</span> demangledName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isFixedUp() <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">void</span> setFixedUp();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isCanonical() <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">void</span> clearIsCanonical();</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> HAS_FIELD(f) (size &gt;= offsetof(protocol_t, f) + sizeof(f))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> hasExtendedMethodTypesField() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> HAS_FIELD(_extendedMethodTypes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> hasDemangledNameField() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> HAS_FIELD(_demangledName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> hasClassPropertiesField() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> HAS_FIELD(_classProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">undef</span> HAS_FIELD</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **extendedMethodTypes() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasExtendedMethodTypesField() ? _extendedMethodTypes : <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *classProperties() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasClassPropertiesField() ? _classProperties : <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="runtime-结构体分析"><a href="#runtime-结构体分析" class="headerlink" title="runtime 结构体分析"></a>runtime 结构体分析</h2><h3 id="isa-t"><a href="#isa-t" class="headerlink" title="isa_t"></a>isa_t</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isa.h ISA_BITFIELD 的定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_PACKED_ISA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// extra_rc must be the MSB-most field (so it matches carry/overflow flags)</span></span><br><span class="line">    <span class="comment">// nonpointer must be the LSB (fixme or get rid of it)</span></span><br><span class="line">    <span class="comment">// shiftcls must occupy the same bits that a real class pointer would</span></span><br><span class="line">    <span class="comment">// bits + RC_ONE is equivalent to extra_rc + 1</span></span><br><span class="line">    <span class="comment">// RC_HALF is the high bit of extra_rc (i.e. half of its range)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// future expansion:</span></span><br><span class="line">    <span class="comment">// uintptr_t fast_rr : 1;     // no r/r overrides</span></span><br><span class="line">    <span class="comment">// uintptr_t lock : 2;        // lock for atomic property, @synch</span></span><br><span class="line">    <span class="comment">// uintptr_t extraBytes : 1;  // allocated with extra bytes</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                                               \</span></span><br><span class="line">      uintptr_t nonpointer        : <span class="number">1</span>;  <span class="comment">/*0 表示普通的 isa 指针；1 表示优化后的 isa 指针，存储引用计数*/</span>      \</span><br><span class="line">      uintptr_t has_assoc         : <span class="number">1</span>;  <span class="comment">/*表示该对象是否包含 associated object，如果没有，则析构时会更快*/</span>    \</span><br><span class="line">      uintptr_t has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">/*表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快*/</span>     \</span><br><span class="line">      uintptr_t shiftcls          : <span class="number">33</span>; <span class="comment">/*类的指针 MACH_VM_MAX_ADDRESS 0x1000000000*/</span>                  \</span><br><span class="line">      uintptr_t magic             : <span class="number">6</span>;  <span class="comment">/*固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。*/</span>             \</span><br><span class="line">      uintptr_t weakly_referenced : <span class="number">1</span>;  <span class="comment">/*表示该对象是否有过 weak 对象，如果没有，则析构时更快*/</span>              \</span><br><span class="line">      uintptr_t deallocating      : <span class="number">1</span>;  <span class="comment">/*表示该对象是否正在析构*/</span>                                        \</span><br><span class="line">      uintptr_t has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">/*表示该对象的引用计数值是否过大无法存储在 isa 指针  */</span>               \</span><br><span class="line">      uintptr_t extra_rc          : <span class="number">19</span>  <span class="comment">/*存储引用计数值减一后的结果*/</span> </span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                        \</span></span><br><span class="line">      uintptr_t nonpointer        : <span class="number">1</span>;                                         \</span><br><span class="line">      uintptr_t has_assoc         : <span class="number">1</span>;                                         \</span><br><span class="line">      uintptr_t has_cxx_dtor      : <span class="number">1</span>;                                         \</span><br><span class="line">      uintptr_t shiftcls          : <span class="number">44</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \</span><br><span class="line">      uintptr_t magic             : <span class="number">6</span>;                                         \</span><br><span class="line">      uintptr_t weakly_referenced : <span class="number">1</span>;                                         \</span><br><span class="line">      uintptr_t deallocating      : <span class="number">1</span>;                                         \</span><br><span class="line">      uintptr_t has_sidetable_rc  : <span class="number">1</span>;                                         \</span><br><span class="line">      uintptr_t extra_rc          : <span class="number">8</span> </span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;56)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">error</span> unknown architecture for packed isa</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SUPPORT_PACKED_ISA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="class-ro-t-与-class-rw-t"><a href="#class-ro-t-与-class-rw-t" class="headerlink" title="class_ro_t 与 class_rw_t"></a>class_ro_t 与 class_rw_t</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// strong修饰的ivars</span></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// weak修饰的ivars</span></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略了一些方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>class_ro_t 编译时已经决定，只读</p></li><li><p>class_rw_t 运行时创建</p></li></ul><h2 id="class-初始化"><a href="#class-初始化" class="headerlink" title="class 初始化"></a>class 初始化</h2><ol><li><p>编译器取出 bits 中的 class_ro_t，创建 class_rw_t，将 ro 赋值给 rw</p></li><li><p>初始化父类</p></li><li><p>初始化元类</p></li><li><p>初始化方法，将 ro 中的  method_list_t、property_list_t、protocol_list_t 赋值给 rw</p></li></ol><h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p>iPhone 5s 起，iOS 引入了 64 位处理器，指针长度为 8 字节。</p><p>为了优化内存，推出了 <strong>Tagged Pointer</strong></p><p>Tagged Pointer 中，指针就是<strong>值</strong></p><h3 id="isa-t-1"><a href="#isa-t-1" class="headerlink" title="isa_t"></a>isa_t</h3><p>isa_t 同 Tagged Pointer，在 OC2.0 之后，直接本身就存储着对象的信息，查找对象信息时，直接对 isa_t 操作即可。</p><p>因此，我们最好通过 ISA() 方法来获取 isa，而不是直接访问 isa。</p><h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><h3 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)alloc &#123;</span><br><span class="line">    <span class="comment">// 按照注释 [cls alloc] 调用的是 objc_alloc，不过最终都会走到 callAlloc 方法</span></span><br><span class="line">    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base class implementation of +alloc. cls is not nil.</span></span><br><span class="line"><span class="comment">// Calls [cls alloc]. </span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_alloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">true</span><span class="comment">/*checkNil*/</span>, <span class="literal">false</span><span class="comment">/*allocWithZone*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class="line"><span class="comment">// shortcutting optimizations.</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span></span><br><span class="line">callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="comment">// 重点关注这一部分，最终都会走到这里</span></span><br><span class="line">    <span class="comment">// 检查是否为 nil 对象调用</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 调用 _objc_rootAllocWithZone</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        <span class="keyword">return</span> _objc_rootAllocWithZone(cls, <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL, <span class="keyword">struct</span> _NSZone *))objc_msgSend)(cls, <span class="keyword">@selector</span>(allocWithZone:), <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(cls, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NEVER_INLINE</span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// allocWithZone under __OBJC2__ ignores the zone parameter</span></span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, <span class="number">0</span>, <span class="literal">nil</span>,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* class_createInstance</span></span><br><span class="line"><span class="comment">* fixme</span></span><br><span class="line"><span class="comment">* Locking: none</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Note: this function has been carefully written so that the fastpath</span></span><br><span class="line"><span class="comment">* takes no branch.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span></span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="keyword">void</span> *zone,</span><br><span class="line">                              <span class="keyword">int</span> construct_flags = OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>,</span><br><span class="line">                              size_t *outAllocatedSize = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 是否实现 cls</span></span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read class's info bits all at once for performance</span></span><br><span class="line">    <span class="comment">// cls 是否有 c++ 的构建方法</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    <span class="comment">// cls 是否有 c++ 的析构方法</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    <span class="comment">// cls 是否开启了 isa 优化</span></span><br><span class="line">    <span class="keyword">bool</span> fast = cls-&gt;canAllocNonpointer();</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实例的内存大小，至少 16 字节，参数 extraBytes 是 0</span></span><br><span class="line">    size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="comment">// outAllocatedSize 默认 nil</span></span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> obj;</span><br><span class="line">    <span class="comment">// zone 是 nil</span></span><br><span class="line">    <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">        obj = (<span class="keyword">id</span>)malloc_zone_calloc((malloc_zone_t *)zone, <span class="number">1</span>, size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 size 开辟内存</span></span><br><span class="line">        obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!obj)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            <span class="keyword">return</span> _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        <span class="comment">// fast 参数，开启了 isa 优化，初始化 isa_t</span></span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be</span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">        <span class="comment">// 使用为优化的 isa 指针</span></span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    <span class="keyword">return</span> object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootInit(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> _objc_rootInit(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// In practice, it will be hard to rely on this function.</span></span><br><span class="line">    <span class="comment">// Many classes do not properly chain -init calls.</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h3><ul><li>rootDealloc</li></ul><p>当对象的引用计数为0时，底层会调用 _objc_rootDealloc 方法对对象进行释放</p><p>在 _objc_rootDealloc 方法里面会调用 rootDealloc 方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::rootDealloc() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TaggedPointer 类型的对象，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  当对象 </span></span><br><span class="line">    <span class="comment">// 1使用优化的 isa 计数；            isa.nonpointer</span></span><br><span class="line">    <span class="comment">// 2没有weak引用；                 !isa.weakly_referenced</span></span><br><span class="line">    <span class="comment">// 3没有关联对象；                  !isa.has_assoc</span></span><br><span class="line">    <span class="comment">// 4没有c++析构方法；               !isa.has_cxx_dtor</span></span><br><span class="line">    <span class="comment">// 5没有使用SideTable记录引用计数    !isa.has_sidetable_rc</span></span><br><span class="line">    <span class="comment">// 直接 free</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        object_dispose((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>object_dispose</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *objc_destructInstance(<span class="keyword">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="comment">// c++ 析构方法</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="comment">// 移除关联对象，并将其自身从Association Manager的map中移除</span></span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        <span class="comment">// 执行 clearDeallocating</span></span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>clearDeallocating</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        <span class="comment">// 没有使用优化的 isa 指针，清除 SideTable 中的引用计数的数据</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        <span class="comment">// 有弱指针 或者 使用 SideTable 管理引用计数</span></span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>clearDeallocating_slow</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE <span class="keyword">void</span></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在全局的 SideTables 中，以this指针为key，找到对应的 SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>]; </span><br><span class="line"></span><br><span class="line">    table.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果对象被弱引用</span></span><br><span class="line">    <span class="comment">// 在 SideTable 的 weak_table 中对this进行清理工作</span></span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123; </span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (<span class="keyword">id</span>)<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果采用了 SideTable 管理引用计数</span></span><br><span class="line">    <span class="comment">// 在 SideTable 的引用计数中移除</span></span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123; </span><br><span class="line">        table.refcnts.erase(<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="runtime-加载"><a href="#runtime-加载" class="headerlink" title="runtime 加载"></a>runtime 加载</h2><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>iOS 应用会用到很多系统的库，所有 iOS 应用都共用同一套，这些库是动态加载的，称动态库。</p><p>优点：<br>1、防止重复。所有应用共用，防止除服占内存。<br>2、减少应用包体积。打包时可以省略这一部分库<br>3、动态更新。</p><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><ol><li><p>app 启动，dyld 将应用加载，并完成一些文件的初始化；</p></li><li><p>runtime 向 dyld 中注册回调函数；</p></li><li><p>ImageLoader 将所有 image 加载到内存；</p></li><li><p>dyld 在 image 发生改变时，主动调用回调函数；</p></li><li><p>runtime 接收到 dyld 的回调，执行 map_images、load_images 操作，并调用 +load 方法；</p></li><li><p>调用 main() 函数</p></li></ol><p>其中 3、4、5 会多次执行，每次加载 image 都会执行</p><h3 id="map-images"><a href="#map-images" class="headerlink" title="map_images"></a>map_images</h3><p>map_images 中包含 runtime 大量初始化方法，其核心函数是 _read_images</p><ol><li><p>加载所有类到类的gdb_objc_realized_classes表中。</p></li><li><p>对所有类做重映射。</p></li><li><p>将所有SEL都注册到namedSelectors表中。</p></li><li><p>修复函数指针遗留。</p></li><li><p>将所有Protocol都添加到protocol_map表中。</p></li><li><p>对所有Protocol做重映射。</p></li><li><p>初始化所有非懒加载的类，进行rw、ro等操作。</p></li><li><p>遍历已标记的懒加载的类，并做初始化操作。</p></li><li><p>处理所有Category，包括Class和Meta Class。</p></li><li><p>初始化所有未初始化的类。</p></li></ol><h3 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h3><p>load_images 的主要内容：</p><ol><li><p>用 prepare_load_methods 函数，将 class load list 和 category load list 准备好</p></li><li><p>用 call_load_methods 函数，调用上面两个方法表</p></li></ol><p>load 方法的特点：</p><ul><li><p>比 main() 函数要更早</p></li><li><p>整个 app 运行期只会执行一次</p></li><li><p>类和类别（category）的 load 方法都会执行，不会覆盖</p></li><li><p>调用顺序 <strong>父类 -&gt; 子类 -&gt; 类别</strong></p></li><li><p>不是通过 objc_msgSend 调用</p></li></ul><h3 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h3><p>向对象发送消息时，lookUpImpOrForward 函数会判断当前类是否是</p><p>特点</p><ul><li><p>第一次调用类所属的方法时，才调用 initialize</p></li><li><p>只会执行一次，也可能整个 app 声明周期都没有调用</p></li><li><p>调用顺序 <strong>父类 -&gt; 子类</strong>，类别中的 initialize 方法会覆盖原方法</p></li><li><p>通过 objc_msgSend 调用</p></li></ul><h2 id="runtime-消息发送"><a href="#runtime-消息发送" class="headerlink" title="runtime 消息发送"></a>runtime 消息发送</h2><h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(<span class="keyword">void</span> <span class="comment">/* id self, SEL op, ... */</span>)</span><br></pre></td></tr></table></figure><p>objc_msgSend 的两个隐藏参数：</p><ul><li><p>self，当前调用对象</p></li><li><p>_cmd，当前调用方法的 SEL</p></li></ul><p>当前对象调用任何方法，接收者都是当前对象，即使是 super 调用</p><p>当向一个空对象（nil）发送消息，objc_msgSend 会判断接收者为空，直接返回 nil</p><p>注意 NSNull 和 nil 的区别：</p><ul><li><p>NSNull 是继承 NSObject 的对象，只有一个方法 [NSNull null]，向它发送别的消息（方法），会 crash</p></li><li><p>nil 是空，向它发消息不会报错</p></li></ul><h3 id="发送流程"><a href="#发送流程" class="headerlink" title="发送流程"></a>发送流程</h3><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/runtime-2.png" alt=""></p><ol><li><p>对象接收到消息</p></li><li><p>按照对象的 isa 指针，找到对象的类</p></li><li><p>先在类的 cache 中查找</p></li><li><p>在类的 method_list 中查找 selecter</p></li><li><p>如果在类中没有找到，沿着继承链，向父类查找，直到 NSObject</p></li><li><p>还未找到，进入<strong>动态方法解析</strong> resolveInstanceMethod: resolveClassMethod:</p></li><li><p>动态方法解析未实现，进入<strong>动态消息转发</strong> </p></li><li><p>forwardingTargetForSelector: 中，将未找到的消息，转发给其他对象</p></li><li><p>forwardingTargetForSelector: 未实现，先调用 methodSignatureForSelector: 在方法内部生成 NSMethodSignature 类型的方法签名对象 forwardInvocation: 中转发消息</p></li><li><p>还未对消息处理，crash</p></li></ol><h3 id="lookUpImpOrForward-源码"><a href="#lookUpImpOrForward-源码" class="headerlink" title="lookUpImpOrForward 源码"></a>lookUpImpOrForward 源码</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, <span class="keyword">id</span> inst, </span><br><span class="line">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">bool</span> triedResolver = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果cache是YES，则从缓存中查找IMP。如果是从cache3函数进来，则不会执行cache_getImp()函数</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        <span class="comment">// 通过cache_getImp函数查找IMP，查找到则返回IMP并结束调用</span></span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during isRealized and isInitialized checking</span></span><br><span class="line">    <span class="comment">// to prevent races against concurrent realization.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during method search to make</span></span><br><span class="line">    <span class="comment">// method-lookup + cache-fill atomic with respect to method addition.</span></span><br><span class="line">    <span class="comment">// Otherwise, a category could be added but ignored indefinitely because</span></span><br><span class="line">    <span class="comment">// the cache was re-filled with the old value after the cache flush on</span></span><br><span class="line">    <span class="comment">// behalf of the category.</span></span><br><span class="line"></span><br><span class="line">    runtimeLock.read();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断类是否已经被创建，如果没有被创建，则将类实例化 (class 的创建时机：第一次接收消息)</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        <span class="comment">// Drop the read-lock and acquire the write-lock.</span></span><br><span class="line">        <span class="comment">// realizeClass() checks isRealized() again to prevent</span></span><br><span class="line">        <span class="comment">// a race while the lock is down.</span></span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        runtimeLock.write();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对类进行实例化操作</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line"></span><br><span class="line">        runtimeLock.unlockWrite();</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次调用当前类的话，执行 initialize 的代码</span></span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        <span class="comment">// 对类进行初始化，并开辟内存空间</span></span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> retry:    </span><br><span class="line">    runtimeLock.assertReading();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取这个类的缓存</span></span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果没有从cache中查找到，则从方法列表中获取Method</span></span><br><span class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            <span class="comment">// 如果获取到对应的Method，则加入缓存并从Method获取IMP</span></span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try superclass caches and method lists.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> attempts = unreasonableClassCount();</span><br><span class="line">        <span class="comment">// 循环获取这个类的 缓存IMP 或 方法列表的IMP</span></span><br><span class="line">        <span class="keyword">for</span> (Class curClass = cls-&gt;superclass;</span><br><span class="line">             curClass != <span class="literal">nil</span>;</span><br><span class="line">             curClass = curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">            <span class="keyword">if</span> (--attempts == <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Memory corruption in class list."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass cache.</span></span><br><span class="line">            <span class="comment">// 获取父类 缓存的IMP</span></span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">                    <span class="comment">// 如果发现父类的方法，并且不再缓存中，在下面的函数中缓存方法</span></span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                    <span class="comment">// Stop searching, but don't cache yet; call method </span></span><br><span class="line">                    <span class="comment">// resolver for this class first.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass method list.</span></span><br><span class="line">            <span class="comment">// 在父类的方法列表中，获取method_t对象。如果找到则缓存查找到的IMP</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp = meth-&gt;imp;</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到，则尝试动态方法解析</span></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></span><br><span class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">        triedResolver = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line">    <span class="comment">// Use forwarding.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有IMP被发现，并且动态方法解析也没有处理，则进入消息转发阶段</span></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息转发的方法的区别"><a href="#消息转发的方法的区别" class="headerlink" title="消息转发的方法的区别"></a>消息转发的方法的区别</h3><p>forwardingTargetForSelector:， 仅支持一个对象的返回，也就是说消息只能被转发给一个对象、无法处理消息的内容，比如参数和返回值。</p><p>forwardInvocation:， 可以将消息同时转发给任意多个对象</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(aSelector);</span><br><span class="line">    <span class="keyword">if</span> ([selectorName isEqualToString:<span class="string">@"selector"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="keyword">if</span> ([object respondsToSelector:[anInvocation selector]]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:object];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p>阻止因调用未实现的方法而导致崩溃的情况</p></li><li><p>模拟多继承</p></li></ul><h2 id="method-swizzling"><a href="#method-swizzling" class="headerlink" title="method swizzling"></a>method swizzling</h2><h3 id="method-exchangeImplementations"><a href="#method-exchangeImplementations" class="headerlink" title="method_exchangeImplementations"></a>method_exchangeImplementations</h3><p>核心 API method_exchangeImplementations</p><h3 id="aspects"><a href="#aspects" class="headerlink" title="aspects"></a>aspects</h3><p><a href="https://skybrim.top/2019/01/01/iOS/Aspects/">源码分析</a></p><p>aspects 合理的规避了 method swizzling 的一些风险</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>+load 方法中调用</p></li><li><p>dispath_once</p></li></ul><h3 id="类簇-与-method-swizzling"><a href="#类簇-与-method-swizzling" class="headerlink" title="类簇 与 method swizzling"></a>类簇 与 method swizzling</h3><p>需要找到真实的类，来进行交换操作</p><h2 id="runtime-应用"><a href="#runtime-应用" class="headerlink" title="runtime 应用"></a>runtime 应用</h2><h3 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a><strong>attribute</strong></h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被修饰的类不能被其他类继承</span></span><br><span class="line">__attribute__((objc_subclassing_restricted))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类必须调用被修饰的方法</span></span><br><span class="line">__attribute__((objc_requires_super))</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数执行之前</span></span><br><span class="line">__attribute__((constructor)) </span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数执行之后</span></span><br><span class="line">__attribute__((destructor)) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许定义多个同名但不同参数类型的函数</span></span><br><span class="line">__attribute__((overloadable))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在编译时，将Class或Protocol指定为另一个名字</span></span><br><span class="line">__attribute__((objc_runtime_name(<span class="string">"xxxx"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消除 unused 警告</span></span><br><span class="line"><span class="built_in">NSObject</span> *object __attribute__((unused)) = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>object relational mapping</p><ul><li><p>MJExtension</p></li><li><p>Mantle</p></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>下面的代码输出什么？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>答案：都输出Son。</p><p>第一个NSLog输出Son肯定是不用说的。</p><p>第二个输出中，[super class]会被转换为下面代码。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super objcSuper = &#123;</span><br><span class="line">    <span class="keyword">self</span>,</span><br><span class="line">    class_getSuperclass([<span class="keyword">self</span> <span class="keyword">class</span>]),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">id</span> (*sendSuper)(<span class="keyword">struct</span> objc_super*, SEL) = (<span class="keyword">void</span> *)objc_msgSendSuper;</span><br><span class="line">sendSuper(&amp;objcSuper, <span class="keyword">@selector</span>(<span class="keyword">class</span>));</span><br></pre></td></tr></table></figure><p>super的调用会被转换为objc_msgSendSuper的调用，并传入一个objc_super类型的结构体。结构体有两个参数，第一个就是接受消息的对象，第二个是[super class]对应的父类。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull <span class="keyword">id</span> receiver;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由此可知，虽然调用的是[super class]，但是接受消息的对象还是self。然后来到父类Father的class方法中，输出self对应的类Son。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>下面代码的结果？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> res1 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> res2 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> res3 = [(<span class="keyword">id</span>)[Sark <span class="keyword">class</span>] isKindOfClass:[Sark <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> res4 = [(<span class="keyword">id</span>)[Sark <span class="keyword">class</span>] isMemberOfClass:[Sark <span class="keyword">class</span>]];</span><br></pre></td></tr></table></figure><p>答案：<br>除了第一个是YES，其他三个都是NO。</p><p>在推测结果之前，首先要明白两个问题。isKindOfClass和isMemberOfClass的区别是什么？<br>isKindOfClass:class，调用该方法的对象所属的类，继承者链中包含传入的class则返回YES。<br>isMemberOfClass:class，调用改方法的对象所属的类，必须是传入的class则返回YES。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass((<span class="keyword">id</span>)<span class="keyword">self</span>) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = object_getClass((<span class="keyword">id</span>)<span class="keyword">self</span>); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平时开发过程中只会接触到对象方法的isKindOfClass和isMemberOfClass，但是在NSObject类中还隐式的实现了类方法版本。不只这两个方法，其他NSObject中的对象方法，都有其对应的类方法版本。因为在OC中，类和元类也都是对象。这四个调用由于都是类对象发起调用的，所以最终执行的都是类方法版本。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>下面代码会？Compile Error / Runtime Crash / NSLog…?</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Sark</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)foo;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Sark</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"IMP: -[NSObject (Sark) foo]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">[<span class="built_in">NSObject</span> foo];</span><br><span class="line">[[<span class="built_in">NSObject</span> new] performSelector:<span class="keyword">@selector</span>(foo)];</span><br></pre></td></tr></table></figure><p>答案：<br>全都正常输出，编译和运行都没有问题。</p><p>这道题和上一道题很相似，第二个调用肯定没有问题，第一个调用后会从元类中查找方法，然而方法并不在元类中，所以找元类的superclass。方法定义在是NSObject的Category，由于NSObject的对象模型比较特殊，元类的superclass是类对象，所以从类对象中找到了方法并调用。</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>下面的代码会？Compile Error / Runtime Crash / NSLog…?</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line">- (<span class="keyword">void</span>)speak &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"my name's %@"</span>, <span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj speak];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>答案：<br>正常执行，不会导致Crash。</p><p>执行[Sark class]后获取到类对象，然后通过obj指针指向获取到的类对象首地址，这就构成了对象的基本结构，可以进行正常调用。</p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>为什么MRC下没有weak？</p><p>其实MRC下并不是没有weak，在MRC环境下也可以通过Runtime源码调用weak源码的。weak源码定义在Private Headers私有文件夹下，需要引入#import “objc-internal.h”文件。</p><p>以以下ARC的源码为例，定义了一个TestObject类型的对象，并用一个weak指针指向已创建对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        TestObject *object = [[TestObject alloc] init];</span><br><span class="line">        __<span class="keyword">weak</span> TestObject *newObject = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码会被编译器转移为下面代码，这段代码中的两个函数就是weak的实现函数，在MRC下也可以调用这两个函数。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_initWeak(&amp;newObject, object);</span><br><span class="line">objc_destroyWeak(&amp;newObject);</span><br></pre></td></tr></table></figure><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>相同的一个类，创建不同的对象，怎样实现指定的某个对象在dealloc时打印一段文字？</p><p>这个问题最简单的方法就是在类的.h文件里，定义一个标记属性，如果属性被赋值为YES，则在dealloc中打印文字。但是，这种实现方式显然不是面试官想要的，会被直接pass~</p><p>可以参考KVO的实现方案，在运行时动态创建一个类，这个类是对象的子类，将新创建类的dealloc实现指向自定义的IMP，并在IMP中打印一段文字。将对象的isa设置为新创建的类，当执行dealloc方法时就会执行isa所指向的新类。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/ce97c66027cd" target="_blank" rel="noopener">&lt;简书 — 刘小壮&gt; https://www.jianshu.com/p/ce97c66027cd</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;runtime&lt;br&gt;源码基于 &lt;a href=&quot;https://opensource.apple.com/tarballs/objc4/objc4-781.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;objc4-781&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>git-command</title>
    <link href="https://skybrim.top/2020/05/20/inbox/git-command/"/>
    <id>https://skybrim.top/2020/05/20/inbox/git-command/</id>
    <published>2020-05-20T02:22:25.000Z</published>
    <updated>2020-12-10T02:48:42.064Z</updated>
    
    <content type="html"><![CDATA[<p>git 命令备忘</p><p>持续更新 …</p><a id="more"></a><h2 id="状态模型"><a href="#状态模型" class="headerlink" title="状态模型"></a>状态模型</h2><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/git_0.png" alt=""></p><h2 id="仓库结构"><a href="#仓库结构" class="headerlink" title="仓库结构"></a>仓库结构</h2><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/git_1.png" alt=""></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git commit <span class="comment"># 提交</span></span><br><span class="line"></span><br><span class="line">git commit --amend <span class="comment"># 追加提交</span></span><br><span class="line"></span><br><span class="line">git checkout &lt;your-branch-name&gt; <span class="comment"># 切换到指定分支</span></span><br><span class="line"></span><br><span class="line">git checkout -b &lt;your-branch-name&gt; <span class="comment"># 创建分支并切换到该分支</span></span><br><span class="line"></span><br><span class="line">git merge &lt;your-branch-name&gt; <span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line"></span><br><span class="line">git rebase &lt;your-branch-name&gt; <span class="comment"># 合并指定分支到当前分支，创造更线性的提交历史</span></span><br></pre></td></tr></table></figure><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git checkout &lt;commit-SHA-1&gt; <span class="comment"># 分离 HEAD，HEAD 指向某个提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相对引用 ^ 分离 HEAD</span></span><br><span class="line">git checkout master^ <span class="comment"># HEAD 切换到 master 的父节点</span></span><br><span class="line">git checkout master^^ <span class="comment"># HEAD 切换到 master 的父节点的父节点</span></span><br><span class="line">git checkout HEAD^ <span class="comment"># HEAD 指向 HEAD 的父节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相对引用 ~ 分离 HEAD</span></span><br><span class="line">git checkout HEAD~3 <span class="comment"># HEAD 向后移动 3 步</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制移动分支到指定提交</span></span><br><span class="line">git branch -f master HEAD~3 <span class="comment"># 强制 master 分支向后移动 3 步</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销变更</span></span><br><span class="line">git reset <span class="comment"># 向后移动分支</span></span><br><span class="line">git revert <span class="comment"># 创建了一个新的提交，内容是撤销当前提交，这个操作针对远程分支</span></span><br></pre></td></tr></table></figure><h2 id="移动提交记录"><a href="#移动提交记录" class="headerlink" title="移动提交记录"></a>移动提交记录</h2><p>利用 cherry-pick 和 rebase -i 命令，来修改分支的提交记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 将指定的提交，复制到当前分支</span></span><br><span class="line">git cherry-pick &lt;commit-SHA-1&gt; &lt;commit-SHA-1&gt; ... </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在编辑器里修改提交</span></span><br><span class="line">git rebase -i HEAD~5</span><br></pre></td></tr></table></figure><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tag-name&gt; &lt;commit-SHA-1&gt;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learngitbranching.js.org/?locale=zh_CN" target="_blank" rel="noopener">Learn Git</a></p><p><a href="https://zhuanlan.zhihu.com/p/142289703?utm_source=wechat_session&utm_medium=social&utm_oi=52825543409664&from=groupmessage&isappinstalled=0&wechatShare=1&s_s_i=QWra%2BCirMCY6QhghF0le9aHvj5P3HmW%2FdS4rvaZuIqY%3D&s_r=1" target="_blank" rel="noopener">一文讲透 Git 底层数据结构和原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git 命令备忘&lt;/p&gt;
&lt;p&gt;持续更新 …&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="git" scheme="https://skybrim.top/tags/git/"/>
    
      <category term="inbox" scheme="https://skybrim.top/tags/inbox/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 加密</title>
    <link href="https://skybrim.top/2020/02/28/inbox/https/"/>
    <id>https://skybrim.top/2020/02/28/inbox/https/</id>
    <published>2020-02-28T02:12:49.000Z</published>
    <updated>2020-12-10T02:48:42.064Z</updated>
    
    <content type="html"><![CDATA[<p>简单描述一下 HTTPS 加密</p><a id="more"></a><h2 id="加密的种类"><a href="#加密的种类" class="headerlink" title="加密的种类"></a>加密的种类</h2><h3 id="Hash-加密"><a href="#Hash-加密" class="headerlink" title="Hash 加密"></a>Hash 加密</h3><p>哈希算法，是一种从任意文件中创造小的数字「指纹」的方法。</p><ul><li><p>常见算法：</p><p>  1、MD5（128位）<br>  2、SHA-1（160位）<br>  3、SHA-2（包括 SHA-224、SHA-256、SHA-384、SHA-512）  </p></li><li><p>特点：</p><p>  1、正向快：根据原始可以快速计算哈希值<br>  2、逆向难：基本不可能通过哈希值反推出原始数据<br>  3、抗修改性：原始数据有一点改动，哈希值就会产生很大差别<br>  4、强抗碰撞：找到两个相同哈希值的数据很难  </p></li><li><p>用途：</p><p>  1、数据一致性验证<br>  2、数字签名<br>  3、安全访问认证  </p></li></ul><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密，也叫私钥加密，指加密和解密使用相同密钥的加密算法。</p><ul><li><p>常见算法：</p><p>  1.DES<br>  2.3DES<br>  3.AES<br>  4.TDEA<br>  5.Blowfish<br>  6.RC5<br>  7.IDEA  </p></li><li><p>特点：</p><p>  1、只有一个密钥<br>  2、速度快<br>  3、效率高  </p></li><li><p>用途：</p><p>  大量数据的加密</p></li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>公钥和私钥配对的加解密，公钥加密+私钥解密，或者，私钥加密+公钥解密。</p><ul><li><p>常见算法：</p><p>  1、RSA<br>  2、ECC</p></li><li><p>特点：</p><p>  1、相比对称加密，安全性更强<br>  2、加密速度慢  </p></li><li><p>用途：</p><p>  1、少量数据的加密  </p></li></ul><h2 id="对加密的应用"><a href="#对加密的应用" class="headerlink" title="对加密的应用"></a>对加密的应用</h2><h3 id="数字信封"><a href="#数字信封" class="headerlink" title="数字信封"></a>数字信封</h3><ul><li>发送端：</li></ul><p>使用 对称密钥 加密 数据，得到 <strong>数据密文</strong></p><p>使用 私钥 加密 对称密钥，得到 <strong>密钥密文</strong></p><p>发送<strong>数据密文</strong>和<strong>密钥密文</strong></p><ul><li>接收端：</li></ul><p>接收<strong>数据密文</strong>和<strong>密钥密文</strong></p><p>使用 公钥 解密 密钥密文，得到 <strong>对称密钥</strong></p><p>使用 对称密钥 解密 数据密文，得到 <strong>数据</strong></p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><ul><li>发送端：</li></ul><p>对 签名明文 使用 哈希算法，得到 <strong>签名摘要</strong></p><p>使用 私钥 加密 签名摘要，得到 <strong>签名摘要密文</strong></p><p>发送<strong>签名明文</strong>和<strong>签名摘要密文</strong></p><ul><li>接收端：</li></ul><p>接收到<strong>签名明文</strong>和<strong>签名摘要密文</strong></p><p>对签名明文 使用 签名内的哈希算法，得到 <strong>签名摘要1</strong></p><p>使用 公钥 解密 签名摘要密文，得到 <strong>签名摘要2</strong></p><p>验证 <strong>签名摘要1</strong> 与 <strong>签名摘要2</strong> 是否一致</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS 是对 HTTP 协议的扩展。</p><p>HTTPS 协议传输数据大致分为三部分</p><ul><li><p>TCP 协议 — 通信双方通过三次握手建立 TCP 连接</p></li><li><p>TLS 协议 — 通信双方通过四次握手建立 TLS 连接</p></li><li><p>HTTP 协议 — 客户端向服务端发送请求，服务端发回响应</p></li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP 三次握手</p><ol><li><p>客户端向服务端发送带有 SYN 的数据段以及客户端开始发送数据段（Segment）的初始序列号 SEQ = 100</p></li><li><p>服务端收到数据段时，向客户端发送带有 SYN 和 ACK 的数据段</p><ul><li>通过返回 ACK = 101 确认客户端数据段的初始序列号</li><li>通过发送 SEQ = 300 通知客户端，服务端开始发送数据段的初始序列号</li></ul></li></ol><p>3.客户端向服务端发送带有 ACK 的数据段，确认服务端的初始序列号，其中包含 ACK = 301</p><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p>TLS 的作用是在可靠的 TCP 协议上构建安全的传输通道，其本身是不提供可靠性保障的，我们还是需要下层可靠的传输层协议。</p><ul><li>TLS 握手过程</li></ul><ol><li><p>客户端向服务端发送 Client Hello 消息，其中携带客户端支持的协议版本、加密算法、压缩算法以及客户端生成的随机数；</p></li><li><p>服务端收到客户端支持的协议版本、加密算法等信息后；</p><ul><li>向客户端发送 Server Hello 消息，并携带选择特定的协议版本、加密方法、会话 ID 以及服务端生成的随机数；</li><li>向客户端发送 Certificate 消息，即服务端的证书链，其中包含证书支持的域名、发行方和有效期等信息；</li><li>向客户端发送 Server Key Exchange 消息，传递公钥以及签名等信息；</li><li>向客户端发送可选的消息 CertificateRequest，验证客户端的证书；</li><li>向客户端发送 Server Hello Done 消息，通知服务端已经发送了全部的相关信息；</li></ul></li><li><p>客户端收到服务端的协议版本、加密方法、会话 ID 以及证书等信息后，验证服务端的证书；</p><ul><li>向服务端发送 Client Key Exchange 消息，包含使用服务端公钥加密后的随机字符串，即预主密钥（Pre Master Secret）；</li><li>向服务端发送 Change Cipher Spec 消息，通知服务端后面的数据段会加密传输；</li><li>向服务端发送 Finished 消息，其中包含加密后的握手信息；</li></ul></li><li><p>服务端收到 Change Cipher Spec 和 Finished 消息后；</p><ul><li>向客户端发送 Change Cipher Spec 消息，通知客户端后面的数据段会加密传输；</li><li>向客户端发送 Finished 消息，验证客户端的 Finished 消息并完成 TLS 握手；</li></ul></li></ol><ul><li>总结</li></ul><p>TLS 的四次握手，目的是为了交换三个信息</p><ol><li><p>加密通信协议</p><p>就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；</p></li><li><p>数字证书</p><p>该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；</p><p>假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；</p></li><li><p>三个随机数</p><p>这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的“对话密钥”。</p><p>首先客户端先发第一个随机数 N1（明文）;</p><p>然后服务器回了第二个随机数 N2（明文），这个过程同时把之前提到的证书发给客户端；</p><p>第三个随机数N3（Premaster secret），客户端用数字证书的公钥进行非对称加密，发给服务器；服务器用只有自己知道的私钥来解密，获取第三个随机数。</p><p>这样，服务端和客户端都有了三个随机数 N1+N2+N3，然后两端就使用这三个随机数来生成“对话密钥”，在此之后的通信都是使用这个“对话密钥”来进行对称加密解密。</p><p>在 TLS 握手的过程中，服务端的私钥只用来解密第三个随机数，从来没有在网络中传输过，只要私钥没有被泄露，那么数据就是安全的。</p></li></ol><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>在已经建立好 TCP 和 TLS 通道上传输数据是比较简单的事情，HTTP 协议可以直接利用下层建立的可靠的、安全的通道传输数据</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://draveness.me/whys-the-design-https-latency/" target="_blank" rel="noopener">为什么 HTTPS 需要 7 次握手以及 9 倍时延</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单描述一下 HTTPS 加密&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="inbox" scheme="https://skybrim.top/tags/inbox/"/>
    
      <category term="http" scheme="https://skybrim.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Kindle电子书转PDF</title>
    <link href="https://skybrim.top/2019/12/12/inbox/kindle-to-pdf/"/>
    <id>https://skybrim.top/2019/12/12/inbox/kindle-to-pdf/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.065Z</updated>
    
    <content type="html"><![CDATA[<p>没有 Kindle，也不是自购的 Kindle 电子书就不要进来看了。  </p><a id="more"></a><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>想把自己购买的 Kindle 电子书转成 pdf ，在 iPad 的 Notability 上看，配合 apple pencil 作笔记会非常方便。</p><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ul><li><p>Kindle 电子书<br>打开亚马逊的网站，我的账户 - 管理我的内容和设备 - 我的内容<br>选择需要转换的电子书，点击 … 按钮<br>选择-通过电脑下载USB传输<br>顺便去 我的设备 ，记录下自己的 kindle 的序列号</p></li><li><p>Calibre<br>brew cask install Calibre  </p></li><li><p>DeDRM_tools<br><a href="https://github.com/apprenticeharper/DeDRM_tools/releases" target="_blank" rel="noopener">https://github.com/apprenticeharper/DeDRM_tools/releases</a></p></li></ul><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><ul><li><p>安装插件<br>打开 Calibre<br>偏好设置 - 高级选项 - 插件<br>选择 - 从文件加载插件<br>选择刚才下载好的 DeDrm_tools</p></li><li><p>设置插件<br>双击安装好的插件<br>选择第一项 elnk Kindle ebooks<br>点击 + 按钮，输入你的 Kindle 的序列号  </p></li><li><p><em>注意，序列号需要去除空格*</em></p></li><li><p>添加书籍到 Calibre<br>根据自己的需要，转换相应的格式</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有 Kindle，也不是自购的 Kindle 电子书就不要进来看了。  &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="inbox" scheme="https://skybrim.top/tags/inbox/"/>
    
      <category term="kindle" scheme="https://skybrim.top/tags/kindle/"/>
    
  </entry>
  
  <entry>
    <title>RaspberryPi NAS</title>
    <link href="https://skybrim.top/2019/12/12/inbox/raspberry-pi-nas/"/>
    <id>https://skybrim.top/2019/12/12/inbox/raspberry-pi-nas/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.065Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下，用树莓派搭建一个低功耗下载机，挂PT看视频<br>硬件：RaspberryPi 3B+、 TF卡（安装树莓派系统）、 1T移动硬盘、 网线</p><a id="more"></a><h2 id="挂载磁盘"><a href="#挂载磁盘" class="headerlink" title="挂载磁盘"></a>挂载磁盘</h2><p>插上自己的移动硬盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df -h  <span class="comment">#查看磁盘</span></span><br><span class="line">mkdir /share  <span class="comment">#创建分享文件目录</span></span><br><span class="line">chown pi:pi /share  <span class="comment">#权限</span></span><br><span class="line">mount /dev/sda1 /share  <span class="comment">#挂载</span></span><br></pre></td></tr></table></figure><h2 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h2><p>开机或者重启的时候，自动挂载移动硬盘  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br><span class="line"></span><br><span class="line">proc            /proc      proc    defaults    0     0</span><br><span class="line">/dev/mmcblk0p1  /boot      vfat    defaults    0     2</span><br><span class="line">/dev/mmcblk0p2  /          ext4    defaults,noatime  0   1</span><br><span class="line">/dev/sda1       /share     ext3    defaults    0     0  <span class="comment"># 添加这一行信息</span></span><br></pre></td></tr></table></figure><h2 id="安装miniDLNA"><a href="#安装miniDLNA" class="headerlink" title="安装miniDLNA"></a>安装miniDLNA</h2><p>个人硬件：RT-AC86U、RasbperryPi 3B+<br>尝试过 samba 、 FTP 、 dlna 等协议，视频观看使用dlna协议最流畅，其他协议会出现卡顿、音画不同步等各种状况  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、apt-get install minidlna <span class="comment">#安装</span></span><br><span class="line">2、vim /etc/minidlna.conf <span class="comment">#编辑配置文件</span></span><br><span class="line">3、/etc/init.d/minidlna restart <span class="comment">#重启</span></span><br><span class="line">4、service minidlna force-reload <span class="comment">#重新加载配置</span></span><br><span class="line">5、/etc/init.d/minidlna status <span class="comment">#查看状态</span></span><br></pre></td></tr></table></figure><h2 id="安装samba"><a href="#安装samba" class="headerlink" title="安装samba"></a>安装samba</h2><p>dlna协议不能编辑文件，安装samba，方便修改文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install samba samba-common-bin <span class="comment">#安装</span></span><br><span class="line">vim /etc/samba/smb.conf <span class="comment">#修改其配置文件</span></span><br><span class="line"></span><br><span class="line">[share]           <span class="comment">#共享文件的名称， 将在网络上以此名称显示</span></span><br><span class="line">path = /share           <span class="comment">#共享文件的路径</span></span><br><span class="line">valid users = pi        <span class="comment">#允许访问的用户</span></span><br><span class="line">browseable = yes        <span class="comment">#允许浏览</span></span><br><span class="line">public = yes            <span class="comment">#共享开放</span></span><br><span class="line">writable = yes          <span class="comment">#可写</span></span><br><span class="line">sudo /etc/init.d/samba restart <span class="comment">#重启 samba</span></span><br><span class="line">sudo smbpasswd -a pi    <span class="comment">#添加samba共享用户</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下，用树莓派搭建一个低功耗下载机，挂PT看视频&lt;br&gt;硬件：RaspberryPi 3B+、 TF卡（安装树莓派系统）、 1T移动硬盘、 网线&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="inbox" scheme="https://skybrim.top/tags/inbox/"/>
    
      <category term="raspberry-pi" scheme="https://skybrim.top/tags/raspberry-pi/"/>
    
  </entry>
  
  <entry>
    <title>树莓派 + nginx + rtmp</title>
    <link href="https://skybrim.top/2019/12/12/inbox/raspberry-pi-nginx-rtmp/"/>
    <id>https://skybrim.top/2019/12/12/inbox/raspberry-pi-nginx-rtmp/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.065Z</updated>
    
    <content type="html"><![CDATA[<p>RaspberryPi 折腾记录</p><a id="more"></a><h2 id="安装-nginx-rtmp"><a href="#安装-nginx-rtmp" class="headerlink" title="安装 nginx + rtmp"></a>安装 nginx + rtmp</h2><p>由于需要安装 rtmp，所以选择使用源码编译的方式进行安装</p><ul><li>升级</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><ul><li>安装gcc g++依赖库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install libtool</span><br></pre></td></tr></table></figure><ul><li>安装pcre依赖库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libpcre3 libpcre3-dev</span><br></pre></td></tr></table></figure><ul><li>安装zlib依赖库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zlib1g-dev</span><br></pre></td></tr></table></figure><ul><li>安装SSL依赖库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssl libssl-dev</span><br></pre></td></tr></table></figure><ul><li>下载 nginx</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.17.4.tar.gz</span><br><span class="line">tar -zxvf nginx-1.17.4.tar.gz</span><br></pre></td></tr></table></figure><ul><li>下载 rtmp</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/arut/nginx-rtmp-module.git</span><br></pre></td></tr></table></figure><ul><li>安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> nginx-1.17.4</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/nginx --add-module=/root/nginx-rtmp-module --with-http_ssl_module --with-cc-opt=<span class="string">"-Wno-error"</span></span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/conf/</span><br><span class="line">sudo vim nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 rtmp server</span></span><br><span class="line">rtmp &#123;</span><br><span class="line">    server&#123;</span><br><span class="line">        <span class="comment"># 制定服务端口</span></span><br><span class="line">        listen 1935;</span><br><span class="line">        chunk_size 4000;</span><br><span class="line">        <span class="comment"># 制定流应用</span></span><br><span class="line">        application live</span><br><span class="line">        &#123;</span><br><span class="line">            live on;</span><br><span class="line">            record off;</span><br><span class="line">            allow play all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/nginx/sbin/nginx /usr/<span class="built_in">local</span>/sbin/</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -antup | grep 1935</span><br></pre></td></tr></table></figure><h2 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h2><p>使用 ffmpeg 推流</p><ul><li>安装 ffmpeg</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ffmpeg</span><br></pre></td></tr></table></figure><ul><li>推流</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i http://pcyf.qing.mgtv.com/nn_live/nn_x64/cz05NThjNDc5ZjE2ZWNjMjcxNDU1MzQwNmExMWY1NWI5ZSZlcz0xNTcwMzgzOTExJnV1aWQ9MWZmYjQ5ZTdmNGRhZTJmZjE1YjYyY2Y3ZDNkOWE1NzAtNzQxOWZiYmImdj0yJmFzPTAmY2RuZXhfaWQ9eWZfcGNfbGl2ZQ,,/KLGMPP360.flv?timezone=8 -c:a copy -c:v copy -f flv rtmp://localhost:1935/live/room</span><br></pre></td></tr></table></figure><h2 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h2><p>使用 ffplay 播放</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay rtmp://RaspberryPi_IP:1935/live/room</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RaspberryPi 折腾记录&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="inbox" scheme="https://skybrim.top/tags/inbox/"/>
    
      <category term="raspberry-pi" scheme="https://skybrim.top/tags/raspberry-pi/"/>
    
  </entry>
  
  <entry>
    <title>Raspbery Pi 初始化</title>
    <link href="https://skybrim.top/2019/12/12/inbox/raspberry-pi/"/>
    <id>https://skybrim.top/2019/12/12/inbox/raspberry-pi/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.065Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>树莓派 3B+</p><p>16GB 的内存卡</p><h2 id="下载树莓派镜像"><a href="#下载树莓派镜像" class="headerlink" title="下载树莓派镜像"></a>下载树莓派镜像</h2><p><a href="https://shumeipai.nxez.com/download#os" target="_blank" rel="noopener">树莓派系统</a></p><h2 id="写入镜像"><a href="#写入镜像" class="headerlink" title="写入镜像"></a>写入镜像</h2><p>我使用的是 balenaEtcher 工具写入镜像</p><p>写入镜像后，重新插拔一下内存卡</p><ol><li>新建一个名为 ssh 的文件，无任何后缀</li><li>新建一个 wpa_supplicant.conf 文件，内容如下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"> </span><br><span class="line">network=&#123;</span><br><span class="line">    ssid=<span class="string">"WiFi-A"</span></span><br><span class="line">    psk=<span class="string">"12345678"</span></span><br><span class="line">    key_mgmt=WPA-PSK</span><br><span class="line">    priority=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh pi@raspberrypi.local</span><br><span class="line">password: raspberry</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;硬件&quot;&gt;&lt;a href=&quot;#硬件&quot; class=&quot;headerlink&quot; title=&quot;硬件&quot;&gt;&lt;/a&gt;硬件&lt;/h2&gt;&lt;p&gt;树莓派 3B+&lt;/p&gt;
&lt;p&gt;16GB 的内存卡&lt;/p&gt;
&lt;h2 id=&quot;下载树莓派镜像&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
    
      <category term="inbox" scheme="https://skybrim.top/tags/inbox/"/>
    
      <category term="raspberry-pi" scheme="https://skybrim.top/tags/raspberry-pi/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 弱引用</title>
    <link href="https://skybrim.top/2019/10/21/ios/weak-point/"/>
    <id>https://skybrim.top/2019/10/21/ios/weak-point/</id>
    <published>2019-10-21T03:10:56.000Z</published>
    <updated>2020-12-10T02:48:42.069Z</updated>
    
    <content type="html"><![CDATA[<p>weak 指针学习</p><a id="more"></a><h2 id="前置学习"><a href="#前置学习" class="headerlink" title="前置学习"></a>前置学习</h2><p><a href="https://skybrim.top/2019/10/19/iOS/reference-counting/">Objective-C 引用计数</a></p><h2 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h2><p>__weak 修饰的指针指向对象，对象的引用计数不会增加</p><p>当对象释放时，__weak 修饰的指向对象的指针，会变成 nil</p><h2 id="先上结论"><a href="#先上结论" class="headerlink" title="先上结论"></a>先上结论</h2><p>Runtime 维护着一个全局的 SideTables 定长哈希表，key 是对象的地址，值是对象对应的 SideTable</p><p>SideTable 里维护这对象的 引用计数表（RefcountMap）和 <strong>弱指针表（weak_table_t）</strong></p><p>weak_table_t 中，通过对象的地址，获取到对象的 <strong>弱指针数组（weak_entry_t *）</strong></p><p>创建 weak 指针，就是向这个数组里添加 weak 指针的地址</p><p>对象释放，weak 指针置为 nil，就是清空该数组</p><h2 id="SideTables-结构图"><a href="#SideTables-结构图" class="headerlink" title="SideTables 结构图"></a>SideTables 结构图</h2><p><strong>详细的结构分析，见上一篇博文 <a href="https://skybrim.top/2019/10/19/iOS/reference-counting/">Objective-C 引用计数</a></strong></p><p>此文重点是 weak_table_t 与 weak_entry_t 的分析</p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/weak_point_0.png" alt="SideTables"></p><h3 id="weak-table-t"><a href="#weak-table-t" class="headerlink" title="weak_table_t"></a>weak_table_t</h3><p>weak_table_t 是一个全局的弱引用哈希表。</p><p>weak_table_t 的 key 是对象地址，value 是 weak_entry_t</p><p>由于 SideTables 一共只有 64（iPhone真机为8）个节点，App 中对象肯定不止，所以每个 SideTable 对应多个对象。</p><p>所以，weak_table_t 也是对应着多个对象的弱引用信息，即 weak_entries 中存放着多个对象的弱引用信息（weak_entry_t）。</p><p>而 weak_table_t，则是通过对 <strong>对象指针</strong> 进行哈希计算，获取到 <strong>对象的 weak_entry_t</strong></p><p>weak_table_t 定义</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The global weak references table. Stores object ids as keys,</span></span><br><span class="line"><span class="comment"> * and weak_entry_t structs as their values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> weak_table_t &#123;</span><br><span class="line">    weak_entry_t *weak_entries;</span><br><span class="line">    size_t    num_entries;</span><br><span class="line">    uintptr_t mask;</span><br><span class="line">    uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分析 weak_entry_for_referent 方法，可以得知 weak_table 通过 对象指针 获取到对象的弱引用信息（weak_entry_t）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Return the weak reference table entry for the given referent. </span></span><br><span class="line"><span class="comment"> * If there is no entry for referent, return NULL. </span></span><br><span class="line"><span class="comment"> * Performs a lookup.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param weak_table </span></span><br><span class="line"><span class="comment"> * @param referent The object. Must not be nil.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return The table of weak referrers to this object. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> weak_entry_t *</span><br><span class="line">weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(referent);</span><br><span class="line"></span><br><span class="line">    weak_entry_t *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!weak_entries) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出对象的 weak_entry_t 在 weak_entries 中的索引</span></span><br><span class="line">    size_t begin = hash_pointer(referent) &amp; weak_table-&gt;mask;</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_table-&gt;weak_entries);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;weak_table-&gt;weak_entries[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="weak-entry-t"><a href="#weak-entry-t" class="headerlink" title="weak_entry_t"></a>weak_entry_t</h3><p>weak_entry_t 维护着对象的弱引用信息的哈希集合</p><p>是一个 union 类型，如果 out_of_line_ness != REFERRERS_OUT_OF_LINE ，用一个内联数组代替</p><p>这是因为对象可能不止一个弱指针，根据不同情况来优化</p><p>通过分析 remove_referrer 和 append_referrer 源码可以得知</p><p>weak_entry_t 通过对 弱指针的指针 进行哈希计算，可以找到 弱指针 在 weak_referrer_t-&gt;referrers 中的位置</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The address of a __weak variable.</span></span><br><span class="line"><span class="comment">// These pointers are stored disguised so memory analysis tools</span></span><br><span class="line"><span class="comment">// don't see lots of interior pointers from the weak table into objects.</span></span><br><span class="line"><span class="keyword">typedef</span> DisguisedPtr&lt;objc_object *&gt; weak_referrer_t;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_MINUS_2 62</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_MINUS_2 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The internal structure stored in the weak references table. </span></span><br><span class="line"><span class="comment"> * It maintains and stores</span></span><br><span class="line"><span class="comment"> * a hash set of weak references pointing to an object.</span></span><br><span class="line"><span class="comment"> * If out_of_line_ness != REFERRERS_OUT_OF_LINE then the set</span></span><br><span class="line"><span class="comment"> * is instead a small inline array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WEAK_INLINE_COUNT 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// out_of_line_ness field overlaps with the low two bits of inline_referrers[1].</span></span><br><span class="line"><span class="comment">// inline_referrers[1] is a DisguisedPtr of a pointer-aligned address.</span></span><br><span class="line"><span class="comment">// The low two bits of a pointer-aligned DisguisedPtr will always be 0b00</span></span><br><span class="line"><span class="comment">// (disguised nil or 0x80..00) or 0b11 (any other address).</span></span><br><span class="line"><span class="comment">// Therefore out_of_line_ness == 0b10 is used to mark the out-of-line state.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REFERRERS_OUT_OF_LINE 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> weak_entry_t &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            weak_referrer_t *referrers;</span><br><span class="line">            uintptr_t        out_of_line_ness : <span class="number">2</span>;</span><br><span class="line">            uintptr_t        num_refs : PTR_MINUS_2;</span><br><span class="line">            uintptr_t        mask;</span><br><span class="line">            uintptr_t        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// out_of_line_ness field is low bits of inline_referrers[1]</span></span><br><span class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> out_of_line() &#123;</span><br><span class="line">        <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entry_t&amp; operator=(<span class="keyword">const</span> weak_entry_t&amp; other) &#123;</span><br><span class="line">        memcpy(<span class="keyword">this</span>, &amp;other, <span class="keyword">sizeof</span>(other));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : referent(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[<span class="number">0</span>] = newReferrer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Add the given referrer to set of weak pointers in this entry.</span></span><br><span class="line"><span class="comment"> * Does not perform duplicate checking (b/c weak pointers are never</span></span><br><span class="line"><span class="comment"> * added to a set twice). </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param entry The entry holding the set of weak pointers. </span></span><br><span class="line"><span class="comment"> * @param new_referrer The new weak pointer to be added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> append_referrer(weak_entry_t *entry, objc_object **new_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="comment">// Try to insert inline.</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == <span class="literal">nil</span>) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Couldn't insert inline. Allocate out of line.</span></span><br><span class="line">        weak_referrer_t *new_referrers = (weak_referrer_t *)</span><br><span class="line">            calloc(WEAK_INLINE_COUNT, <span class="keyword">sizeof</span>(weak_referrer_t));</span><br><span class="line">        <span class="comment">// This constructed table is invalid, but grow_refs_and_insert</span></span><br><span class="line">        <span class="comment">// will fix it and rehash it.</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        entry-&gt;referrers = new_referrers;</span><br><span class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;</span><br><span class="line">        entry-&gt;mask = WEAK_INLINE_COUNT<span class="number">-1</span>;</span><br><span class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASSERT(entry-&gt;out_of_line());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 弱指针的指针 进行哈希计算，拿到索引，将对应的 弱指针 插入到 weak_referrer_t-&gt;referrers 中</span></span><br><span class="line">    size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != <span class="literal">nil</span>) &#123;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    weak_referrer_t &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Remove old_referrer from set of referrers, if it's present.</span></span><br><span class="line"><span class="comment"> * Does not remove duplicates, because duplicates should not exist. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @todo this is slow if old_referrer is not present. Is this ever the case? </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param entry The entry holding the referrers.</span></span><br><span class="line"><span class="comment"> * @param old_referrer The referrer to remove. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> remove_referrer(weak_entry_t *entry, objc_object **old_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == old_referrer) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = <span class="literal">nil</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _objc_inform(<span class="string">"Attempted to unregister unknown __weak variable "</span></span><br><span class="line">                     <span class="string">"at %p. This is probably incorrect use of "</span></span><br><span class="line">                     <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                     <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                     old_referrer);</span><br><span class="line">        objc_weak_error();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != old_referrer) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"Attempted to unregister unknown __weak variable "</span></span><br><span class="line">                         <span class="string">"at %p. This is probably incorrect use of "</span></span><br><span class="line">                         <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                         <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                         old_referrer);</span><br><span class="line">            objc_weak_error();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    entry-&gt;referrers[index] = <span class="literal">nil</span>;</span><br><span class="line">    entry-&gt;num_refs--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="weak-指针的创建"><a href="#weak-指针的创建" class="headerlink" title="weak 指针的创建"></a>weak 指针的创建</h2><h3 id="objc-initWeak"><a href="#objc-initWeak" class="headerlink" title="objc_initWeak"></a>objc_initWeak</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// location： weak 指针地址，类型 id*</span></span><br><span class="line"><span class="comment">// newObj: 所指向的对象， 类型 id</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_initWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="storeWeak"><a href="#storeWeak" class="headerlink" title="storeWeak"></a>storeWeak</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update a weak variable.</span></span><br><span class="line"><span class="comment">// If HaveOld is true, the variable has an existing value </span></span><br><span class="line"><span class="comment">//   that needs to be cleaned up. This value might be nil.</span></span><br><span class="line"><span class="comment">// If HaveNew is true, there is a new value that needs to be </span></span><br><span class="line"><span class="comment">//   assigned into the variable. This value might be nil.</span></span><br><span class="line"><span class="comment">// If CrashIfDeallocating is true, the process is halted if newObj is </span></span><br><span class="line"><span class="comment">//   deallocating or newObj's class does not support weak references. </span></span><br><span class="line"><span class="comment">//   If CrashIfDeallocating is false, nil is stored instead.</span></span><br><span class="line"><span class="keyword">enum</span> CrashIfDeallocating &#123;</span><br><span class="line">    DontCrashIfDeallocating = <span class="literal">false</span>, DoCrashIfDeallocating = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> </span><br><span class="line">storeWeak(<span class="keyword">id</span> *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) assert(newObj == <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">id</span> oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire locks for old and new values.</span></span><br><span class="line">    <span class="comment">// Order by lock address to prevent lock ordering problems. </span></span><br><span class="line">    <span class="comment">// Retry if the old value changes underneath us.</span></span><br><span class="line"> retry:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weak指针 之前引用过一个 obj，取出 obj 对应的 SideTable，赋值给 oldTable</span></span><br><span class="line">    <span class="comment">// 没有引用过对象，则 oldTable = nil</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weak指针 要引用一个新的 obj，取出 obj 对应的 SideTable，赋值 newTable</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁操作</span></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 location 与 oldObj 不同，可能被其他线程所修改</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent a deadlock between the weak reference machinery</span></span><br><span class="line">    <span class="comment">// and the +initialize machinery by ensuring that no </span></span><br><span class="line">    <span class="comment">// weakly-referenced object has an un-+initialized isa.</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果cls还没有初始化，先初始化，再尝试设置弱引用</span></span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (<span class="keyword">id</span>)newObj));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this class is finished with +initialize then we're good.</span></span><br><span class="line">            <span class="comment">// If this class is still running +initialize on this thread </span></span><br><span class="line">            <span class="comment">// (i.e. +initialize called storeWeak on an instance of itself)</span></span><br><span class="line">            <span class="comment">// then we may proceed but it will appear initializing and </span></span><br><span class="line">            <span class="comment">// not yet initialized to the check above.</span></span><br><span class="line">            <span class="comment">// Instead set previouslyInitializedClass to recognize it on retry.</span></span><br><span class="line">            <span class="comment">// 完成初始化后进行标记</span></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// newObj 初始化后，重新获取一遍newObj</span></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up old value, if any.</span></span><br><span class="line">    <span class="comment">// 如果 weak指针 之前弱引用过别的对象oldObj</span></span><br><span class="line">    <span class="comment">// weak_unregister_no_lock，移除 oldTable-&gt;weak_table-&gt;weak_entries 中该 weak指针 地址</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign new value, if any.</span></span><br><span class="line">    <span class="comment">// 如果 weak指针 需要弱引用新的对象 newObj</span></span><br><span class="line">    <span class="comment">// weak_register_no_lock，将 weak指针 的地址添加到 newObj 对应的 newTable-&gt;weak_table-&gt;weak_entries</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (<span class="keyword">id</span>)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></span><br><span class="line">        <span class="comment">// 更新 newObj 的 isa指针 的 weakly_referenced bit 标志位</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></span><br><span class="line">        <span class="comment">// *location 赋值，也就是将weak指针直接指向了newObj，而且没有将newObj的引用计数+1</span></span><br><span class="line">        *location = (<span class="keyword">id</span>)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No new value. The storage is not changed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="weak-register-no-lock"><a href="#weak-register-no-lock" class="headerlink" title="weak_register_no_lock"></a>weak_register_no_lock</h3><p>添加弱引用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> </span><br><span class="line">weak_register_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </span><br><span class="line">                      <span class="keyword">id</span> *referrer_id, <span class="keyword">bool</span> crashIfDeallocating) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// referent_id: 对象</span></span><br><span class="line">    <span class="comment">// referrer_id: weak指针</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;   <span class="comment">// 对象的地址</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id; <span class="comment">// weak指针的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果对象 referent 为 nil 或者 对象是 TaggedPointer 计数方式，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure that the referenced object is viable</span></span><br><span class="line">    <span class="comment">// 确保对象可用：没有在析构，支持weak弱引用</span></span><br><span class="line">    <span class="keyword">bool</span> deallocating;</span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        deallocating = referent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> (*allowsWeakReference)(objc_object *, SEL) = </span><br><span class="line">            (<span class="built_in">BOOL</span>(*)(objc_object *, SEL))</span><br><span class="line">            object_getMethodImplementation((<span class="keyword">id</span>)referent, </span><br><span class="line">                                           SEL_allowsWeakReference);</span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, SEL_allowsWeakReference);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果对象正在析构，不能够被弱引用</span></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Cannot form weak reference to instance (%p) of "</span></span><br><span class="line">                        <span class="string">"class %s. It is possible that this object was "</span></span><br><span class="line">                        <span class="string">"over-released, or is in the process of deallocation."</span>,</span><br><span class="line">                        (<span class="keyword">void</span>*)referent, object_getClassName((<span class="keyword">id</span>)referent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now remember it and where it is being stored</span></span><br><span class="line">    <span class="comment">// 在 weak_table 中找到对象 referent 对应的 weak_entries，并将 referrer 加入到 weak_entries 中</span></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// append_referrer() 的源码在文章上半部分</span></span><br><span class="line">        <span class="comment">// 如果能找到 weak_entries，插入 referrer</span></span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果找不到 weak_entries，新建一个 weak_entries</span></span><br><span class="line">        weak_entry_t new_entry(referent, referrer);</span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="weak-unregister-no-lock"><a href="#weak-unregister-no-lock" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h3><p>移除弱引用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">weak_unregister_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </span><br><span class="line">                        <span class="keyword">id</span> *referrer_id) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// referent_id: 对象</span></span><br><span class="line">    <span class="comment">// referrer_id: weak指针</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;   <span class="comment">// 对象的地址</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id; <span class="comment">// weak指针的地址</span></span><br><span class="line"></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找到以前弱引用的对象 referent 所对应的 weak_entries</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在对象 referent 所对应的 weak_entries 数组中，移除弱引用 referrer</span></span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除元素之后， 要检查一下 weak_entries 数组是否已经空了</span></span><br><span class="line">        <span class="keyword">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 weak_entries 的hash数组已经空了，则需要将 weak_entries 从 weak_table 中移除</span></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="weak指针的置空"><a href="#weak指针的置空" class="headerlink" title="weak指针的置空"></a>weak指针的置空</h2><p>当对象释放时，weak 指针会自动置空</p><h3 id="rootDealloc"><a href="#rootDealloc" class="headerlink" title="rootDealloc"></a>rootDealloc</h3><p>当对象的引用计数为0时，底层会调用 _objc_rootDealloc 方法对对象进行释放</p><p>在 _objc_rootDealloc 方法里面会调用 rootDealloc 方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::rootDealloc() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TaggedPointer 类型的对象，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  当对象 </span></span><br><span class="line">    <span class="comment">// 1使用优化的 isa 计数；            isa.nonpointer</span></span><br><span class="line">    <span class="comment">// 2没有weak引用；                 !isa.weakly_referenced</span></span><br><span class="line">    <span class="comment">// 3没有关联对象；                  !isa.has_assoc</span></span><br><span class="line">    <span class="comment">// 4没有c++析构方法；               !isa.has_cxx_dtor</span></span><br><span class="line">    <span class="comment">// 5没有使用SideTable记录引用计数    !isa.has_sidetable_rc</span></span><br><span class="line">    <span class="comment">// 直接 free</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        object_dispose((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="object-dispose"><a href="#object-dispose" class="headerlink" title="object_dispose"></a>object_dispose</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *objc_destructInstance(<span class="keyword">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="comment">// c++ 析构方法</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="comment">// 移除关联对象，并将其自身从Association Manager的map中移除</span></span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        <span class="comment">// 执行 clearDeallocating</span></span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clearDeallocating"><a href="#clearDeallocating" class="headerlink" title="clearDeallocating"></a>clearDeallocating</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        <span class="comment">// 没有使用优化的 isa 指针，清除 SideTable 中的引用计数的数据</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        <span class="comment">// 有弱指针 或者 使用 SideTable 管理引用计数</span></span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clearDeallocating-slow"><a href="#clearDeallocating-slow" class="headerlink" title="clearDeallocating_slow"></a>clearDeallocating_slow</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE <span class="keyword">void</span></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在全局的 SideTables 中，以this指针为key，找到对应的 SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>]; </span><br><span class="line"></span><br><span class="line">    table.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果对象被弱引用</span></span><br><span class="line">    <span class="comment">// 在 SideTable 的 weak_table 中对this进行清理工作</span></span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123; </span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (<span class="keyword">id</span>)<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果采用了 SideTable 管理引用计数</span></span><br><span class="line">    <span class="comment">// 在 SideTable 的引用计数中移除</span></span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123; </span><br><span class="line">        table.refcnts.erase(<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="weak-clear-no-lock"><a href="#weak-clear-no-lock" class="headerlink" title="weak_clear_no_lock"></a>weak_clear_no_lock</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">weak_clear_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取对象的地址</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到 referent 在 weak_table 中对应的 weak_entries</span></span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); </span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn't happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf("XXX no entry for clear deallocating %p\n", referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    weak_referrer_t *referrers;</span><br><span class="line">    size_t count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出对象的 weak指针地址数组 以及 数组长度</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i]; <span class="comment">// 取出每个weak ptr的地址</span></span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123; <span class="comment">// 如果weak ptr确实weak引用了referent，则将weak ptr设置为nil，这也就是为什么weak 指针会自动设置为nil的原因</span></span><br><span class="line">                *referrer = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123; <span class="comment">// 如果所存储的weak ptr没有weak 引用referent，这可能是由于runtime代码的逻辑错误引起的，报错</span></span><br><span class="line">                _objc_inform(<span class="string">"__weak variable at %p holds %p instead of %p. "</span></span><br><span class="line">                             <span class="string">"This is probably incorrect use of "</span></span><br><span class="line">                             <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                             <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    weak_entry_remove(weak_table, entry); <span class="comment">// 由于referent要被释放了，因此referent的weak_entry_t也要移除出weak_table</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;weak 指针学习&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 引用计数</title>
    <link href="https://skybrim.top/2019/10/19/ios/reference-counting/"/>
    <id>https://skybrim.top/2019/10/19/ios/reference-counting/</id>
    <published>2019-10-19T03:08:50.000Z</published>
    <updated>2020-12-10T02:48:42.067Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C 引用计数</p><a id="more"></a><h2 id="存储引用计数"><a href="#存储引用计数" class="headerlink" title="存储引用计数"></a>存储引用计数</h2><ul><li><p>TaggedPointer</p><p>  直接将其指针值作为引用计数返回</p></li><li><p>64位 &amp;&amp; Objective-C 2.0</p><p>  isa 指针的一部分会用来存储引用计数</p><p>  如果 isa 的引用计数溢出，使用一张 hash 表来存储</p></li></ul><h3 id="TaggedPointer"><a href="#TaggedPointer" class="headerlink" title="TaggedPointer"></a>TaggedPointer</h3><p>判断当前对象是否在使用 TaggedPointer 是看标志位是否为 1 ：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_MSB_TAGGED_POINTERS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> TAG_MASK (1ULL&lt;&lt;63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> TAG_MASK 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> </span><br><span class="line">objc_object::isTaggedPointer()  <span class="comment">// objc_object * 就是 id</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_TAGGED_POINTERS</span></span><br><span class="line">    <span class="keyword">return</span> ((uintptr_t)<span class="keyword">this</span> &amp; TAG_MASK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isa-指针"><a href="#isa-指针" class="headerlink" title="isa 指针"></a>isa 指针</h3><p>优化的 isa 指针并不是就一定会存储引用计数，毕竟用 19bit （iOS 系统）保存引用计数不一定够。</p><p>需要注意的是这 19 位保存的是 <strong>引用计数的值减一</strong>。</p><p>has_sidetable_rc 的值如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中</p><p>看源码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define SUPPORT_NONPOINTER_ISA=1 to enable extra data in the isa field.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__LP64__  ||  TARGET_OS_WIN32  ||  TARGET_IPHONE_SIMULATOR  ||  __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_NONPOINTER_ISA 0 <span class="comment">// iOS 中 arm64 支持优化后的指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_NONPOINTER_ISA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00000001fffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003fe00000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a400000001ULL</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        uintptr_t nonpointer        : <span class="number">1</span>;  <span class="comment">// 0 表示普通的 isa 指针；1 表示优化后的 isa 指针，存储引用计数</span></span><br><span class="line">        uintptr_t has_assoc         : <span class="number">1</span>;  <span class="comment">// 表示该对象是否包含 associated object，如果没有，则析构时会更快</span></span><br><span class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">// 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快</span></span><br><span class="line">        uintptr_t shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000 类的指针</span></span><br><span class="line">        uintptr_t magic             : <span class="number">6</span>;  <span class="comment">// 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。</span></span><br><span class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;  <span class="comment">// 表示该对象是否有过 weak 对象，如果没有，则析构时更快</span></span><br><span class="line">        uintptr_t deallocating      : <span class="number">1</span>;  <span class="comment">// 表示该对象是否正在析构</span></span><br><span class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">// 表示该对象的引用计数值是否过大无法存储在 isa 指针  </span></span><br><span class="line">        uintptr_t extra_rc          : <span class="number">19</span>; <span class="comment">// 存储引用计数值减一后的结果</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x0000000000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x0000000000000001ULL</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        uintptr_t indexed           : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t shiftcls          : <span class="number">44</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x7fffffe00000</span></span><br><span class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        uintptr_t deallocating      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        uintptr_t extra_rc          : <span class="number">14</span>;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;50)</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;13)</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// Available bits in isa field are architecture-specific.</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">error</span> unknown architecture</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="hash-表存储"><a href="#hash-表存储" class="headerlink" title="hash 表存储"></a>hash 表存储</h3><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/weak_point_0.png" alt="SideTables"></p><p>从上往下分析结构</p><ul><li><p>SideTables</p><p>  SideTables 是一个64（iPhone真机的情况下是 8）个元素长度的 hash 表，里面存储了 SideTable</p><p>  键是对象的地址，值是对象的 SideTable</p><p>  所以，<strong>一个 SideTable 可能对应多个对象</strong></p><p>  SideTables 在系统中是全局唯一的。</p><p>  SideTables的类型是是template<typename T> class StripedMap，StripedMap<SideTable> 。</p><p>  可以简单的理解为一个64 * sizeof(SideTable) 的哈希线性数组</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; SideTabls 可以通过全局的静态函数获取，实质是 StripedMap</span><br><span class="line">static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">enum &#123; CacheLineSize &#x3D; 64 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; StripedMap 定义</span><br><span class="line">&#x2F;&#x2F; void* -&gt; T</span><br><span class="line">&#x2F;&#x2F; StripedMap&lt;T&gt; is a map of void* -&gt; T, sized appropriately </span><br><span class="line">&#x2F;&#x2F; for cache-friendly lock striping. </span><br><span class="line">&#x2F;&#x2F; For example, this may be used as StripedMap&lt;spinlock_t&gt;</span><br><span class="line">&#x2F;&#x2F; or as StripedMap&lt;SomeStruct&gt; where SomeStruct stores a spin lock.</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class StripedMap &#123;</span><br><span class="line">#if TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span><br><span class="line">    enum &#123; StripeCount &#x3D; 8 &#125;; &#x2F;&#x2F; 真机 8</span><br><span class="line">#else</span><br><span class="line">    enum &#123; StripeCount &#x3D; 64 &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 封装 T </span><br><span class="line">    struct PaddedT &#123;</span><br><span class="line">        T value alignas(CacheLineSize);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; PaddedT 类型的数组，长度是 StripeCount</span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; hash 定位算法</span><br><span class="line">    &#x2F;&#x2F; 以 void* 作为 key，返回 void* 对应的 SideTable 的位置</span><br><span class="line">    static unsigned int indexForPointer(const void *p) &#123;</span><br><span class="line">        uintptr_t addr &#x3D; reinterpret_cast&lt;uintptr_t&gt;(p);</span><br><span class="line">        return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount; &#x2F;&#x2F; 对 StripeCount 取余，防止越界</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; 对外的存取数据的方法</span><br><span class="line">    T&amp; operator[] (const void *p) &#123; </span><br><span class="line">        return array[indexForPointer(p)].value; </span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; operator[] (const void *p) const &#123; </span><br><span class="line">        return const_cast&lt;StripedMap&lt;T&gt;&gt;(this)[p]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 锁的相关操作，核心都是直接操作 array[i].value</span><br><span class="line">    &#x2F;&#x2F; Shortcuts for StripedMaps of locks.</span><br><span class="line">    void lockAll() &#123;</span><br><span class="line">        for (unsigned int i &#x3D; 0; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            array[i].value.lock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void unlockAll() &#123;</span><br><span class="line">        for (unsigned int i &#x3D; 0; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            array[i].value.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void forceResetAll() &#123;</span><br><span class="line">        for (unsigned int i &#x3D; 0; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            array[i].value.forceReset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void defineLockOrder() &#123;</span><br><span class="line">        for (unsigned int i &#x3D; 1; i &lt; StripeCount; i++) &#123;</span><br><span class="line">            lockdebug_lock_precedes_lock(&amp;array[i-1].value, &amp;array[i].value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void precedeLock(const void *newlock) &#123;</span><br><span class="line">        &#x2F;&#x2F; assumes defineLockOrder is also called</span><br><span class="line">        lockdebug_lock_precedes_lock(&amp;array[StripeCount-1].value, newlock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void succeedLock(const void *oldlock) &#123;</span><br><span class="line">        &#x2F;&#x2F; assumes defineLockOrder is also called</span><br><span class="line">        lockdebug_lock_precedes_lock(oldlock, &amp;array[0].value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const void *getLock(int i) &#123;</span><br><span class="line">        if (i &lt; StripeCount) return &amp;array[i].value;</span><br><span class="line">        else return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#if DEBUG</span><br><span class="line">    StripedMap() &#123;</span><br><span class="line">        &#x2F;&#x2F; Verify alignment expectations.</span><br><span class="line">        uintptr_t base &#x3D; (uintptr_t)&amp;array[0].value;</span><br><span class="line">        uintptr_t delta &#x3D; (uintptr_t)&amp;array[1].value - base;</span><br><span class="line">        ASSERT(delta % CacheLineSize &#x3D;&#x3D; 0);</span><br><span class="line">        ASSERT(base % CacheLineSize &#x3D;&#x3D; 0);</span><br><span class="line">    &#125;</span><br><span class="line">#else</span><br><span class="line">    constexpr StripedMap() &#123;&#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>SideTable</p></li></ul><p>从上面的 SideTables 的结构，可以得出一个结论：</p><p><strong>一个 SideTable 可以对应多个对象</strong></p><p>RefcountMap 是一个 hash 表，key 是对象的地址，值是引用计数减一</p><pre><code><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SideTable &#123;</span><br><span class="line">    spinlock_t slock;        <span class="comment">// 保证原子操作的自旋锁</span></span><br><span class="line">    RefcountMap refcnts;     <span class="comment">// 保存引用计数的 hash 表，也就是 DenseMap</span></span><br><span class="line">    weak_table_t weak_table; <span class="comment">// 保存弱引用的 hash 表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    SideTable() &#123;</span><br><span class="line">        memset(&amp;weak_table, <span class="number">0</span>, <span class="keyword">sizeof</span>(weak_table));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数 （实际上不能被析构）</span></span><br><span class="line">    ~SideTable() &#123;</span><br><span class="line">        _objc_fatal(<span class="string">"Do not delete SideTable."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些锁的操作</span></span><br><span class="line">    <span class="keyword">void</span> lock() &#123; slock.lock(); &#125;</span><br><span class="line">    <span class="keyword">void</span> unlock() &#123; slock.unlock(); &#125;</span><br><span class="line">    <span class="keyword">void</span> forceReset() &#123; slock.forceReset(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Address-ordered lock discipline for a pair of side tables.</span></span><br><span class="line"></span><br><span class="line">    template&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> lockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class="line">    template&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> unlockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>RefcountMap</p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> RefcountMapValuePurgeable &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> isPurgeable(size_t x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,RefcountMapValuePurgeable&gt; RefcountMap;</span><br></pre></td></tr></table></figure></li><li><p>DenseMap</p><p>  key：DisguisedPtr<objc_object>，是对 objc_object * 指针及其一些操作进行的封装</p><p>  value：__darwin_size_t，等价于 unsigned long，内容也是 <strong>引用计数减一</strong></p></li><li><p>weak_table_t</p><p>  关于 weak_table_t 的详细分析，见 <a href="https://skybrim.top/2019/10/21/iOS/weak-point/">Objective-C 弱引用</a>，这里只展示源码</p>  <details>  <summary>weak_table_t</summary>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The global weak references table. Stores object ids as keys,</span></span><br><span class="line"><span class="comment">* and weak_entry_t structs as their values.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> weak_table_t &#123;</span><br><span class="line">    weak_entry_t *weak_entries;</span><br><span class="line">    size_t    num_entries;</span><br><span class="line">    uintptr_t mask;</span><br><span class="line">    uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  </details></li></ul><ul><li><p>weak_entry_t</p><p>  关于 weak_entry_t 的详细分析，见 <a href="https://skybrim.top/2019/10/21/iOS/weak-point/">Objective-C 弱引用</a>，这里展示下源码</p>  <details>  <summary>weak_entry_t</summary>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_MINUS_2 62</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_MINUS_2 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The internal structure stored in the weak references table. </span></span><br><span class="line"><span class="comment">* It maintains and stores</span></span><br><span class="line"><span class="comment">* a hash set of weak references pointing to an object.</span></span><br><span class="line"><span class="comment">* If out_of_line_ness != REFERRERS_OUT_OF_LINE then the set</span></span><br><span class="line"><span class="comment">* is instead a small inline array.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WEAK_INLINE_COUNT 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// out_of_line_ness field overlaps with the low two bits of inline_referrers[1].</span></span><br><span class="line"><span class="comment">// inline_referrers[1] is a DisguisedPtr of a pointer-aligned address.</span></span><br><span class="line"><span class="comment">// The low two bits of a pointer-aligned DisguisedPtr will always be 0b00</span></span><br><span class="line"><span class="comment">// (disguised nil or 0x80..00) or 0b11 (any other address).</span></span><br><span class="line"><span class="comment">// Therefore out_of_line_ness == 0b10 is used to mark the out-of-line state.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REFERRERS_OUT_OF_LINE 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> weak_entry_t &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            weak_referrer_t *referrers;</span><br><span class="line">            uintptr_t        out_of_line_ness : <span class="number">2</span>;</span><br><span class="line">            uintptr_t        num_refs : PTR_MINUS_2;</span><br><span class="line">            uintptr_t        mask;</span><br><span class="line">            uintptr_t        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// out_of_line_ness field is low bits of inline_referrers[1]</span></span><br><span class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> out_of_line() &#123;</span><br><span class="line">        <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entry_t&amp; operator=(<span class="keyword">const</span> weak_entry_t&amp; other) &#123;</span><br><span class="line">        memcpy(<span class="keyword">this</span>, &amp;other, <span class="keyword">sizeof</span>(other));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : referent(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[<span class="number">0</span>] = newReferrer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  </details>    </li></ul><h2 id="获取引用计数"><a href="#获取引用计数" class="headerlink" title="获取引用计数"></a>获取引用计数</h2><h3 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)retainCount &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><p>Core Foundation 库的 CFGetRetainCount()</p><p>Runtime 的 _objc_rootRetainCount(id obj)</p><h2 id="修改引用计数"><a href="#修改引用计数" class="headerlink" title="修改引用计数"></a>修改引用计数</h2><h3 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h3><p>引用计数 +1</p><p>_objc_rootRetain(id obj)</p><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>引用计数 -1</p><p>_objc_rootRelease(id obj)</p><h3 id="alloc-new-copy-mutableCopy"><a href="#alloc-new-copy-mutableCopy" class="headerlink" title="alloc, new, copy, mutableCopy"></a>alloc, new, copy, mutableCopy</h3><p>引用计数 +1</p><h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><p><a href="https://skybrim.top/2017/06/01/iOS/autorelease/">autorelease</a></p><h2 id="引用-amp-参考"><a href="#引用-amp-参考" class="headerlink" title="引用&amp;参考"></a>引用&amp;参考</h2><p><a href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/" target="_blank" rel="noopener">Objective-C 引用计数原理 by:杨潇玉</a><br><a href="https://blog.csdn.net/u013378438/article/details/80733391" target="_blank" rel="noopener">Objective-C runtime机制(5)</a><br><a href="https://blog.csdn.net/u013378438/article/details/82790332" target="_blank" rel="noopener">Objective-C runtime机制(7)</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C 引用计数&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://skybrim.top/2019/07/13/algorithm/dynamic-programming/"/>
    <id>https://skybrim.top/2019/07/13/algorithm/dynamic-programming/</id>
    <published>2019-07-12T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.063Z</updated>
    
    <content type="html"><![CDATA[<p>暴力法 -&gt; 记忆化递归 -&gt; 动态规划</p><a id="more"></a><h2 id="三道例题"><a href="#三道例题" class="headerlink" title="三道例题"></a>三道例题</h2><p>先给出两道例题，按照 暴力法 -&gt; 记忆化递归 -&gt; 动态规划 的顺序，给出结题方法。</p><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><ul><li><p>题目：<br>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p></li><li><p>暴力递归解<br>关键思路：斐波那契数列<br>第 n 阶的方法数 = 第 n-1 阶的方法数 + 第 n-2 阶的方法数<br>最终拆分到，第 1 个台阶方法数 = 1，第 2 个台阶方法数 = 2。</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> n &gt; <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>记忆化递归<br>结题思路和暴力递归一样，但是考虑到暴力法中，有很多重复计算，此时记录初次计算的值，以便后续使用。<br>用空间换取时间。  </li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> n &gt; <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> store = <span class="type">Array</span>(repeating: <span class="number">0</span>, <span class="built_in">count</span>: n + <span class="number">1</span>)</span><br><span class="line">    store[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    store[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">help</span><span class="params">(<span class="number">_</span> step: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> store[step] != <span class="number">0</span> &#123; <span class="keyword">return</span> store[step] &#125;</span><br><span class="line">        store[step] = help(step - <span class="number">1</span>) + help(step - <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> store[step]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> help(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>动态规划<br>记忆化递归，是自顶向下的方法，即将较大规模的问题，向较小规模的问题拆分。<br>动态规划，是自底向上的方法，从最小规模的方法，逐级向上推算。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记忆化递归 -&gt; 记忆化动态规划，此时记录了所有的解</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> n &gt; <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> res = <span class="type">Array</span>(repeating: <span class="number">0</span>, <span class="built_in">count</span>: n + <span class="number">1</span>)</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        res[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">3</span> ... n &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + res[i - <span class="number">2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//优化空间，只记录前两个解</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> n &gt; <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pre_1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> pre_2 = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">3</span> ... n &#123;</span><br><span class="line">            res = pre_1 + pre_2</span><br><span class="line">            pre_1 = pre_2</span><br><span class="line">            pre_2 = res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><ul><li><p>题目：<br>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p></li><li><p>暴力解</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(<span class="number">_</span> coins: [Int], <span class="number">_</span> amount: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> amount == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="type">Int</span>.<span class="built_in">max</span></span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coins &#123;</span><br><span class="line">        <span class="keyword">if</span> amount - coin &lt; <span class="number">0</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> tmp = coinChange(coins, amount - coin)</span><br><span class="line">        <span class="keyword">if</span> tmp == -<span class="number">1</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">        res = <span class="built_in">min</span>(res, tmp + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == <span class="type">Int</span>.<span class="built_in">max</span> ? -<span class="number">1</span> : <span class="type">Int</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>记忆化递归</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(<span class="number">_</span> coins: [Int], <span class="number">_</span> amount: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">help</span><span class="params">(<span class="number">_</span> coins: [Int], <span class="number">_</span> amount: Int, <span class="number">_</span> memory: <span class="keyword">inout</span> [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> amount == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> memory[amount] != -<span class="number">2</span> &#123; <span class="keyword">return</span> memory[amount] &#125;</span><br><span class="line">        <span class="keyword">var</span> res = <span class="type">Int</span>.<span class="built_in">max</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins &#123;</span><br><span class="line">            <span class="keyword">if</span> amount - coin &lt; <span class="number">0</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">            <span class="keyword">let</span> tmp = help(coins, amount - coin, &amp;memory)</span><br><span class="line">            <span class="keyword">if</span> tmp == -<span class="number">1</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">            res = <span class="built_in">min</span>(res, tmp + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        memory[amount] = res == <span class="type">Int</span>.<span class="built_in">max</span> ? -<span class="number">1</span> : <span class="type">Int</span>(res)</span><br><span class="line">        <span class="keyword">return</span> memory[amount]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> memory = <span class="type">Array</span>(repeating: -<span class="number">2</span>, <span class="built_in">count</span>: amount + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> help(coins, amount, &amp;memory)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>动态规划</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(<span class="number">_</span> coins: [Int], <span class="number">_</span> amount: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> amount == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> memory = <span class="type">Array</span>(repeating: amount + <span class="number">1</span>, <span class="built_in">count</span>: amount + <span class="number">1</span>)</span><br><span class="line">    memory[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> ... amount &#123;</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins &#123;</span><br><span class="line">            <span class="keyword">if</span> i - coin &gt;= <span class="number">0</span> &#123;</span><br><span class="line">                memory[i] = <span class="built_in">min</span>(memory[i], memory[i - coin] + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[amount] &gt; amount ? -<span class="number">1</span> : memory[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过例题，我们可以总结思路：</p><ul><li><p>状态转移方程<br>动态规划类题目，第一步就是得到状态转移方程。状态转移方程，就是 f(n) = f(n-1) + f(n-2)。，即，状态 n 是入户通过状态 n-1 和状态 n-2 相加获取。<br>这一步，通常是大家不想看的暴力解法，但是，这一步是最重要的。<br>后续的解法，都是围绕如何优化这一步来的。</p></li><li><p>记忆化递归<br>通过记录已知的解，使用空间来优化时间。</p></li><li><p>动态规划<br>自底向上。</p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>一开始，很难直接一步写出动态规划，但是通过 状态转移方程 -&gt; 记忆化递归 -&gt; 动态规划，这个思路，可以逐步推导出解法。<br>通过练习强化，当练习到一定程度，相信一定可以一步写出动态规划解法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暴力法 -&amp;gt; 记忆化递归 -&amp;gt; 动态规划&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://skybrim.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>编译 FFmpeg 源码</title>
    <link href="https://skybrim.top/2019/06/28/ffmpeg/compile-ffmpeg/"/>
    <id>https://skybrim.top/2019/06/28/ffmpeg/compile-ffmpeg/</id>
    <published>2019-06-27T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.064Z</updated>
    
    <content type="html"><![CDATA[<p>ffmpeg compile</p><a id="more"></a><ul><li>下载源码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://git.ffmpeg.org/ffmpeg.git</span><br></pre></td></tr></table></figure><ul><li>依赖库</li></ul><p>安装依赖库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">brew install pkg-config</span><br><span class="line">brew install yasm</span><br><span class="line">brew install fdk-aac</span><br><span class="line">brew install speex</span><br><span class="line">brew install x264</span><br><span class="line">brew install x265</span><br><span class="line">brew install sdl2</span><br></pre></td></tr></table></figure><ul><li>切换到 release 分支</li></ul><p>个人偏好，在稳定版本下学习</p><ul><li>修改 config.asm</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FFPLAY 1</span></span><br></pre></td></tr></table></figure><ul><li>设置编译参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/ffmpeg</span><br><span class="line">                  --<span class="built_in">enable</span>-gpl</span><br><span class="line">                  --<span class="built_in">enable</span>-nonfree</span><br><span class="line">                  --<span class="built_in">enable</span>-libfdk-aac</span><br><span class="line">                  --<span class="built_in">enable</span>-libx264</span><br><span class="line">                  --<span class="built_in">enable</span>-libx265</span><br><span class="line">                  --<span class="built_in">enable</span>-filter=delogo</span><br><span class="line">                  --<span class="built_in">enable</span>-debug</span><br><span class="line">                  --<span class="built_in">disable</span>-optimizations</span><br><span class="line">                  --<span class="built_in">enable</span>-libspeex</span><br><span class="line">                  --<span class="built_in">enable</span>-videotoolbox</span><br><span class="line">                  --<span class="built_in">enable</span>-shared</span><br><span class="line">                  --<span class="built_in">enable</span>-pthreads</span><br><span class="line">                  --<span class="built_in">enable</span>-version3</span><br><span class="line">                  --<span class="built_in">enable</span>-hardcoded-tables</span><br><span class="line">                  --cc=clang</span><br><span class="line">                  --host-cflags=</span><br><span class="line">                  --host-ldflags=</span><br></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure><ul><li>在 zsh 中添加路径</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/ffmpeg/bin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ffmpeg compile&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ffmpeg" scheme="https://skybrim.top/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg 常用命令</title>
    <link href="https://skybrim.top/2019/06/28/ffmpeg/ffmpeg-command/"/>
    <id>https://skybrim.top/2019/06/28/ffmpeg/ffmpeg-command/</id>
    <published>2019-06-27T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.064Z</updated>
    
    <content type="html"><![CDATA[<p>ffmpeg command</p><a id="more"></a><h2 id="基本信息查询"><a href="#基本信息查询" class="headerlink" title="基本信息查询"></a>基本信息查询</h2><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4.jpg" alt="基本信息查询"></p><h2 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h2><ul><li>查看支持的采集设备编号列表</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -list_devices <span class="literal">true</span> -i <span class="string">""</span></span><br></pre></td></tr></table></figure><ul><li>视频录制</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -f : 指定使用 AVfoundation 采集数据</span></span><br><span class="line"><span class="comment"># -i : 指定从哪里采集数据，文件索引号  0 摄像头 1 屏幕</span></span><br><span class="line"><span class="comment"># -r : 指定帧率</span></span><br><span class="line"><span class="comment"># out.yuv : 保存的文件名，yuv 无压缩的数据</span></span><br><span class="line">ffmpeg -f avfoundation -i 1 -r 30 out.yuv</span><br></pre></td></tr></table></figure><ul><li>视频播放</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -s : size，视频分辨率</span></span><br><span class="line"><span class="comment"># -pix_fmt : 像素格式，默认 yuv420p</span></span><br><span class="line">ffplay -s 4096x2304 -pix_fmt uyvy422 out.yuv</span><br></pre></td></tr></table></figure><ul><li>音频录制</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -i : 指定采集设备，冒号前面是视频采集设置，冒号后面是音频采集设备</span></span><br><span class="line">ffmpeg -f avfoundation -i :0 out.wav</span><br></pre></td></tr></table></figure><ul><li>音频播放</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay out.wav</span><br></pre></td></tr></table></figure><h2 id="分解与复用"><a href="#分解与复用" class="headerlink" title="分解与复用"></a>分解与复用</h2><ul><li>转换 复用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 直接转格式 demuxer + muxer</span></span><br><span class="line"><span class="comment"># -vcodec copy : 视频编码处理方式，copy 指不改变</span></span><br><span class="line"><span class="comment"># -acodec copy : 音频编码处理方式，copy 指不改变</span></span><br><span class="line">ffmpeg -i input.mp4 -vcodec copy -acodec copy out.flv</span><br></pre></td></tr></table></figure><ul><li>分解</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 抽取视频</span></span><br><span class="line"><span class="comment"># -an : 不要音频</span></span><br><span class="line">ffmpeg -i input.mp4 -an -vcodec copy out.h264</span><br><span class="line"></span><br><span class="line"><span class="comment">## 抽取音频</span></span><br><span class="line"><span class="comment"># -vn :  不要音频</span></span><br><span class="line">ffmpeg -i input.mp4 -acodec copy -vn out.aac</span><br></pre></td></tr></table></figure><h2 id="处理原始数据"><a href="#处理原始数据" class="headerlink" title="处理原始数据"></a>处理原始数据</h2><ul><li>抽取视频原始数据 yuv</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c:v rawvideo : 视频编码。rawvideo 原始视频</span></span><br><span class="line"><span class="comment"># -pix_fmt : 像素格式</span></span><br><span class="line">ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv</span><br></pre></td></tr></table></figure><ul><li>抽取音频原始数据 pcm</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -ar : 音频采样率 44.1k</span></span><br><span class="line"><span class="comment"># -ac 2 : channel，2 是双声道</span></span><br><span class="line"><span class="comment"># -f s16le : 数据存储格式； s : 有符号； 16 : 16位表示； le 小</span></span><br><span class="line">ffmpeg -i input.mp4 -vn -ar 44100 -ac2 -f s16le out.pcm</span><br><span class="line"></span><br><span class="line"><span class="comment">## 播放原始音频</span></span><br><span class="line"><span class="comment"># 指定原始音频播放参数</span></span><br><span class="line">ffplay -ar 44100 -ac 2 -f s16le out.pcm</span><br></pre></td></tr></table></figure><h2 id="剪裁与合并"><a href="#剪裁与合并" class="headerlink" title="剪裁与合并"></a>剪裁与合并</h2><ul><li>裁剪</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -ss : 视频裁剪起始点</span></span><br><span class="line"><span class="comment"># -t : 裁剪时长，单位秒</span></span><br><span class="line">ffmpeg -i input.mp4 -ss 00:00:00 -t 10 out.ts</span><br></pre></td></tr></table></figure><ul><li>合并</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># inputs.txt : 想要合并的文件的文件名列表，内容格式为 file 'filename.xxx'</span></span><br><span class="line">ffmpeg -f concat -i inputs.txt out.flv</span><br><span class="line"><span class="comment"># 拼接 MP4</span></span><br></pre></td></tr></table></figure><h2 id="图片与视频互转"><a href="#图片与视频互转" class="headerlink" title="图片与视频互转"></a>图片与视频互转</h2><ul><li>图片转视频</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i image-%3d.jpeg out.mp4</span><br></pre></td></tr></table></figure><ul><li>视频转图片</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -r : 指定转换图片帧率。 1 每秒转出1张</span></span><br><span class="line"><span class="comment"># -f : 指定格式 image2</span></span><br><span class="line">ffmpeg -i input.flv -r 1 -f image2 image-%3d.jpeg</span><br></pre></td></tr></table></figure><h2 id="直播相关"><a href="#直播相关" class="headerlink" title="直播相关"></a>直播相关</h2><ul><li>推流</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -re : Read input at native frame rate. Mainly used to simulate a grab device, or live input stream (e.g. when reading from a file). Should not be used with actual grab devices or live input streams (where it can cause packet loss). By default ffmpeg attempts to read the input(s) as fast as possible. This option will slow down the reading of the input(s) to the native frame rate of the input(s). It is useful for real-time output (e.g. live streaming).</span></span><br><span class="line"><span class="comment"># -c : 音视频编解码</span></span><br><span class="line"><span class="comment"># -f : 格式</span></span><br><span class="line"><span class="comment"># 推向的服务器地址</span></span><br><span class="line">ffmpeg -re -i out.mp4 -c copy -f flv rtmpt://server/live/streamName</span><br></pre></td></tr></table></figure><ul><li>拉流</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</span><br></pre></td></tr></table></figure><h2 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h2><ul><li>视频裁剪</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -vf : vf,使用视频滤镜；crop 滤镜名；crop=in_w-200:in_h-200，滤镜参数，长宽减200；默认原点是中心</span></span><br><span class="line"><span class="comment"># crop 格式 : crop=xxxx_w:xxxx_h:x:y</span></span><br><span class="line"><span class="comment"># -c:v : 视频编码器，libx264</span></span><br><span class="line"><span class="comment"># -c:a : 音频编码器，copy</span></span><br><span class="line">ffmpeg -i input.mp4 -vf crop=input_w-200:input_h-200 -c:v libx264 -c:a copy out.mp4</span><br></pre></td></tr></table></figure><ul><li>添加水印</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ffmpeg command&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ffmpeg" scheme="https://skybrim.top/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg 处理音视频的流程</title>
    <link href="https://skybrim.top/2019/06/28/ffmpeg/ffmpeg/"/>
    <id>https://skybrim.top/2019/06/28/ffmpeg/ffmpeg/</id>
    <published>2019-06-27T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.064Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/FFmpeg.jpg" alt="FFmpeg 处理音视频流程"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/FFmpeg.jpg&quot; alt=&quot;FFmpeg 处理音视频流程&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="ffmpeg" scheme="https://skybrim.top/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg 初级开发内容</title>
    <link href="https://skybrim.top/2019/06/28/ffmpeg/ffmpeg-primary/"/>
    <id>https://skybrim.top/2019/06/28/ffmpeg/ffmpeg-primary/</id>
    <published>2019-06-27T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.064Z</updated>
    
    <content type="html"><![CDATA[<p>ffmpeg primary</p><a id="more"></a><h2 id="FFmpeg-日志的使用及目录操作"><a href="#FFmpeg-日志的使用及目录操作" class="headerlink" title="FFmpeg 日志的使用及目录操作"></a>FFmpeg 日志的使用及目录操作</h2><h3 id="开启日志"><a href="#开启日志" class="headerlink" title="开启日志"></a>开启日志</h3><ul><li><p>#include &lt;libavutil/log.h&gt;</p></li><li><p>设置日志级别<br>avi_log_set_level(AV_LOG_DEBUG)<br>常见日志级别：<br>AV_LOG_ERROR<br>AV_LOG_WARNING<br>AV_LOG_INFO<br>AV_LOG_DEBUG  </p></li><li><p>av_log(NULL,AV_LOG_INFO,”…%s\n”, op) </p></li></ul><h3 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h3><ul><li><p>#include &lt;libavformat/avformat.h&gt;<br>指定库文件位置： pkg-config –libs libavformat  </p></li><li><p>删除<br>avpriv_io_delete(“1.txt”);  </p></li><li><p>重命名<br>avpriv_io_move(“111.txt”, “222.txt”);  </p></li></ul><h3 id="操作目录"><a href="#操作目录" class="headerlink" title="操作目录"></a>操作目录</h3><ul><li><p>#include &lt;libavformat/avformat.h&gt;  </p></li><li><p>打开目录<br>avio_open_dir()</p></li><li><p>读<br>avio_read_dir()  </p></li><li><p>关闭<br>avio_close_dir()  </p></li><li><p>重要结构体<br>操作目录的上下文 AVIODirContext<br>目录项 AVIODirEntry  </p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">av_log_set_level(AV_LOG_INFO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作目录</span></span><br><span class="line">AVIODirContext *ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVIODirEntry *entry = <span class="literal">NULL</span>;</span><br><span class="line">ret = avio_open_dir(&amp;ctx, <span class="string">"./"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Cant open dir:%s\n"</span>, av_err2str(ret));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">ret = avio_read_dir(ctx, &amp;entry);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Cant read dir:%s.\n"</span>, av_err2str(ret));</span><br><span class="line"><span class="comment">//报错后，跳转到__fail 标记，释放 ctx</span></span><br><span class="line"><span class="keyword">goto</span> __fail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!entry) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"%12"</span>PRId64<span class="string">" %s \n"</span>, entry-&gt;<span class="built_in">size</span>, entry-&gt;name);</span><br><span class="line"><span class="comment">//释放 entry</span></span><br><span class="line">avio_free_directory_entry(&amp;entry);</span><br><span class="line">&#125;</span><br><span class="line">__fail;</span><br><span class="line">avio_close_dir(&amp;ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// move rename</span></span><br><span class="line">ret = avpriv_io_move(<span class="string">"111.txt"</span>, <span class="string">"222.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to rename.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"Success to rename.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete</span></span><br><span class="line">ret = avpriv_io_delete(<span class="string">"./222.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to delete.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"Success to delete.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FFmpeg-基本概念以及常用结构体"><a href="#FFmpeg-基本概念以及常用结构体" class="headerlink" title="FFmpeg 基本概念以及常用结构体"></a>FFmpeg 基本概念以及常用结构体</h2><ul><li><p>概念<br>多媒体文件本质是一个容器<br>在容器里有很多流（Stream/Track）<br>每种流是由不同的编码器编码的<br>从流中读取的数据，称为包<br>在一个包中包含着一个或多个帧，包是压缩后的数据  </p></li><li><p>常用结构体<br>AVFormatContext<br>AVStream<br>AVPacket  </p></li><li><p>FFmpeg操作流数据的基本步骤<br>解复用 –&gt; 获取流 –&gt; 读取数据包 –&gt; 操作 –&gt; 释放资源  </p></li></ul><h2 id="对复用-解复用及流操作的各种实践"><a href="#对复用-解复用及流操作的各种实践" class="headerlink" title="对复用/解复用及流操作的各种实践"></a>对复用/解复用及流操作的各种实践</h2><ul><li>打印音视频信息（meta）  </li></ul><h2 id="FFmpeg-代码结构"><a href="#FFmpeg-代码结构" class="headerlink" title="FFmpeg 代码结构"></a>FFmpeg 代码结构</h2><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/FFmpeg%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84.jpg" alt="FFmpeg-代码结构"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ffmpeg primary&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ffmpeg" scheme="https://skybrim.top/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>日本自由行</title>
    <link href="https://skybrim.top/2019/05/11/inbox/japan-travel/"/>
    <id>https://skybrim.top/2019/05/11/inbox/japan-travel/</id>
    <published>2019-05-10T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.065Z</updated>
    
    <content type="html"><![CDATA[<p>18年两人就计划好的清明日本之旅，终于开始了。<br>请了4天年假，加上清明假期，一共7天。<br>虽然有一些波折，一些意外，不过有这些才是真正的旅游。</p><a id="more"></a><h2 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h2><ul><li>护照签注</li><li>漫游wifi</li><li>人均15，000的日元的现金，主要用在交通费用</li><li>提前打印好网上预订的票</li><li>适合的衣服</li><li>应急药品</li><li>签字笔</li></ul><h2 id="3月30日，出发前一天"><a href="#3月30日，出发前一天" class="headerlink" title="3月30日，出发前一天"></a>3月30日，出发前一天</h2><blockquote><p>是等太阳升起，还是意外先来临？</p></blockquote><p>意外来临，好久没有生过病的毛毛，高烧不退！！<br>早上收到毛毛的信息，心里一沉，打包完东西后，打的到了毛毛家。<br>吃了药也不见好，一直反反复复，4点多的时候，和阿姨琪琪一起，跟毛毛去南山医院看病。<br>流感！😭。<br>医生开了药，匆匆回家，毛毛勉强收拾了一下东西，我也喝了抗病毒口服液。<br>晚上睡毛毛家沙发，希望第二天退烧，不然不好过出境安检。</p><h2 id="3月31日，出发"><a href="#3月31日，出发" class="headerlink" title="3月31日，出发"></a>3月31日，出发</h2><p>早上起来，毛毛好像好了一点，继续吃退烧药，我也抗病毒口服液两瓶。<br>叔叔开车，送我们到香港的入境口岸。<br>入境香港，也嘀了一下额温枪，还好没啥事。这里注意一下，最好自备一支笔，要填写一些表格。<br>全程高速到香港机场。</p><p>13:05，乘飞机。香港 TO 福冈 （UO 638）。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG1.jpeg" alt="1"><br>入境要填写一些表格，自备笔最好，或者机场内填写也可以。<br>大概5点到福冈机场，按指示入境即可。</p><p>17:30，搭乘公共巴士，2号线巴士，福冈空港 TO 博多站。  </p><blockquote><p>日本搭乘公交比国内复杂，简单描述一下：<br>日本公交是后门上车，前门下车。<br>上车后刷公交卡或者取一张小票，小票上有上车站编号，车的前面的显示器上，会显示当前停车站+对应编号的费用。<br>车内有很多按钮，意思是提示司机有人要下车，快到站的时候按一下就好。<br><strong>现金支付</strong><br>去司机旁边的破钱机器上，破开1000日元，取出硬币。<br>到站后，给司机看一下看投入对应的小票号码，投入硬币就好。<br><strong>刷卡</strong><br>上车刷卡，下车刷卡，金额不够，会优先扣除卡内余额，然后再投币补足即可<br><strong>apple pay</strong><br>这个我没有试过，可以尝试用日本西瓜卡公司的app，开卡，加入apple pay。<br>不要apple pay直接添加，日区的apple pay只支持日区的银行卡支付。 </p></blockquote><p>博多酒店check-in<br>博多東急REIホテル(Hakata Tokyu REI Hotel)<a href="https://maps.app.goo.gl/M3LZH" target="_blank" rel="noopener">酒店地址</a><br>到酒店，重新测了下提问，还是低烧，退烧贴继续。😌</p><p>晚餐<br>附近随便找了一家吃，应该是小火锅。万万没想到，居然是猪大肠汤底。<br>回国后了解到，这个应该是牛肠火锅，算是博多当地特产，小店人也很多。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG2.jpeg" alt="2"></p><blockquote><p>补充：<br>博多站附近也有一些可以尝试的美食，由于生病的原因，都错过了。<br>eg:墨鱼刺身、火烧鸟。</p></blockquote><hr><h2 id="4月1日，黑川温泉"><a href="#4月1日，黑川温泉" class="headerlink" title="4月1日，黑川温泉"></a>4月1日，黑川温泉</h2><p>08:30，早上起来，体温36.7，看来基本好了。711随便买了点早餐吃。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG3.jpeg" alt="3"></p><p>09:30，去博多站乘车，不同楼层不一样，城际巴士、市内公交、地铁等。<br>这个站比较大，最好提前一点去，防止迷路。<br>记不清3楼还是2楼是城际巴士，到对应的上车口等待即可。<br>博多站 TO 黑川温泉站（51202便 1号车 09:36）<br>车票是网上提前买好的，提前a4纸打印好，给司机，司机会告诉你坐哪里，当然车票上也有写位置。</p><p>大概两个半到三个小时的车程黑川温泉站。路上风景不错。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG4.jpeg" alt="4"></p><p>黑川预定的酒店会到车站接车，送我们到去温泉街游客中心，帮我们把行李寄存到酒店。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG10.jpeg" alt="5"></p><p><a href="https://maps.app.goo.gl/N5Yhy" target="_blank" rel="noopener">温泉街</a><br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG5.jpeg" alt="6"></p><p>游客中心可以一人买一个温泉手型，可以去任意几家温泉街的店泡温泉，由于生病外加天气冷，就没有这样做，只是买了个手型做纪念。<br>黑川的温泉街，不算大，很有日本特色。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG8.jpeg" alt="7"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG9.jpeg" alt="8"></p><p>有一个神社。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG7.jpeg" alt="9"></p><p>午餐随便选的一家。<br>买了一些纪念品。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG6.jpeg" alt="10"></p><p>15:00 黑川酒店check-in<br>河野裕旅馆(Ryokan Kono-Yu)<a href="https://maps.app.goo.gl/Yzqqw" target="_blank" rel="noopener">酒店地址</a><br>网上预订好的，里面有中文接待，目测应该是国人。<br>酒店是庭院式的，风景是真的好。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG13.jpeg" alt="11"></p><p>住宿的屋子是双层的，下面是用来泡温泉的，有一个小的室外温泉和一个室内温泉。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG11.jpeg" alt="12"></p><p>二层是起居室，吃晚餐的时候，工作人员会给你铺好床。  </p><p>晚餐<br>酒店提供的晚餐，很丰盛。</p><p>泡温泉<br>酒店里面转为住宿客人提供的温泉，和工作人员预约好时间，然后直接过去就好了。<br>天气很冷，室外温泉真刺激。<br>回到屋子，也试了一下小院子的温泉，里面还有立汤，可以站起来泡的地方，上面有跟杆子，可以扶着。很不错。  </p><hr><h2 id="4月2日，福冈去京都"><a href="#4月2日，福冈去京都" class="headerlink" title="4月2日，福冈去京都"></a>4月2日，福冈去京都</h2><p>08:00，起床，下雪了！不过不大。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG18.jpeg" alt="13"></p><p>雪中泡了一个早起温泉，舒服。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG12.jpeg" alt="14"></p><p>早餐，酒店早餐，依然丰盛。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG14.jpeg" alt="15"></p><p>10:00 黑川酒店check-out<br>和酒店工作人员约好乘车时间，工作人员会按时，从酒店带上行李，到游客中心街上接上我们，送到黑川温泉站。<br>逛温泉街，上吃了甜点。日本的甜点太甜了。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG19.jpeg" alt="16"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG15.jpeg" alt="17"></p><p>温泉街比较小，可以逛的地方不多，不过景色还是很不错的。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG16.jpeg" alt="18"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG17.jpeg" alt="19"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG20.jpeg" alt="20"></p><p>14:00，乘巴士<br>黑川 TO 博多 （51205便 1号车 14:00）<br>乘坐巴士，回到博多站。  </p><p>18:00，博多站换乘JR到京都站  </p><p>21:00，换成地铁，到京都酒店check-in<a href="https://maps.app.goo.gl/sffFA" target="_blank" rel="noopener">酒店地址</a><br>京都维斯塔普瑞米欧那果米泰酒店(Hotel Vista Premio Kyoto Nagomi teiu)  </p><p>22:00 附近的KFC吃了晚餐。捂脸</p><hr><h2 id="4月3日，吉野山看樱花"><a href="#4月3日，吉野山看樱花" class="headerlink" title="4月3日，吉野山看樱花"></a>4月3日，吉野山看樱花</h2><p>08:30 早餐  继续KFC</p><p>出发去京都站<br>京都站买午餐便当</p><p>购买特急车次<br><a href="https://maps.app.goo.gl/dAJdi" target="_blank" rel="noopener">京都站</a>–&gt;<a href="https://maps.app.goo.gl/UP1g9" target="_blank" rel="noopener">檀原神宫前站（换乘）</a>–&gt;<a href="https://maps.app.goo.gl/cGrKg" target="_blank" rel="noopener">吉野站</a><br>车票还是比较贵的，而且由于旺季，人还是挺多的，没有买到9点45的车次。<br>直接拿着Google地图显示的车次，在购票处给工作人员看，买票就好了。  </p><p>游览吉野山<br>由于路上看到信息，发现今年天气太冷，山上的樱花没有开，只坐巴士到中千本，然后步行逛街下山。<br>吉野站出门，往前走一点就是接驳巴士，400日元/人，到中千本下车。<br>步行下山，还是挺累的，天气也比较冷。<br>路上寺庙比较多，这个地方跟佛教有关，算日本佛教的热门旅游点。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG21.jpeg" alt="21"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG22.jpeg" alt="22"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG23.jpeg" alt="23 一目千本，可惜没有开花"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG24.jpeg" alt="24"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG25.jpeg" alt="25 仁王"></p><p>晚餐<br>回到京都市区，见了毛毛一个也是来日本旅游的朋友。<br>一起吃饭，星巴克聊天，然后回酒店休息了，比较累。</p><p>山上比较冷，加上背着东西</p><hr><h2 id="4月4日，京都一日游-amp-大阪夜樱"><a href="#4月4日，京都一日游-amp-大阪夜樱" class="headerlink" title="4月4日，京都一日游&amp;大阪夜樱"></a>4月4日，京都一日游&amp;大阪夜樱</h2><p>08:30 京都酒店check-out<br>寄存行李到酒店，白天逛京都市区。</p><p>先去豆水楼<br>路上沿着一条两边都是樱花树的河。<br>京都的街道真的很干净。</p><p>豆水楼吃午餐<br>刚刚好赶上豆水楼午餐的最后一个位置。Good Luck。<br>味道不错。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG26.jpeg" alt="26"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG27.jpeg" alt="27"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG28.jpeg" alt="28"></p><p>八班神社<br>人超级多，很多日本的学生，穿着很职业的感觉。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG29.jpeg" alt="29"></p><p>16:00，京都酒店坐地铁到京都站，转乘JR到大阪。</p><p>17:30 大阪酒店check-in<a href="https://maps.app.goo.gl/ghZ6b" target="_blank" rel="noopener">酒店地址</a><br>高级酒店-CABIN-大阪  </p><p>晚餐，去了一家寿司店吃寿司，超级大块的鳗鱼，而且不贵。  </p><p>吃完晚餐，正好去附近的一个商场，买了一顶帽子。NICE。  </p><p>乘坐地铁，<a href="https://maps.app.goo.gl/psAaQ" target="_blank" rel="noopener">夜樱毛马樱之公园</a> 观看夜樱。<br>有点黑，路灯也比较暗。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG30.jpeg" alt="30"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG36.jpeg" alt="31"></p><hr><h2 id="4月5日，大阪环球影城"><a href="#4月5日，大阪环球影城" class="headerlink" title="4月5日，大阪环球影城"></a>4月5日，大阪环球影城</h2><p>8:30 酒店出发，去大阪环球影城<br><a href="https://maps.app.goo.gl/7ocbN" target="_blank" rel="noopener">大阪环球影城</a></p><p>人多到爆炸。<br>还好买了快速通道，优先参观了快速通道上的项目。<br>蜘蛛侠，有点刺激。<br>侏罗纪公园，很刺激，溅了一脸的水。出门就是卖毛巾的，丢。还买了俯冲的时候的抓拍照片。<br>哈利波特魔法区域，人山人海。几个项目也都是非常刺激的。<br>用餐区人也是爆满，简单的吃了一点。<br>接着去鲁邦三世X名侦探柯南、小黄人区域。都是超刺激项目。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG31.jpeg" alt="32"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG32.jpeg" alt="33"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG33.jpeg" alt="34"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG34.jpeg" alt="35"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG35.jpeg" alt="36"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG37.jpeg" alt="37"></p><p>晚上吃了一点晚餐，开始环球影城的夜间活动。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG38.jpeg" alt="38"></p><p>先去哈利波特区域，霍格沃茨灯光秀。<br>人超级多，只能限流，还好我们去的早，还能进去。<br>灯光秀非常漂亮。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG39.jpeg" alt="39"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG40.jpeg" alt="40"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG41.jpeg" alt="41"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG42.jpeg" alt="42"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG43.jpeg" alt="43"></p><p>然后在主干道，看了一会游街表演。</p><p>回酒店。</p><hr><h2 id="4月6日，买买买"><a href="#4月6日，买买买" class="headerlink" title="4月6日，买买买"></a>4月6日，买买买</h2><p>9:00 大阪酒店check-out<br>乘坐地铁去<a href="https://maps.app.goo.gl/TKhEA" target="_blank" rel="noopener">DOTON PLAZA</a>，买一下去机场的巴士票，并寄存行李。  </p><p>开始买买买  </p><p><a href="https://maps.app.goo.gl/bpDb7" target="_blank" rel="noopener">道顿堀(ku)</a><br>道顿堀不错，里面很多很有日本特色的店面，外面的商标都超级巨大，有的还有动作！<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG44.jpeg" alt="44"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG45.jpeg" alt="45"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG46.jpeg" alt="46"></p><p>附近的商场开始买买买。<br>一楼化妆品，人多到爆炸，还需要预约时间段。<br>店员有很多中国人，顾客也是。<br>买完东西去退税，长龙队伍，绝大部分都是国人。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG48.jpeg" alt="47"></p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG49.jpeg" alt="48"></p><p>中午吃了附近的回转寿司，感觉超级便宜，好吃。  </p><p>下午去了<a href="https://maps.app.goo.gl/f9CST" target="_blank" rel="noopener">Orange Street</a><br>感觉并没有什么东西，和网上说的不太一样，不过人少一点，可能适合拍一些街拍吧。<br>随便逛了逛。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/WechatIMG50.jpeg" alt="49"></p><p>17:30 DOTON PLAZA，坐巴士，去<a href="https://maps.app.goo.gl/U7pyi" target="_blank" rel="noopener">关西机场</a><br>机场的免税店里，买了SK2，和一些日本点心。</p><p>22:20 乘飞机，大阪关西 TO 香港 （UO 863）</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>简单的记录一下自己的第一次出国行程，有很多不便，但有更多的快乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;18年两人就计划好的清明日本之旅，终于开始了。&lt;br&gt;请了4天年假，加上清明假期，一共7天。&lt;br&gt;虽然有一些波折，一些意外，不过有这些才是真正的旅游。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="inbox" scheme="https://skybrim.top/tags/inbox/"/>
    
      <category term="travel" scheme="https://skybrim.top/tags/travel/"/>
    
  </entry>
  
  <entry>
    <title>block</title>
    <link href="https://skybrim.top/2019/03/04/ios/block/"/>
    <id>https://skybrim.top/2019/03/04/ios/block/</id>
    <published>2019-03-04T07:17:38.000Z</published>
    <updated>2020-12-10T02:48:42.066Z</updated>
    
    <content type="html"><![CDATA[<p>Blocks</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Blocks，带有自动变量（局部变量）的匿名函数。</p><p>C 语言中的变量：</p><ul><li>自动变量（局部变量）</li><li>函数的参数</li><li>静态变量（静态局部变量）</li><li>静态全局变量</li><li>全局变量</li></ul><p>其中，静态变量（静态局部变量）、静态全局变量、全局变量 可以在函数的多次调用之间传递值。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Objective-C 中 blocks 的语法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ^ 返回值类型 参数列表 表达式</span></span><br><span class="line">^<span class="keyword">void</span> (<span class="keyword">int</span> a) &#123; <span class="built_in">NSLog</span>(<span class="string">"%d"</span>, a); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值类型省略，表达式有 return 使用返回值类型，没有 return 使用 void，多个 return 必须类型相同</span></span><br><span class="line">^(<span class="keyword">int</span> count) &#123; <span class="keyword">return</span> count + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用参数，参数列表也可以省略</span></span><br><span class="line">^&#123; <span class="built_in">NSLog</span>(<span class="string">"abc"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 block 类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^blk_t)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><h2 id="Block-实质"><a href="#Block-实质" class="headerlink" title="Block 实质"></a>Block 实质</h2><p>clang(LLVM编译器)，将 block 语法的代码，转变为 C++ 的源代码，观察 block 实质。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure><h3 id="没有截获自动变量的-block"><a href="#没有截获自动变量的-block" class="headerlink" title="没有截获自动变量的 block"></a>没有截获自动变量的 block</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// block </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main() &#123; </span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123; printf(<span class="string">"hello\n"</span>); &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器转为 C++ </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __main_block_impl_0 内部 impl 的类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __main_block_impl_0 内部 Desc 的类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式转换的 C函数 __main_block_func_0 的参数 cself 的类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// __main_block_impl_0 的构造函数</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock; <span class="comment">/* isa 指针 */</span></span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp; <span class="comment">/* 函数的指针 */</span></span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式 ^&#123;printf("hello");&#125;; 转变为 __main_block_func_0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello\n"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// struct __main_block_impl_0 tmp = __main_block_impl_0(__main_block_func_0, /* Block语法中表达式转换的C 函数的指针 */ </span></span><br><span class="line">                                                            &amp;__main_block_desc_0_DATA);</span><br><span class="line">    <span class="comment">// struct __main_blcok_impl_0 *blk = &amp;tmp; /* __main_blcok_impl_0 的指针赋值给 blk */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="截获自动变量的-block"><a href="#截获自动变量的-block" class="headerlink" title="截获自动变量的 block"></a>截获自动变量的 block</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">int</span> dmy = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"val = %d\n"</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123; printf(fmt, val); &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __main_block_impl_0 内部 impl 的类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __main_block_impl_0 内部 Desc 的类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式转换的 C函数 __main_block_func_0 的参数 cself 的类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="comment">// 截获的自动变量</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _val, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), val(_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 表达式 ^&#123; printf(fmt, val); &#125;; 转变为 __main_block_func_0</span></span><br><span class="line"><span class="comment">// __cself-&gt;val，此 val 是在创建 blcok 时保存到 block 中的自动变量的值</span></span><br><span class="line"><span class="comment">// 并不能拿到自动变量，所以我们只能使用，而不能赋值给自动变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = __cself-&gt;fmt; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="keyword">int</span> val = __cself-&gt;val; <span class="comment">// bound by copy</span></span><br><span class="line"> <span class="built_in">printf</span>(fmt, val); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dmy = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"val = %d\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 block 的时候，将 block 使用的自动变量的值，保存到 block 的结构体实例（即 block 自身）中</span></span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态变量-amp-静态全局变量-amp-全局变量"><a href="#静态变量-amp-静态全局变量-amp-全局变量" class="headerlink" title="静态变量 &amp; 静态全局变量 &amp; 全局变量"></a>静态变量 &amp; 静态全局变量 &amp; 全局变量</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> global_val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_val = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_val = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        global_val *= <span class="number">1</span>;</span><br><span class="line">        static_global_val *= <span class="number">2</span>;</span><br><span class="line">        static_val *= <span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">int</span> global_val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_val = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="comment">// 静态变量的指针</span></span><br><span class="line">  <span class="keyword">int</span> *static_val;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> *_static_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : static_val(_static_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> *static_val = __cself-&gt;static_val; <span class="comment">// bound by copy</span></span><br><span class="line">        <span class="comment">// 直接操作 全局变量 和 静态全局变量</span></span><br><span class="line">        global_val *= <span class="number">1</span>;</span><br><span class="line">        static_global_val *= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 通过指针，操作静态变量</span></span><br><span class="line">        (*static_val) *= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_val = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 参数 &amp;static_val，构建 block 时，将静态变量的指针赋值到 block 中</span></span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：</p><p>为什么操作静态变量可以使用指针，而操作自动变量没有这么做？</p><p>因为 block 调用时，可能已经超过自动变量的作用域，自动变量的指针，超出其自身的作用域后就会被废弃，所以操作指针的方式只适用于静态变量。</p><h3 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    __block <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        val = <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __block 修饰 int，转换为 C++ 的源码</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_val_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_val_0 *__forwarding; <span class="comment">// 自身类型的指针</span></span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="comment">// __block 对象</span></span><br><span class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line">        <span class="comment">// 为什么需要一个额外的指针，而不是直接取值？解释在下面。</span></span><br><span class="line">        (val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造 __block</span></span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">// 构造 block</span></span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>));</span><br><span class="line">    <span class="comment">// block 执行</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>block 的存储域</p><p>block 是 objective-c 的对象。block 的类有三种，_NSConcreteStackBlock、_NSConcreteGlobalBlock、_NSConcreteMallocBlock。</p><table><thead><tr><th>类</th><th>设置对象的存储域</th></tr></thead><tbody><tr><td>_NSConcreteStackBlock</td><td>栈</td></tr><tr><td>_NSConcreteGlobalBlock</td><td>程序的数据区域（.data 区）</td></tr><tr><td>_NSConcreteMallocBlock</td><td>堆</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/block_0.png" alt=""></p></li><li><p>_NSConcreteGlobalBlock</p><ol><li>block 声明在全局变量的地方</li><li>block 表达式中没有使用自动变量，虽然 clang 转换的源码通常是_NSConcreteStackBlock，但实现上不同</li></ol><p>即，block 存储在程序的数据区域中。</p></li><li><p>_NSConcreteStackBlock</p><p>除了上述两种 global 情况外，其他 block 为 _NSConcreteStackBlock 对象，存储在栈上。</p></li><li><p>_NSConcreteMallocBlock</p><p>何时使用堆上的 _NSConcreteMallocBlock?</p><p>设置在栈上的 block 和 __block 对象，在离开了所属变量的作用域时，就会被废弃。</p><p>Blocks 提供了将 block 和 __block 对象，从栈上赋值到堆上的方法来解决这个问题。</p><p>复制到堆上的 block 将 _NSConcreteMallocBlock 类对象写入 block 的结构体实例的变量 isa</p><p>impl.isa = &amp;_NSConcreteMallocBlock;</p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/block_1.png" alt=""></p><p>当 block 被复制到堆上时，block 使用的所有 __block 变量，也会被复制到堆上，此时 block 持有 __block 变量。</p><p>__block 对象的 __forwarding 指针，则会在复制到堆上后，指向堆上的 __block 结构体实例的地址。</p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/block_2.png" alt=""></p></li><li><p>什么时候栈上的 block 会被复制到堆上呢？</p><ul><li>调用 block 的 copy 实例方法；</li><li>block 作为函数的返回值</li><li>将 block 赋值给 __strong 修饰的 id 类型的类或 block 类型成员变量时；</li><li>在方法名中含有 usingBlock 的 Cocoa 框架方法，或者 GCD 的 API 中传递 block 时。</li></ul></li></ul><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>如果在 block 中使用 strong 修饰符的对象的自动变量，那么当 block 从栈复制到堆上时，改对象被 block 持有。</p><p>此时可能产生循环引用。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// block 循环引用实例代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span>: <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">  blk_t blk_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  blk_ = ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"self = %@"</span>, <span class="keyword">self</span>); &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)execBlock &#123;</span><br><span class="line">  blk_();</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"dealloc"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">  <span class="keyword">id</span> foo = [[MyObject alloc] init];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, foo);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，dealloc 方法没有被调用。</p><ol><li>foo 强引用 blk_</li><li>blk_ 强引用 foo。</li></ol><p>解决方法：</p><ul><li><p>使用 weak</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> tmp = <span class="keyword">self</span>;</span><br><span class="line">blk_ = ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"self = %@"</span>, tmp); &#125;;</span><br></pre></td></tr></table></figure><ol><li>foo 强引用 blk_</li><li>blk_ 弱引用 foo。</li></ol></li><li><p>使用 __block</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">id</span> tmp = <span class="keyword">self</span>;</span><br><span class="line">blk_ = ^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"self = %@"</span>, <span class="keyword">self</span>);</span><br><span class="line">  tmp = <span class="literal">nil</span>; <span class="comment">// 置空 tmp</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 必须执行 blk_()</span></span><br><span class="line">[foo execBlock];</span><br></pre></td></tr></table></figure><ol><li>foo 强引用 blk_;</li><li>blk_ 强引用 __block 修饰的 tmp;</li><li>tmp 强引用 foo;</li><li><strong>执行完 blk_(), tmp 对 foo 没有引用</strong></li></ol><p>简单起见，使用 weak 方法。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Blocks&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Aspects 原理简析</title>
    <link href="https://skybrim.top/2019/01/01/ios/aspects/"/>
    <id>https://skybrim.top/2019/01/01/ios/aspects/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.066Z</updated>
    
    <content type="html"><![CDATA[<p>Aspects 是使用 Objective-C 语言编写的AOP 库。在此简单的记录一下原理简析，备忘。</p><a id="more"></a><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><ul><li><p><strong>下文中，selector 指开发者想 hook 的方法，block 指开发者想执行的代码</strong></p></li><li><p>aspect_add<br>保存所有开发者需要执行的 block 到 容器中<br>执行 aspect_prepareClassAndHookSelector  </p></li><li><p>aspect_prepareClassAndHookSelector<br>动态创建子类：aspect_hookClass<br>给 selector 起了一个别名(添加了前缀 Aspects__)，并将 selector 的 imp 指向了 Aspects__selector<br>将 _objc_msgForward/_objc_msgForward_stret 的 imp 指向了 selector  </p></li><li><p>aspect_hookClass<br>动态生成子类<br>交换方法 aspect_swizzleForwardInvocation  </p></li><li><p>aspect_swizzleForwardInvocation<br>将 forwardInvocation: 的 IMP 指向了 Aspects 自定义的 IMP __ASPECTS_ARE_BEING_CALLED__  </p></li><li><p>__ASPECTS_ARE_BEING_CALLED__<br>根据参数 invocation ，获得 selector ，拿到 aliasSelector(即：Aspects__selector) ，根据 aliasSelector 拿到 selector 的 IMP<br>从容器中取出所有的 before instead after 的 block，按照顺序，依次执行，没有 instead 的 block ，就执行 aliasSelector。  </p></li><li><p>执行<br>执行代码，当调用 selector 时，其 imp 是 _objc_msgForward/_objc_msgForward_stret ，直接触发了 forwardInvocation: ，此时 forwardInvocation: 的 imp 指向的是自定义的 __ASPECTS_ARE_BEING_CALLED__ ，在其内执行了 block  </p></li></ul><h2 id="入口方法"><a href="#入口方法" class="headerlink" title="入口方法"></a>入口方法</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                           withOptions:(AspectOptions)options</span><br><span class="line">                            usingBlock:(<span class="keyword">id</span>)block</span><br><span class="line">                                 error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                           withOptions:(AspectOptions)options</span><br><span class="line">                            usingBlock:(<span class="keyword">id</span>)block</span><br><span class="line">                                 error:(<span class="built_in">NSError</span> **)error;</span><br></pre></td></tr></table></figure><h2 id="aspect-add"><a href="#aspect-add" class="headerlink" title="aspect_add"></a>aspect_add</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> aspect_add(<span class="keyword">id</span> <span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="keyword">id</span> block, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(block);</span><br><span class="line"></span><br><span class="line">    __block AspectIdentifier *identifier = <span class="literal">nil</span>;</span><br><span class="line">    aspect_performLocked(^&#123;</span><br><span class="line">        <span class="comment">//过滤一些方法 . eg: delloc</span></span><br><span class="line">        <span class="keyword">if</span> (aspect_isSelectorAllowedAndTrack(<span class="keyword">self</span>, selector, options, error)) &#123;</span><br><span class="line">            <span class="comment">// 使用 lazy load 的方式，为 self 生成一个 AspectsContainer 容器</span></span><br><span class="line">            AspectsContainer *aspectContainer = aspect_getContainerForObject(<span class="keyword">self</span>, selector);</span><br><span class="line">            <span class="comment">//创建 AspectIdentifier 保存 block</span></span><br><span class="line">            identifier = [AspectIdentifier identifierWithSelector:selector</span><br><span class="line">                                                           object:<span class="keyword">self</span></span><br><span class="line">                                                          options:options</span><br><span class="line">                                                            block:block</span><br><span class="line">                                                            error:error];</span><br><span class="line">            <span class="keyword">if</span> (identifier) &#123;</span><br><span class="line">                <span class="comment">//将 AspectIdentifier 加入到容器中</span></span><br><span class="line">                [aspectContainer addAspect:identifier</span><br><span class="line">                               withOptions:options];</span><br><span class="line">                <span class="comment">// ****** 重要 ******</span></span><br><span class="line">                <span class="comment">// Modify the class to allow message interception.</span></span><br><span class="line">                aspect_prepareClassAndHookSelector(<span class="keyword">self</span>, selector, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="aspect-prepareClassAndHookSelector"><a href="#aspect-prepareClassAndHookSelector" class="headerlink" title="aspect_prepareClassAndHookSelector"></a>aspect_prepareClassAndHookSelector</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_prepareClassAndHookSelector(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    <span class="comment">// 动态生成了一个子类，在这个方法里，hook 了 forwardInvocation</span></span><br><span class="line">    Class klass = aspect_hookClass(<span class="keyword">self</span>, error);</span><br><span class="line">    <span class="comment">//根据 SEL 获取 IMP</span></span><br><span class="line">    Method targetMethod = class_getInstanceMethod(klass, selector);</span><br><span class="line">    IMP targetMethodIMP = method_getImplementation(targetMethod);</span><br><span class="line">    <span class="comment">// 检查如果目标方法的实现还不是 _objc_msgForward 或者 _objc_msgForward_stret 的话，就进行 hook</span></span><br><span class="line">    <span class="keyword">if</span> (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;</span><br><span class="line">        <span class="comment">// Make a method alias for the existing method implementation, it not already copied.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = method_getTypeEncoding(targetMethod);</span><br><span class="line">         <span class="comment">// 给被替换的 selector 取一个别名</span></span><br><span class="line">        SEL aliasSelector = aspect_aliasForSelector(selector);</span><br><span class="line">        <span class="comment">// 为类增加一个 SEL 为 aliasSelector， 实现为 selector 的 IMP</span></span><br><span class="line">        <span class="keyword">if</span> (![klass instancesRespondToSelector:aliasSelector]) &#123;</span><br><span class="line">            __unused <span class="built_in">BOOL</span> addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);</span><br><span class="line">            <span class="built_in">NSCAssert</span>(addedAlias, <span class="string">@"Original implementation for %@ is already copied to %@ on %@"</span>, <span class="built_in">NSStringFromSelector</span>(selector), <span class="built_in">NSStringFromSelector</span>(aliasSelector), klass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在先前的动态生成子类的方法 aspect_hookClass 里面，hook 了 forwardInvocation</span></span><br><span class="line">        <span class="comment">// 把原 selector 的 imp 指向 _objc_msgForward 或 _objc_msgForward_stret。</span></span><br><span class="line">        <span class="comment">// 这样当调用原 selector 就可以直接触发消息转发，即 _objc_msgForward</span></span><br><span class="line">        <span class="comment">// We use forwardInvocation to hook in.</span></span><br><span class="line">        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(<span class="keyword">self</span>, selector), typeEncoding);</span><br><span class="line">        AspectLog(<span class="string">@"Aspects: Installed hook for -[%@ %@]."</span>, klass, <span class="built_in">NSStringFromSelector</span>(selector));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="aspect-hookClass"><a href="#aspect-hookClass" class="headerlink" title="aspect_hookClass"></a>aspect_hookClass</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class aspect_hookClass(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">    Class statedClass = <span class="keyword">self</span>.class;</span><br><span class="line">    Class baseClass = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(baseClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Already subclassed</span></span><br><span class="line">    <span class="keyword">if</span> ([className hasSuffix:AspectsSubclassSuffix]) &#123;</span><br><span class="line">        <span class="keyword">return</span> baseClass;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We swizzle a class object, not a single object.</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (class_isMetaClass(baseClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace((Class)<span class="keyword">self</span>);</span><br><span class="line">        <span class="comment">// Probably a KVO'ed class. Swizzle in place. Also swizzle meta classes in place.</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (statedClass != baseClass) &#123;</span><br><span class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace(baseClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态生成 子类</span></span><br><span class="line">    <span class="comment">// Default case. Create dynamic subclass.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;</span><br><span class="line">    Class subclass = objc_getClass(subclassName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</span><br><span class="line">        subclass = objc_allocateClassPair(baseClass, subclassName, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *errrorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"objc_allocateClassPair failed to allocate class %s."</span>, subclassName];</span><br><span class="line">            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ***** 重要，在这个里 hook forwardInvocation *****</span></span><br><span class="line">        aspect_swizzleForwardInvocation(subclass);</span><br><span class="line">        aspect_hookedGetClass(subclass, statedClass);</span><br><span class="line">        aspect_hookedGetClass(object_getClass(subclass), statedClass);</span><br><span class="line">        objc_registerClassPair(subclass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    object_setClass(<span class="keyword">self</span>, subclass);</span><br><span class="line">    <span class="keyword">return</span> subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="aspect-swizzleForwardInvocation"><a href="#aspect-swizzleForwardInvocation" class="headerlink" title="aspect_swizzleForwardInvocation"></a>aspect_swizzleForwardInvocation</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> AspectsForwardInvocationSelectorName = <span class="string">@"__aspects_forwardInvocation:"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_swizzleForwardInvocation(Class klass) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</span><br><span class="line">    <span class="comment">//一般不会去实现 forwardInvocation ，所以不一定有原始 forwardInvocation 的 imp</span></span><br><span class="line">    <span class="comment">//Aspects把forwardInvocation的实现换成了__ASPECTS_ARE_BEING_CALLED__这个函数</span></span><br><span class="line">    <span class="comment">//原始的forwardInvocation实现的名字就变成了__aspects_forwardInvocation</span></span><br><span class="line">    <span class="comment">// If there is no method, replace will act like class_addMethod.</span></span><br><span class="line">    IMP originalImplementation = class_replaceMethod(klass, <span class="keyword">@selector</span>(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, <span class="string">"v@:@"</span>);</span><br><span class="line">    <span class="keyword">if</span> (originalImplementation) &#123;</span><br><span class="line">        class_addMethod(klass, <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName), originalImplementation, <span class="string">"v@:@"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    AspectLog(<span class="string">@"Aspects: %@ is now aspect aware."</span>, <span class="built_in">NSStringFromClass</span>(klass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ASPECTS-ARE-BEING-CALLED"><a href="#ASPECTS-ARE-BEING-CALLED" class="headerlink" title="__ASPECTS_ARE_BEING_CALLED__"></a>__ASPECTS_ARE_BEING_CALLED__</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ASPECTS_ARE_BEING_CALLED__(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSInvocation</span> *invocation) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(invocation);</span><br><span class="line">    <span class="comment">// 从消息转发的参数 invocation 中,得到原 selector</span></span><br><span class="line">    SEL originalSelector = invocation.selector;</span><br><span class="line">     <span class="comment">//selector 添加前缀，</span></span><br><span class="line">    <span class="comment">//之前在 aspect_prepareClassAndHookSelector 方法中用新的 selector 添加了新的 method，新的 method 的 imp 是原imp</span></span><br><span class="line">    <span class="comment">//根据这个 selector，在容器中寻找 block，并全部执行</span></span><br><span class="line">    SEL aliasSelector = aspect_aliasForSelector(invocation.selector);</span><br><span class="line">    <span class="comment">//将 invocation 中的 selector 也替换撑新的 selector，imp 是原imp</span></span><br><span class="line">    invocation.selector = aliasSelector;</span><br><span class="line">    <span class="comment">//拿到存储自定义的 block 的容器，包括实例方法和类方法</span></span><br><span class="line">    AspectsContainer *objectContainer = objc_getAssociatedObject(<span class="keyword">self</span>, aliasSelector);</span><br><span class="line">    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(<span class="keyword">self</span>), aliasSelector);</span><br><span class="line">    <span class="comment">//根据 invocation 拿到 info，根据 info 从容器中取出 block</span></span><br><span class="line">    AspectInfo *info = [[AspectInfo alloc] initWithInstance:<span class="keyword">self</span> invocation:invocation];</span><br><span class="line">    <span class="built_in">NSArray</span> *aspectsToRemove = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 AspectPositionBefore 的 block</span></span><br><span class="line">    <span class="comment">// Before hooks.</span></span><br><span class="line">    aspect_invoke(classContainer.beforeAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.beforeAspects, info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行原 selector 或者 Instead</span></span><br><span class="line">    <span class="comment">// Instead hooks.</span></span><br><span class="line">    <span class="built_in">BOOL</span> respondsToAlias = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;</span><br><span class="line">        aspect_invoke(classContainer.insteadAspects, info);</span><br><span class="line">        aspect_invoke(objectContainer.insteadAspects, info);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Class klass = object_getClass(invocation.target);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123;</span><br><span class="line">                [invocation invoke];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行 AspectPositionAfter 的 block</span></span><br><span class="line">    <span class="comment">// After hooks.</span></span><br><span class="line">    aspect_invoke(classContainer.afterAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.afterAspects, info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If no hooks are installed, call original implementation (usually to throw an exception)</span></span><br><span class="line">    <span class="keyword">if</span> (!respondsToAlias) &#123;</span><br><span class="line">        <span class="comment">// 如果没有执行的话，好执行默认的 forwardInvocation</span></span><br><span class="line">        invocation.selector = originalSelector;</span><br><span class="line">        SEL originalForwardInvocationSEL = <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName);</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:originalForwardInvocationSEL]) &#123;</span><br><span class="line">            ((<span class="keyword">void</span>( *)(<span class="keyword">id</span>, SEL, <span class="built_in">NSInvocation</span> *))objc_msgSend)(<span class="keyword">self</span>, originalForwardInvocationSEL, invocation);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span> doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 做一些额外的清理</span></span><br><span class="line">    <span class="comment">// Remove any hooks that are queued for deregistration.</span></span><br><span class="line">    [aspectsToRemove makeObjectsPerformSelector:<span class="keyword">@selector</span>(remove)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Aspects 是使用 Objective-C 语言编写的AOP 库。在此简单的记录一下原理简析，备忘。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Copy</title>
    <link href="https://skybrim.top/2019/01/01/ios/copy/"/>
    <id>https://skybrim.top/2019/01/01/ios/copy/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.066Z</updated>
    
    <content type="html"><![CDATA[<p>Copy 在 Objective-C 中的使用，一些个人理解。</p><a id="more"></a><h2 id="Object-Copying"><a href="#Object-Copying" class="headerlink" title="Object Copying"></a>Object Copying</h2><p>OC 中，一个<strong>对象</strong>，如果遵循 NSCopying 协议，且实现了 <code>copyWihtZone:</code> 方法，就可以被拷贝。</p><p>如果<strong>类</strong>具有不可变和可变两种变体，通过遵循 NSMutableCopying 协议，并实现 <code>mutableCopyWithZone:</code> 来确保<strong>可变对象</strong>的拷贝也是可变的</p><p>Copy 分为 shadow copy 和 deep copy，这两种 copy 的区别，主要在堆指针的处理：</p><ol><li>shadow copy 仅复制对象的引用指针</li><li>deep copy 复制新的对象</li></ol><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/copy_01.png" alt=""></p><p><strong>注意</strong>：</p><p>对象的 copy，不能仅仅看内存地址来分辨是 shadow 还是 deep。</p><p>比如 NSString，对其使用 copy，返回地址与原对象相同，但是两个对象是完全独立的，相互修改不影响</p><h2 id="Object-Copying-Memory-Management"><a href="#Object-Copying-Memory-Management" class="headerlink" title="Object Copying Memory Management"></a>Object Copying Memory Management</h2><p>对象复制，会返回一个引用计数为 1 的新对象。</p><p>这个复制的对象的内存管理，谁引用谁负责释放。</p><h2 id="copy-修饰属性"><a href="#copy-修饰属性" class="headerlink" title="copy 修饰属性"></a>copy 修饰属性</h2><p>copy 作为 内存管理语义 ，在 @property 中声明，其目的是：复制外部的传过来的值并隔断之后外界值修改对属性的影响。</p><p>对应的， strong(retain) 修饰词，只是将外部值或者指针赋值给属性（shadow copy），如果是对象指针，之后外部值修改会影响属性。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copy 修饰</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *copyStr;</span><br><span class="line">- (<span class="keyword">void</span>)setCopyStr:(<span class="built_in">NSString</span> *)copyStr &#123;</span><br><span class="line">    <span class="keyword">if</span> (_copyStr != copyStr) &#123;</span><br><span class="line">        [_copyStr release];</span><br><span class="line">        _copyStr = [copyStr <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strong(retain) 修饰</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *strongStr;</span><br><span class="line">- (<span class="keyword">void</span>)setStrongStr:(<span class="built_in">NSString</span> *)strongStr &#123;</span><br><span class="line">    <span class="keyword">if</span> (_strongStr != strongStr) &#123;</span><br><span class="line">        [_strongStr release];</span><br><span class="line">        [strongStr <span class="keyword">retain</span>];</span><br><span class="line">        _strongStr = strongStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察赋值方法，引申出一个小知识点：</p><p>使用<code>self.foo = foo;</code>语法赋值，调用了 setter 方法；使用<code>_foo = foo;</code>则只是改变指针指向。</p><p>如果只是简单的变更指针指向，可能会导致可变对象和不可变对象混淆。</p><p>因此，更推荐使用<code>self.</code>语法进行赋值</p><ul><li>NSString</li></ul><p>在 OC 中，因为父类指针可以指向子类对象，使用 copy 的目的是为了让本对象的属性不受外界影响。</p><p>使用 copy 修饰 NSString，无论传入是一个可变对象还是不可对象，对象持有的就是一个不可变的副本.  </p><p>注意：无论原来的 string 类型是否可变，copy 后的类型均为不可变类型。</p><ul><li>collection</li></ul><p>NSArray、NSDictionary、NSSet 属于 collection 集合类对象。</p><p>这些集合类的属性，使用 copy 修饰，只能保证容器本身的不变，如果容器内的引用对象，发生了变化，这些容器属性中的对象也会发生变化。</p><ul><li>block</li></ul><p>block 使用 copy 是从 MRC 遗留下来的“传统”。</p><p>在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区。</p><p>在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 可以提示：编译器自动对 block 进行了 copy 操作。</p><p>如果block块没有访问处于栈区的变量（比如局部变量），也没有访问堆区的变量（比如我们alloc创建的对象），那就存在代码区(低地址)，即使访问了全局变量，也依然存在代码区。</p><p>如果访问了栈区或者堆区的变量，那就会被存在堆区（实际存在栈区，ARC下会自动拷贝到堆区）。</p><h2 id="copy-mutableCopy-方法"><a href="#copy-mutableCopy-方法" class="headerlink" title="copy mutableCopy 方法"></a>copy mutableCopy 方法</h2><p>主动调用 <code>copy</code> 方法，其<strong>目的</strong>是为了 copy 一个新对象。</p><p>此时需要根据对象的类实现的 <code>copyWithZone:</code> 方法来判断是 shadow 还是 deep。</p><ul><li>非集合类对象</li></ul><p>对 immutable 对象进行 copy 操作， 执行结果类似 retain 操作，但操作的目的是为了 copy 对象。</p><p>对 immutable 对象进行 mutableCopy 操作时内容复制。</p><p>对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[immutableObject <span class="keyword">copy</span>] <span class="comment">// 类似 retain</span></span><br><span class="line">[immutableObject mutableCopy] <span class="comment">//深复制</span></span><br><span class="line">[mutableObject <span class="keyword">copy</span>] <span class="comment">//深复制</span></span><br><span class="line">[mutableObject mutableCopy] <span class="comment">//深复制</span></span><br></pre></td></tr></table></figure><ul><li>集合类对象</li></ul><p>和上面非集合类对象十分类似。</p><p>但是无论是 copy 还是 mutableCopy，集合中的元素，都是仅仅执行了一次 retain 操作，依然是原对象</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[immutableCollection <span class="keyword">copy</span>]</span><br><span class="line">[immutableCollection mutableCopy] <span class="comment">//深复制</span></span><br><span class="line">[mutableCollection <span class="keyword">copy</span>] <span class="comment">//深复制</span></span><br><span class="line">[mutableCollection mutableCopy] <span class="comment">//深复制</span></span><br></pre></td></tr></table></figure><h2 id="copy-collection"><a href="#copy-collection" class="headerlink" title="copy collection"></a>copy collection</h2><p>当我们对集合类型的对象，使用 copy 或者 mutableCopy，都是对集合对象本身的拷贝，集合中的元素，都仅仅是一个 retain 操作。</p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/CopyingCollections_2x.png" alt="array copy">  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *view1 = [<span class="built_in">UIView</span> new];</span><br><span class="line"><span class="built_in">UIView</span> *view2 = [<span class="built_in">UIView</span> new];</span><br><span class="line"><span class="built_in">UIView</span> *view3 = [<span class="built_in">UIView</span> new];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *array = @[view1, view2, view3,];</span><br><span class="line"><span class="built_in">NSArray</span> *copyArray = [array <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mCopyArray = [array mutableCopy];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"array %p \n %@"</span>, array, array);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"copy %p \n %@"</span>, copyArray, copyArray);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"mutableCopy %p \n %@"</span>, mCopyArray, mCopyArray);</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">array <span class="number">0x600003da2ca0</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033feca0&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033fede0&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033feda0&gt;"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">copy</span> <span class="number">0x600003da2ca0</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033feca0&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033fede0&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033feda0&gt;"</span></span><br><span class="line">)</span><br><span class="line">mutableCopy <span class="number">0x600003da2af0</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033feca0&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033fede0&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033feda0&gt;"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如何对集合对象进行 deep copy 呢？</p><p><strong>首先，需要集合对象中的元素，实现 NSCopying 协议</strong></p><p>使用 <code>initWithArray:copyItems:</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *oneLevelDeepCopy = [[<span class="built_in">NSArray</span> alloc] initWithArray:array copyItems:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"oneLevelDeepCopy %p \n %@"</span>, oneLevelDeepCopy, oneLevelDeepCopy);</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">oneLevelDeepCopy <span class="number">0x600003d9ef10</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033b47a0&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033b4780&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033b4760&gt;"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>initWithArray:copyItems:</code> 这个方法，只能对一元数组进行 deep copy。</p><p>apple 推荐使用 NSKeyedArchiver 实现 true deep copy。<strong>需要集合对象中的元素，实现 NSCoding 协议</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *twoLevelArray = @[@[obj1, obj2, obj3,]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"twoLevelArray %p \n %@"</span>, twoLevelArray, twoLevelArray);</span><br><span class="line"><span class="built_in">NSArray</span> *oneLevelDeepCopy2 = [[<span class="built_in">NSArray</span> alloc] initWithArray:twoLevelArray copyItems:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"oneLevelDeepCopy2 %p \n %@"</span>, oneLevelDeepCopy2, oneLevelDeepCopy2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span>* trueDeepCopyArray = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:</span><br><span class="line">[<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:array]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"trueDeepCopyArray %p \n %@"</span>, trueDeepCopyArray, trueDeepCopyArray);</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">twoLevelArray <span class="number">0x6000031f07e0</span></span><br><span class="line">(</span><br><span class="line">        (</span><br><span class="line">        <span class="string">"&lt;ObjectCopyingCoding: 0x6000033feca0&gt;"</span>,</span><br><span class="line">        <span class="string">"&lt;ObjectCopyingCoding: 0x6000033fede0&gt;"</span>,</span><br><span class="line">        <span class="string">"&lt;ObjectCopyingCoding: 0x6000033feda0&gt;"</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">oneLevelDeepCopy2 <span class="number">0x6000031e3c20</span></span><br><span class="line">(</span><br><span class="line">        (</span><br><span class="line">        <span class="string">"&lt;ObjectCopyingCoding: 0x6000033feca0&gt;"</span>,</span><br><span class="line">        <span class="string">"&lt;ObjectCopyingCoding: 0x6000033fede0&gt;"</span>,</span><br><span class="line">        <span class="string">"&lt;ObjectCopyingCoding: 0x6000033feda0&gt;"</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">trueDeepCopyArray <span class="number">0x600003d9ae80</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033e6e00&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033e6e20&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;ObjectCopyingCoding: 0x6000033e4e40&gt;"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectCopying.html" target="_blank" rel="noopener">Object Copying</a></p><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW3" target="_blank" rel="noopener">Copying Collections</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Copy 在 Objective-C 中的使用，一些个人理解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>icon font</title>
    <link href="https://skybrim.top/2019/01/01/ios/icon-font/"/>
    <id>https://skybrim.top/2019/01/01/ios/icon-font/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.066Z</updated>
    
    <content type="html"><![CDATA[<p>icon font  </p><a id="more"></a><p>优点：<br>1、减少包的体积<br>2、无需2x或者3x<br>3、颜色修改方便准确<br>缺点：<br>1、只有单色<br>2、使用时需要使用 unicode 字符<br>3、维护 ttf 字体库  </p><!--more--><h2 id="获取-iconfont"><a href="#获取-iconfont" class="headerlink" title="获取 iconfont"></a>获取 iconfont</h2><ul><li>1 <a href="https://www.iconfont.cn/" target="_blank" rel="noopener">iconfont.cn</a><br>  Iconfont阿里的矢量图标库，可以直接使用里面的免费的iconfont，设计师也可以将自己的矢量图 svg 上传到 iconfont，在线管理。<br>  开发人员将需要的 iconfont 加入购物车，下载代码，找到 ttf 文件；  </li><li>2 本地管理<br>  使用第三方工具，如 iconfount、FontForge，通过 svg 矢量图，生成 ttf 文件。</li></ul><h2 id="iOS-开发使用-iconfont"><a href="#iOS-开发使用-iconfont" class="headerlink" title="iOS 开发使用 iconfont"></a>iOS 开发使用 iconfont</h2><ul><li><p>1 注册字体<br>  iOS中加入字体文件，需要先把 ttf 文件加入项目，然后注册字体。<br>  注册字体分两种：<br>  1、info.plist 中， Fonts provided by application<br>  2、使用 API 注册<br>  建议使用 API 注册，方便下载字体注册  </p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIFont</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">registerFont</span><span class="params">(fontName: String)</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">Bundle</span>.main.url(forResource: fontName, withExtension: <span class="string">"ttf"</span>),</span><br><span class="line">           <span class="keyword">let</span> fontDataProvider = <span class="type">CGDataProvider</span>(url: url <span class="keyword">as</span> <span class="type">NSURL</span>),</span><br><span class="line">           <span class="keyword">let</span> newFont = <span class="type">CGFont</span>(fontDataProvider) &#123;</span><br><span class="line">           <span class="type">CTFontManagerRegisterGraphicsFont</span>(newFont, <span class="literal">nil</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2 使用 iconfont<br>  一般采用 UIImage 的形式使用</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span><span class="params">(iconCode: String, fontName: String, size: CGFloat, color: UIColor)</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">       <span class="keyword">let</span> imageSize = <span class="type">CGSize</span>(width: size, height: size)</span><br><span class="line">       <span class="type">UIGraphicsBeginImageContextWithOptions</span>(imageSize, <span class="literal">false</span>, <span class="type">UIScreen</span>.main.scale)</span><br><span class="line">       <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: size, height: size))</span><br><span class="line">       label.font = <span class="type">UIFont</span>(name: fontName, size: size)</span><br><span class="line">       label.text = iconCode</span><br><span class="line">       label.textColor = color</span><br><span class="line">       label.layer.render(<span class="keyword">in</span>: <span class="type">UIGraphicsGetCurrentContext</span>()!)</span><br><span class="line">       <span class="keyword">let</span> retImage = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">       <span class="keyword">return</span> retImage</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  iconfont 使用时，需要使用 Unicode 编码，打开从 iconfont.cn 下载的文件夹，找到 html 文件，打开，会看到 &amp;#xXXXX 的 Unicode 编码。<br>  在 Swift 中，使用 \u{XXXX} ,将上面的 XXXX 替换一下即可。<br>  建议在工程中，维护一个 enum ，方便使用。<br>  在 iconfont.cn 的项目页面，打开 chrome 开发者工具的 console ，执行如下 JavaScript 脚本，获取枚举结构。  </p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function camelCase(text, separator) &#123;</span><br><span class="line">   <span class="keyword">var</span> arr = text.<span class="built_in">split</span>(separator);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">         <span class="keyword">var</span> s = arr[i].slice(<span class="number">0</span>, <span class="number">1</span>).toUpperCase(); </span><br><span class="line">         <span class="keyword">var</span> h = arr[i].slice(<span class="number">1</span>);</span><br><span class="line">         arr[i] = s + h;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> arr.<span class="built_in">join</span>('')</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> items = document.getElementsByClassName('icon-item')</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = items.length; i &lt; len; i++) &#123;</span><br><span class="line">   <span class="keyword">let</span> item = items[i]</span><br><span class="line">   <span class="keyword">var</span> name = item.getElementsByClassName('icon-name')[<span class="number">0</span>].innerHTML</span><br><span class="line">   name = camelCase(name, ' ')</span><br><span class="line">   name = camelCase(name, '-')</span><br><span class="line">   <span class="keyword">var</span> code = item.getElementsByClassName('icon-code')[<span class="number">0</span>].innerHTML</span><br><span class="line">   code = code.replace('&amp;amp;#x', '')</span><br><span class="line">   code = code.replace(';', '')</span><br><span class="line">   result = result + <span class="string">"case "</span> + name + <span class="string">" = "</span> + <span class="string">"\"\\u&#123;"</span> + code + <span class="string">"&#125;\""</span> + <span class="string">"\n"</span></span><br><span class="line">&#125;</span><br><span class="line">console.log(result)</span><br></pre></td></tr></table></figure></li></ul><h2 id="EFIconFont"><a href="#EFIconFont" class="headerlink" title="EFIconFont"></a>EFIconFont</h2><p>在 GitHub 上，找到了一个第三方库 EFIconFont ，可以辅助开发在工程中使用 iconfont。<br><a href="https://github.com/XiangWuShuo/EFIconFont" target="_blank" rel="noopener">EFIconFont</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;icon font  &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>图片渲染</title>
    <link href="https://skybrim.top/2019/01/01/ios/image-resizing/"/>
    <id>https://skybrim.top/2019/01/01/ios/image-resizing/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.067Z</updated>
    
    <content type="html"><![CDATA[<p>image resizing</p><a id="more"></a><h2 id="场景-1：一般网络图片渲染-eg-YYWebImage"><a href="#场景-1：一般网络图片渲染-eg-YYWebImage" class="headerlink" title="场景 1：一般网络图片渲染 eg:YYWebImage"></a>场景 1：一般网络图片渲染 eg:YYWebImage</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul><li>从网络下载图片源数据，默认放入内存和磁盘缓存中</li><li>异步解码，解码后的数据放入内存缓存中</li><li>回调主线程渲染图片</li><li>内部维护磁盘和内存的cache，支持设置定时过期清理，内存cache的上限等</li></ul><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><ul><li>从内存中查找图片数据，如果有并且已经解码，直接返回数据，如果没有解码，异步解码缓存内存后返回</li><li>内存中未查找到图片数据，从磁盘查找，磁盘查找到后，加载图片源数据到内存，异步解码缓存内存后返回，如果没有去网络下载图片。走上面的流程。</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>这样滴流程解决了UIImage imageNamed这种加载一定在主线程解码图片的问题，异步加载，避免了主线程阻塞。</li><li>通过缓存内存方式，避开了频繁的磁盘IO</li><li>通过缓存解码后的图片数据，避开了频繁解码的CPU消耗。</li></ul><h2 id="场景-2：超大图片渲染到较小的-view-上"><a href="#场景-2：超大图片渲染到较小的-view-上" class="headerlink" title="场景 2：超大图片渲染到较小的 view 上"></a>场景 2：超大图片渲染到较小的 view 上</h2><p>使用的是 ImageIO 框架的 下采样（downsampling）<br>生成对应图像的缩略图，使得图像符合显示区域的大小<br>如果是网络图片，用 SDWebImage or YYWebImage，选择不解码，直接下载到本地，否则按照通常的网络图片加载策略，几张图片就会导致内存警告，并闪退。  </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downsampleImage</span><span class="params">(at URL:NSURL, maxSize:Float)</span></span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sourceOptions = [kCGImageSourceShouldCache:<span class="literal">false</span>] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">    <span class="keyword">let</span> source = <span class="type">CGImageSourceCreateWithURL</span>(<span class="type">URL</span> <span class="keyword">as</span> <span class="type">CFURL</span>, sourceOptions)!</span><br><span class="line">    <span class="keyword">let</span> downsampleOptions = [kCGImageSourceCreateThumbnailFromImageAlways:<span class="literal">true</span>,</span><br><span class="line">                             kCGImageSourceThumbnailMaxPixelSize:maxSize</span><br><span class="line">                             kCGImageSourceShouldCacheImmediately:<span class="literal">true</span>,</span><br><span class="line">                             kCGImageSourceCreateThumbnailWithTransform:<span class="literal">true</span>,</span><br><span class="line">                             ] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">    <span class="keyword">let</span> downsampledImage = <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(source, <span class="number">0</span>, downsampleOptions)!</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="warning"><a href="#warning" class="headerlink" title="warning"></a>warning</h3><ul><li><p>设置kCGImageSourceShouldCache为false，避免缓存解码后的数据，64位设置上默认是开启缓存的</p></li><li><p>设置kCGImageSourceShouldCacheImmediately为true，避免在需要渲染的时候才做解码，默认选项是false</p></li><li><p>解码&amp;渲染图片，异步加载</p></li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>内存占用小<br>直接使用 UIImage(contentsOfFile: url.path) 加载图片，堆内存的使用是根据图片的像素来的。<br>但是，实际上 iPhone 的屏幕并不能显示那么多像素。<br>通过下采样，可以使图片渲染根据 iPhone 的屏幕分辨率来，即保证了清晰度，又不会过于占用内存。  </p></li><li><p>速度快<br>渲染像素减少，渲染速度快  </p></li><li><p>API 简洁<br>Core Graphics 的 API 较复杂</p></li></ul><h2 id="场景-3：微信、微博长图详情显示"><a href="#场景-3：微信、微博长图详情显示" class="headerlink" title="场景 3：微信、微博长图详情显示"></a>场景 3：微信、微博长图详情显示</h2><p>CATiledLayer。<br>原理是分片渲染，滑动时通过指定目标位置，通过映射原图指定位置的部分图片数据解码渲染<br>如果是网络图片，也要想 场景2 一样，不解码先下载到本地。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;image resizing&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C NSString</title>
    <link href="https://skybrim.top/2019/01/01/ios/objective-c-nsstring/"/>
    <id>https://skybrim.top/2019/01/01/ios/objective-c-nsstring/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.067Z</updated>
    
    <content type="html"><![CDATA[<p>研究了一下 Objective-C 中 NSSting </p><a id="more"></a><ul><li>代码</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __NSCFConstantString</span></span><br><span class="line"><span class="comment">// retainCount (-1,实际是4294967295),</span></span><br><span class="line"><span class="comment">// 无法被释放</span></span><br><span class="line"><span class="comment">// 内存地址相同，低地址，猜测存放在常量区</span></span><br><span class="line"><span class="comment">// 指针地址不同</span></span><br><span class="line"><span class="built_in">NSString</span> *test1 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"123"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *test2 = <span class="string">@"123"</span>;</span><br><span class="line"><span class="keyword">self</span>.testStr = [test2 <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// __NSCFString</span></span><br><span class="line"><span class="comment">// retainCount 1</span></span><br><span class="line"><span class="comment">// 内存地址不同，在 heap 上</span></span><br><span class="line"><span class="comment">// 指针地址不同，指针在 stack</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *test3 = [[<span class="built_in">NSMutableString</span> alloc] initWithString:<span class="string">@"123"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *test4 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"11111111111111111111111111111111123"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSTaggedPointerString</span></span><br><span class="line"><span class="comment">// 内存地址相同，地址就是值，并非真正的对象，是一个伪对象</span></span><br><span class="line"><span class="comment">// 指针地址不同，指针在栈上</span></span><br><span class="line"><span class="built_in">NSString</span> *test5 = [test3 <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSString</span> *test6 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"123"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *test7 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, <span class="string">@"123"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 stringWithFormat 创建的 NSString</span></span><br><span class="line"><span class="comment">// 字符串短，类型是 NSTaggedPointerString， 字符串长，类型是 __NSCFString</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"test1 class:%@ ++ 内存地址：%p ++ 指针地址：%p"</span>,[test1 <span class="keyword">class</span>],test1,&amp;test1);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"test2 class:%@ ++ 内存地址：%p ++ 指针地址：%p"</span>,[test2 <span class="keyword">class</span>],test2,&amp;test2);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"self.testStr class:%@ ++ 内存地址：%p ++ 指针地址：%p"</span>,[<span class="keyword">self</span>.testStr <span class="keyword">class</span>],<span class="keyword">self</span>.testStr,&amp;_testStr);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"\n"</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"test3 class:%@ ++ 内存地址：%p ++ 指针地址：%p"</span>,[test3 <span class="keyword">class</span>],test3,&amp;test3);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"test4 class:%@ ++ 内存地址：%p ++ 指针地址：%p"</span>,[test4 <span class="keyword">class</span>],test4,&amp;test4);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"\n"</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"test5 class:%@ ++ 内存地址：%p ++ 指针地址：%p"</span>,[test5 <span class="keyword">class</span>],test5,&amp;test5);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"test6 class:%@ ++ 内存地址：%p ++ 指针地址：%p"</span>,[test6 <span class="keyword">class</span>],test6,&amp;test6);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"test7 class:%@ ++ 内存地址：%p ++ 指针地址：%p"</span>,[test7 <span class="keyword">class</span>],test7,&amp;test7);</span><br></pre></td></tr></table></figure><ul><li>输出</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test1 <span class="keyword">class</span>:__NSCFConstantString ++ 内存地址：<span class="number">0x100df9668</span> ++ 指针地址：<span class="number">0x7ffeeee194c8</span></span><br><span class="line">test2 <span class="keyword">class</span>:__NSCFConstantString ++ 内存地址：<span class="number">0x100df9668</span> ++ 指针地址：<span class="number">0x7ffeeee194c0</span></span><br><span class="line"><span class="keyword">self</span>.testStr <span class="keyword">class</span>:__NSCFConstantString ++ 内存地址：<span class="number">0x100df9668</span> ++ 指针地址：<span class="number">0x7f8043604978</span></span><br><span class="line"></span><br><span class="line">test3 <span class="keyword">class</span>:__NSCFString ++ 内存地址：<span class="number">0x600001f6fa50</span> ++ 指针地址：<span class="number">0x7ffeeee194b8</span></span><br><span class="line">test4 <span class="keyword">class</span>:__NSCFString ++ 内存地址：<span class="number">0x60000045bd40</span> ++ 指针地址：<span class="number">0x7ffeeee194b0</span></span><br><span class="line"></span><br><span class="line">test5 <span class="keyword">class</span>:<span class="built_in">NSTaggedPointerString</span> ++ 内存地址：<span class="number">0xfad007b675b0e973</span> ++ 指针地址：<span class="number">0x7ffee03e34a8</span></span><br><span class="line">test6 <span class="keyword">class</span>:<span class="built_in">NSTaggedPointerString</span> ++ 内存地址：<span class="number">0xfad007b675b0e973</span> ++ 指针地址：<span class="number">0x7ffee03e34a0</span></span><br><span class="line">test7 <span class="keyword">class</span>:<span class="built_in">NSTaggedPointerString</span> ++ 内存地址：<span class="number">0xfad007b675b0e973</span> ++ 指针地址：<span class="number">0x7ffee03e3498</span></span><br></pre></td></tr></table></figure><ul><li>分析</li></ul><p>test1 的创建 NSString 方式，在编译器中已经完全被字面量的创建方式取代了，编译器会自动帮你。<br>test2 字面量创建 NSString<br>test3 是对 test2 的指针拷贝<br>这三种方式穿件的 NSString，类型都是 __NSCFConstantString，应该是放在常量区，指针存放在 stack<br>内容相同的时候，内存地址也相同  </p><p>test3 NSMutableString 对象<br>test4 stringWithFormat 创建，注意，其内容一定要大于 8 个字节<br>test3&amp;test4，类型是 __NSCFString，是对象，和 OC 中的普通对象基本一致，存储在 heap 中，指针在 stack<br>内存地址不会相同  </p><p>test5 是对 test3 的深拷贝，从 NSMutableString 转变为 NSString<br>test6 和 test7 都是 stringWithFormat 创建的短字符串，小于 8 个字节<br>test5、test6、test7 ，类型都是 NSTaggedPointerString，tagged pointer 实际是一个伪对象，他的地址就是他的值，如下图可以看出，这三个并没有 isa 指针<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/20191014112326.png" alt="isa"></p><p>关于 tagged pointer ，可以看唐巧大佬的文章:<a href="https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/" target="_blank" rel="noopener">深入理解 Tagged Pointer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;研究了一下 Objective-C 中 NSSting &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Popover</title>
    <link href="https://skybrim.top/2019/01/01/ios/popover/"/>
    <id>https://skybrim.top/2019/01/01/ios/popover/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.067Z</updated>
    
    <content type="html"><![CDATA[<p>iOS8 之前，Popover 只能在 iPad 上使用，iPhone 上使用效果类似 present。<br>iOS8 之后需要实现代理方法，取消设备判断，即可在 iPhone 上实现弹窗效果。  </p><a id="more"></a><ul><li>在 iPhone 上使用 Popover</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现 UIPopoverPresentationControllerDelegate 中的以下方法</span></span><br><span class="line"><span class="comment">//取消设备判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adaptivePresentationStyle</span><span class="params">(<span class="keyword">for</span> controller: UIPresentationController)</span></span> -&gt; <span class="type">UIModalPresentationStyle</span> &#123;</span><br><span class="line"><span class="keyword">return</span> .<span class="keyword">none</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置 Popover  </li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> popover = <span class="type">ViewController</span>()</span><br><span class="line"><span class="comment">//设置弹出模式为 popover  </span></span><br><span class="line">popover.modalPresentationStyle = .popover</span><br><span class="line"><span class="comment">//设置size  </span></span><br><span class="line">popover.preferredContentSize = <span class="type">CGSize</span>(width: <span class="number">200</span>, height: <span class="number">400</span>)</span><br><span class="line"><span class="comment">//设置代理  </span></span><br><span class="line">popover.popoverPresentationController?.delegate = <span class="keyword">self</span></span><br><span class="line"><span class="comment">//设置锚点，下面 1 和 2 任选其一  </span></span><br><span class="line"><span class="comment">//1 依附在 barButtonItem  </span></span><br><span class="line">popover.popoverPresentationController?.barButtonItem = <span class="keyword">self</span>.navigationItem.rightBarButtonItem</span><br><span class="line"><span class="comment">//2 依附在 view 上，如 button 等  </span></span><br><span class="line">popover.popoverPresentationController?.sourceView = sender</span><br><span class="line">popover.popoverPresentationController?.sourceRect = sender.bounds</span><br><span class="line"><span class="comment">//设置箭头方向  </span></span><br><span class="line">popover.popoverPresentationController?.permittedArrowDirections = .up</span><br><span class="line"><span class="comment">//设置箭头颜色  </span></span><br><span class="line">popover.popoverPresentationController?.backgroundColor = .red</span><br><span class="line"><span class="comment">//显示  </span></span><br><span class="line"><span class="keyword">self</span>.present(popover, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS8 之前，Popover 只能在 iPad 上使用，iPhone 上使用效果类似 present。&lt;br&gt;iOS8 之后需要实现代理方法，取消设备判断，即可在 iPhone 上实现弹窗效果。  &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 线程、队列与派发</title>
    <link href="https://skybrim.top/2019/01/01/ios/thread-queue-dispatch/"/>
    <id>https://skybrim.top/2019/01/01/ios/thread-queue-dispatch/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.068Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 线程、队列与派发</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>线程(Thread)</p><p>  线程，是操作系统直接支持的执行单元，CPU调度的基本单位，是代码执行的路径；一个进程内至少包含一个线程。</p><p>  线程只拥有程序的少量资源，但是他与进程内的其他线程共享进程的整个内存空间；线程的切换速度远快于进程。</p></li><li><p>队列(Queue)</p><p>  队列是用于保存以及管理任务的，队列根据情况，调度线程来执行其中的任务。</p><p>  队列分为<strong>串行队列</strong>和<strong>并发队列</strong>；队列都是先进先出的。</p><ul><li><p>串行队列(SerialQueue)</p><p>  串行队列，需要等待前一个任务执行完成才能执行下个任务。</p><p>  串行队列只需要一个线程就可以完成任务的派发。</p></li><li><p>并发队列(ConcurrentQueue)</p><p>  并发队列，允许多个任务同时执行；</p><p>  并发队列，任务开始执行的时间是按照顺序的，但是任务结束时间并不确定。</p><p>  并发队列的并发执行，需要通过新建线程来实现</p></li><li><p>主队列</p><p>  主队列，是一种的特殊的串行队列；</p><p>  主队列的任务只能在主线程执行，并且需要等待主线程的 RunLoop 空闲时才能派发。</p></li></ul></li><li><p>派发</p><p>  GCD的派发，分为<strong>同步派发</strong>和<strong>异步派发</strong>。</p><ul><li><p>同步派发(dispatch_sync)</p><p>  同步派发任务，阻塞当前线程，并等待，直到任务执行完返回。</p></li><li><p>异步派发(dispatch_async)</p><p>  异步派发任务，不会阻塞当前线程，也不等待任务返回。</p></li></ul></li></ul><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h3><p><strong>注意，因为主线程是默认环境，所以代码是默认执行在主线程的</strong></p><p>两个线程：<strong>主线程</strong>  <strong>子线程</strong></p><p>三个队里：<strong>主队列</strong>  <strong>串行队列</strong>  <strong>并发队列</strong></p><p>两种派发：<strong>同步派发</strong>  <strong>异步派发</strong></p><p>将上述进行组合，共有 2 x 3 x 2 = 12 种情况</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用方法，输出当前线程</span></span><br><span class="line">- (<span class="keyword">void</span>)printCurrentThread &#123;</span><br><span class="line">    <span class="built_in">NSThread</span> *currentThread = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"cur = %@"</span>, currentThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验-1：在主线程中派发任务"><a href="#实验-1：在主线程中派发任务" class="headerlink" title="实验 1：在主线程中派发任务"></a>实验 1：在主线程中派发任务</h3><ul><li>在 <strong>主线程</strong> 向 <strong>主队列</strong> 执行 <strong>同步派发</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情景 1：</span></span><br><span class="line"><span class="comment">// 在 **主线程** 向 **主队列** 执行 **同步派发**</span></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 程序崩溃</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"--start--"</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</span><br><span class="line"><span class="built_in">dispatch_sync</span>(mainQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task1--start"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task1--end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(mainQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task2--start"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task2--end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"--end--"</span>);</span><br></pre></td></tr></table></figure><ul><li>在 <strong>主线程</strong> 向 <strong>主队列</strong> 执行 <strong>异步派发</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情景 2：</span></span><br><span class="line"><span class="comment">// 在 **主线程** 向 **主队列** 执行 **异步派发**</span></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 14:51:12.     --start--</span></span><br><span class="line"><span class="comment"> 14:51:12.     --end--</span></span><br><span class="line"><span class="comment"> 14:51:12.     task1--start</span></span><br><span class="line"><span class="comment"> 14:51:12.     cur = **NSThread: 0x600000330100**&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment"> 14:51:15.     task1--end</span></span><br><span class="line"><span class="comment"> 14:51:15.     task2--start</span></span><br><span class="line"><span class="comment"> 14:51:15.     cur = **NSThread: 0x600000330100**&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment"> 14:51:15.     task2--end</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"--start--"</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</span><br><span class="line"><span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task1--start"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task1--end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task2--start"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task2--end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"--end--"</span>);</span><br></pre></td></tr></table></figure><ul><li>在 <strong>主线程</strong> 向 <strong>串行队列</strong> 执行 <strong>同步派发</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情景 3：</span></span><br><span class="line"><span class="comment">// 在 **主线程** 向 **串行队列** 执行 **同步派发**</span></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 15:10:51.     --start--</span></span><br><span class="line"><span class="comment"> 15:10:51.     task1--start</span></span><br><span class="line"><span class="comment"> 15:10:51.     cur = **NSThread: 0x600001340300**&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment"> 15:10:54.     task1--end</span></span><br><span class="line"><span class="comment"> 15:10:54.     task2--start</span></span><br><span class="line"><span class="comment"> 15:10:54.     cur = **NSThread: 0x600001340300**&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment"> 15:10:54.     task2--end</span></span><br><span class="line"><span class="comment"> 15:10:54.     --end--</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"--start--"</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"serialQueue"</span>,</span><br><span class="line">                                                   DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task1--start"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task1--end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task2--start"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task2--end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"--end--"</span>);</span><br></pre></td></tr></table></figure><ul><li>在 <strong>主线程</strong> 向 <strong>串行队列</strong> 执行 <strong>异步派发</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情景 4：</span></span><br><span class="line"><span class="comment">// 在 **主线程** 向 **串行队列** 执行 **异步派发**</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 15:13:03.     --start--</span></span><br><span class="line"><span class="comment"> 15:13:03.     --end--</span></span><br><span class="line"><span class="comment"> 15:13:03.     task1--start</span></span><br><span class="line"><span class="comment"> 15:13:03.     cur = **NSThread: 0x6000035ecc80**&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:13:06.     task1--end</span></span><br><span class="line"><span class="comment"> 15:13:06.     task2--start</span></span><br><span class="line"><span class="comment"> 15:13:06.     cur = **NSThread: 0x6000035ecc80**&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:13:06.     task2--end</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"--start--"</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"serialQueue"</span>,</span><br><span class="line">                                                   DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task1--start"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task1--end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task2--start"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task2--end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"--end--"</span>);</span><br></pre></td></tr></table></figure><ul><li>在 <strong>主线程</strong> 向 <strong>并发队列</strong> 执行 <strong>同步派发</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情景 5：</span></span><br><span class="line"><span class="comment">// 在 **主线程** 向 **并发队列** 执行 **同步派发**</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 15:20:01.    --start--</span></span><br><span class="line"><span class="comment"> 15:20:01.    task1--start</span></span><br><span class="line"><span class="comment"> 15:20:01.    cur = **NSThread: 0x60000000c380**&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment"> 15:20:04.    task1--end</span></span><br><span class="line"><span class="comment"> 15:20:04.    task2--start</span></span><br><span class="line"><span class="comment"> 15:20:04.    cur = **NSThread: 0x60000000c380**&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment"> 15:20:04.    task2--end</span></span><br><span class="line"><span class="comment"> 15:20:04.    --end--</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"--start--"</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"concurrentQueue"</span>,</span><br><span class="line">                                                   DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task1--start"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task1--end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task2--start"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task2--end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"--end--"</span>);</span><br></pre></td></tr></table></figure><ul><li>在 <strong>主线程</strong> 向 <strong>并发队列</strong> 执行 <strong>异步派发</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情景 6：</span></span><br><span class="line"><span class="comment">// 在 **主线程** 向 **并发队列** 执行 **异步派发**</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 15:17:35.     --start--</span></span><br><span class="line"><span class="comment"> 15:17:35.     --end--</span></span><br><span class="line"><span class="comment"> 15:17:35.     task1--start</span></span><br><span class="line"><span class="comment"> 15:17:35.     task2--start</span></span><br><span class="line"><span class="comment"> 15:17:35.     cur = **NSThread: 0x6000004d4ec0**&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:17:35.     cur = **NSThread: 0x6000004d83c0**&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:17:35.     task2--end</span></span><br><span class="line"><span class="comment"> 15:17:38.     task1--end</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"--start--"</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"concurrentQueue"</span>,</span><br><span class="line">                                                   DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task1--start"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task1--end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task2--start"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task2--end"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"--end--"</span>);</span><br></pre></td></tr></table></figure><h3 id="实验-2：在子线程派发任务"><a href="#实验-2：在子线程派发任务" class="headerlink" title="实验 2：在子线程派发任务"></a>实验 2：在子线程派发任务</h3><ul><li>在 <strong>其他线程</strong> 向 <strong>主队列</strong> 执行 <strong>同步派发</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情景 7：</span></span><br><span class="line"><span class="comment">// 在 **其他线程** 向 **主队列** 执行 **同步派发**</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 15:34:08    --start--</span></span><br><span class="line"><span class="comment"> 15:34:08    cur = **NSThread: 0x600001019cc0**&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:34:08    task1--start</span></span><br><span class="line"><span class="comment"> 15:34:08    cur = **NSThread: 0x60000105c980**&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment"> 15:34:11    task1--end</span></span><br><span class="line"><span class="comment"> 15:34:11    task2--start</span></span><br><span class="line"><span class="comment"> 15:34:11    cur = **NSThread: 0x60000105c980**&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment"> 15:34:11    task2--end</span></span><br><span class="line"><span class="comment"> 15:34:11    --end--</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--start--"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(mainQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task1--start"</span>);</span><br><span class="line">        [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task1--end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(mainQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task2--start"</span>);</span><br><span class="line">        [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task2--end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--end--"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ul><li>在 <strong>其他线程</strong> 向 <strong>主队列</strong> 执行 <strong>异步派发</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情景 8：</span></span><br><span class="line"><span class="comment">// 在 **其他线程** 向 **主队列** 执行 **异步派发**</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 15:35:34    --start--</span></span><br><span class="line"><span class="comment"> 15:35:34    cur = **NSThread: 0x60000260ba80**&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:35:34    --end--</span></span><br><span class="line"><span class="comment"> 15:35:34    task1--start</span></span><br><span class="line"><span class="comment"> 15:35:34    cur = **NSThread: 0x600002608080**&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment"> 15:35:37    task1--end</span></span><br><span class="line"><span class="comment"> 15:35:37    task2--start</span></span><br><span class="line"><span class="comment"> 15:35:37    cur = **NSThread: 0x600002608080**&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment"> 15:35:37    task2--end</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--start--"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</span><br><span class="line">    <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task1--start"</span>);</span><br><span class="line">        [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task1--end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task2--start"</span>);</span><br><span class="line">        [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task2--end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--end--"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ul><li>在 <strong>其他线程</strong> 向 <strong>串行队列</strong> 执行 <strong>同步派发</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情景 9：</span></span><br><span class="line"><span class="comment">// 在 **其他线程** 向 **串行队列** 执行 **同步派发**</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 15:39:10.    --start--</span></span><br><span class="line"><span class="comment"> 15:39:10.    cur = **NSThread: 0x60000181d840**&#123;number = 8, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:39:10.    task1--start</span></span><br><span class="line"><span class="comment"> 15:39:10.    cur = **NSThread: 0x60000181d840**&#123;number = 8, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:39:13.    task1--end</span></span><br><span class="line"><span class="comment"> 15:39:13.    task2--start</span></span><br><span class="line"><span class="comment"> 15:39:13.    cur = **NSThread: 0x60000181d840**&#123;number = 8, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:39:13.    task2--end</span></span><br><span class="line"><span class="comment"> 15:39:13.    --end--</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--start--"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"serialQueue"</span>,</span><br><span class="line">                                                       DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task1--start"</span>);</span><br><span class="line">        [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task1--end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task2--start"</span>);</span><br><span class="line">        [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task2--end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--end--"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ul><li>在 <strong>其他线程</strong> 向 <strong>串行队列</strong> 执行 <strong>异步派发</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情景 10：</span></span><br><span class="line"><span class="comment">// 在 **其他线程** 向 **串行队列** 执行 **异步派发**</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 15:40:04.    --start--</span></span><br><span class="line"><span class="comment"> 15:40:04.    cur = **NSThread: 0x6000000c8e80**&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:40:04.    --end--</span></span><br><span class="line"><span class="comment"> 15:40:04.    task1--start</span></span><br><span class="line"><span class="comment"> 15:40:04.    cur = **NSThread: 0x6000000ced80**&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:40:07.    task1--end</span></span><br><span class="line"><span class="comment"> 15:40:07.    task2--start</span></span><br><span class="line"><span class="comment"> 15:40:07.    cur = **NSThread: 0x6000000ced80**&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:40:07.    task2--end</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--start--"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"serialQueue"</span>,</span><br><span class="line">                                                       DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task1--start"</span>);</span><br><span class="line">        [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task1--end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task2--start"</span>);</span><br><span class="line">        [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task2--end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--end--"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ul><li>在 <strong>其他线程</strong> 向 <strong>并发队列</strong> 执行 <strong>同步派发</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情景 11：</span></span><br><span class="line"><span class="comment">// 在 **其他线程** 向 **并发队列** 执行 **同步派发**</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 15:41:12.    --start--</span></span><br><span class="line"><span class="comment"> 15:41:12.    cur = **NSThread: 0x600002defb80**&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:41:12.    task1--start</span></span><br><span class="line"><span class="comment"> 15:41:12.    cur = **NSThread: 0x600002defb80**&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:41:15.    task1--end</span></span><br><span class="line"><span class="comment"> 15:41:15.    task2--start</span></span><br><span class="line"><span class="comment"> 15:41:15.    cur = **NSThread: 0x600002defb80**&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:41:15.    task2--end</span></span><br><span class="line"><span class="comment"> 15:41:15.    --end--</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--start--"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"concurrentQueue"</span>,</span><br><span class="line">                                                       DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task1--start"</span>);</span><br><span class="line">        [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task1--end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task2--start"</span>);</span><br><span class="line">        [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task2--end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--end--"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ul><li>在 <strong>其他线程</strong> 向 <strong>并发队列</strong> 执行 <strong>异步派发</strong></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情景 12：</span></span><br><span class="line"><span class="comment">// 在 **其他线程** 向 **并发队列** 执行 **异步派发**</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 15:42:38    --start--</span></span><br><span class="line"><span class="comment"> 15:42:38    cur = **NSThread: 0x6000036f28c0**&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:42:38    --end--</span></span><br><span class="line"><span class="comment"> 15:42:38    task1--start</span></span><br><span class="line"><span class="comment"> 15:42:38    task2--start</span></span><br><span class="line"><span class="comment"> 15:42:38    cur = **NSThread: 0x6000036aac40**&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:42:38    cur = **NSThread: 0x6000036c2840**&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> 15:42:38    task2--end</span></span><br><span class="line"><span class="comment"> 15:42:41    task1--end</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--start--"</span>);</span><br><span class="line">    [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"concurrentQueue"</span>,</span><br><span class="line">                                                       DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task1--start"</span>);</span><br><span class="line">        [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task1--end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task2--start"</span>);</span><br><span class="line">        [<span class="keyword">self</span> printCurrentThread];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"task2--end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--end--"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><ol><li><p>在主线程向主队列同步派发，会造成死锁。</p><p> 同步派发，会阻塞当前线程，该情况即阻塞主线程，然后等待任务返回；此时任务在主队列中，主队列中的任务需要等待主线程来执行；构成死锁。</p></li><li><p>在主线程向主队列异步派发，任务在主线程中按顺序执行。</p></li><li><p>在主线程向串行队列同步派发，任务在主线程中按顺序执行。</p></li><li><p>在主线程向串行队列异步派发，任务在同一个子线程里按顺序执行。</p><p> <strong>在主线程中派发任务，并不代表任务一定在主线程里执行。</strong></p></li><li><p>在主线程向并发队列同步派发，任务在主线程里按顺序执行。</p><p> 第 3、5 条，之所以会在主线程里执行，是因为 apple 进行了性能优化，切换线程是耗性能的。</p></li><li><p>在主线程向并发队列异步派发，任务在不同的子线程里同时执行。</p></li><li><p>在子线程向主队列同步派发，任务在主线程里按顺序执行。</p></li><li><p>在子线程向主队列异步派发，任务在主线程里按顺序执行。</p></li><li><p>在子线程向串行队列同步派发，任务在同一个子线程里按顺序执行。</p></li><li><p>在子线程向串行队列异步派发，任务在同一个子线程里按顺序执行，但是该子线程不是当前子线程。</p></li><li><p>在子线程向并发队列同步派发，任务在同一个子线程里按顺序执行。</p></li><li><p>在子线程向并发队列异步派发，任务在两个不同的子线程里同时执行，并且与当前子线程也不相同。</p></li></ol><h2 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h2><ul><li>主队列的任务都在主线程里执行</li><li>主线程里派发任务，不一定在主线程里执行（4 主线程里向串行队列异步派发，任务在子线程里执行）</li><li>同步派发的特征是塞当前线程，而不是让任务在当前线程立即执行（5 子线程向主队列同步派发，任务在主线程里执行）</li><li>串行队列异步派发，任务会在一个新子线程中执行（4 10 主线程/子线程向串行队列异步派发）</li><li>串行队列同步派发，任务会在当前线程中执行（3 9 主线程/子线程向串行队列同步派发）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 线程、队列与派发&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UIFont</title>
    <link href="https://skybrim.top/2019/01/01/ios/uifont/"/>
    <id>https://skybrim.top/2019/01/01/ios/uifont/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.068Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 系统中，用户可以通过 设置-&gt;显示与亮度-&gt;文字大小 来调节系统字号的大小。<br>此时，我们也需要跟进适配。</p><a id="more"></a><h2 id="固定字号"><a href="#固定字号" class="headerlink" title="固定字号"></a>固定字号</h2><p>字号不会跟随系统改变，适合一些复杂的 UI 效果，防止因为字号改变，而产生 UI 错乱的 BUG。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自定字号，字体跟随系统</span><br><span class="line">func systemFont(ofSize: CGFloat) -&gt; UIFont</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自定字号，自定字体</span><br><span class="line">init?(name fontName: String, size fontSize: CGFloat)</span><br></pre></td></tr></table></figure><h2 id="Dynamic-Type"><a href="#Dynamic-Type" class="headerlink" title="Dynamic Type"></a>Dynamic Type</h2><p>使用 Dynamic Type 字号可以跟随系统设置改变，但是不支持自定义字体，只能使用系统字体。<br>支持 iOS7 及以上 </p><p>//iOS10 以下，需要监控通知消息来进行更改 UIContentSizeCategoryDidChangeNotification   </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在通知方法中，更新 font </span></span><br><span class="line">label.font = [<span class="built_in">UIFont</span> preferredFontForTextStyle:<span class="built_in">UIFontTextStyleBody</span>];</span><br><span class="line"><span class="comment">// 注意这里需要调用setNeedsLayout然后在layoutSubview或者viewDidLayoutSubview里面更新label的frame</span></span><br><span class="line">[<span class="keyword">self</span>.view setNeedsLayout];</span><br></pre></td></tr></table></figure><p>iOS10 及以上可以直接设置</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label.adjustsFontContentSizeCategory = <span class="literal">true</span></span><br><span class="line">label.font = <span class="type">UIFont</span>.preferredFont(forTextStyle: .<span class="type">Title1</span>)</span><br></pre></td></tr></table></figure><p>下面是系统支持的相关字号<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/font.png" alt=""></p><h2 id="UIFontMetrics"><a href="#UIFontMetrics" class="headerlink" title="UIFontMetrics"></a>UIFontMetrics</h2><p>iOS11，apple 加入了 UIFontMetrics ，终于可以支持自定义字体了。  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">label.adjustsFontForContentSizeCategory = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">20</span>)</span><br><span class="line">label.font = <span class="type">UIFontMetrics</span>.<span class="keyword">default</span>.scaledFont(<span class="keyword">for</span>: font)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 系统中，用户可以通过 设置-&amp;gt;显示与亮度-&amp;gt;文字大小 来调节系统字号的大小。&lt;br&gt;此时，我们也需要跟进适配。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UIViewPropertyAnimator</title>
    <link href="https://skybrim.top/2019/01/01/ios/uiviewpropertyanimator/"/>
    <id>https://skybrim.top/2019/01/01/ios/uiviewpropertyanimator/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.068Z</updated>
    
    <content type="html"><![CDATA[<p>UIViewPropertyAnimator</p><a id="more"></a><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><a href="https://github.com/skybrim/iOS_practice/tree/master/Animation" target="_blank" rel="noopener">demo</a></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>先说一下对别的结论，然后列出代码。  </p><ul><li>优点：  <ul><li>1、精细控制动画状态 start pase stop finish  </li><li>2、精细控制动画进度 fractionComplete  </li><li>3、可以中间加入动画 addAnimations  </li><li>4、自定义 curve  </li></ul></li><li>缺点：  <ul><li>1、无法重复动画: .repeat 无效（-iOS12）  </li><li>2、无法自动翻转动画： .autoreverse 无效（-iOS12）  </li></ul></li></ul><h2 id="UIView-animationDuration-…"><a href="#UIView-animationDuration-…" class="headerlink" title="UIView.animationDuration:…"></a>UIView.animationDuration:…</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIView</span>.animate(</span><br><span class="line">    withDuration: <span class="number">3</span>,</span><br><span class="line">    delay: <span class="number">0</span>,</span><br><span class="line">    options: [.curveLinear], <span class="comment">// [.repeat, .autoreverse]</span></span><br><span class="line">    animations: &#123;</span><br><span class="line">        <span class="comment">// code...</span></span><br><span class="line">&#125;) &#123; (<span class="number">_</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"UIView.animate -- completion"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UIViewPropertyAnimator"><a href="#UIViewPropertyAnimator" class="headerlink" title="UIViewPropertyAnimator"></a>UIViewPropertyAnimator</h2><p>iOS 10 以后 Apple 新加入的动画 API，主要用来取代 UIView.animationWithDuration:…</p><ul><li><p>类似 [UIView animationWithDuration:…] 的使用形式<br>UIViewPropertyAnimator 也可以按照旧式的 UIView.animationWithDuration:… 的形式调用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIViewPropertyAnimator</span>.runningPropertyAnimator(</span><br><span class="line">    withDuration: &lt;#<span class="type">T</span>##<span class="type">TimeInterval</span>#&gt;,</span><br><span class="line">    delay: &lt;#<span class="type">T</span>##<span class="type">TimeInterval</span>#&gt;,</span><br><span class="line">    options: &lt;#<span class="type">T</span>##<span class="type">UIView</span>.<span class="type">AnimationOptions</span>#&gt;,</span><br><span class="line">    animations: &lt;#<span class="type">T</span>##() -&gt; <span class="type">Void</span>#&gt;,</span><br><span class="line">    completion: &lt;#<span class="type">T</span>##((<span class="type">UIViewAnimatingPosition</span>) -&gt; <span class="type">Void</span>)?##((<span class="type">UIViewAnimatingPosition</span>) -&gt; <span class="type">Void</span>)?##(<span class="type">UIViewAnimatingPosition</span>) -&gt; <span class="type">Void</span>#&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>创建对象<br>Apple 提供了三种快速创建的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 duration 、 cureve 和 animation， 创建 UIViewPropertyAnimator</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(duration: <span class="type">TimeInterval</span>, curve: <span class="type">UIView</span>.<span class="type">AnimationCurve</span>, animations: (() -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 通过设置首尾两个点创建动画曲线，创建 UIViewPropertyAnimator</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(duration: <span class="type">TimeInterval</span>, controlPoint1 point1: <span class="type">CGPoint</span>, controlPoint2 point2: <span class="type">CGPoint</span>, animations: (() -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//设置 dampingRatio（阻尼率），创建 UIViewPropertyAnimator</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(duration: <span class="type">TimeInterval</span>, dampingRatio ratio: <span class="type">CGFloat</span>, animations: (() -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>)</span><br><span class="line">```  </span><br><span class="line">如果还是未能满足，可以通过自定义创建动画曲线。</span><br><span class="line">```<span class="type">Swift</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(duration: <span class="type">TimeInterval</span>, timingParameters parameters: <span class="type">UITimingCurveProvider</span>)</span><br></pre></td></tr></table></figure></li><li><p>动画状态</p><ul><li><p>Inactive<br>对象初始化或者动画结束后所处的状态。</p></li><li><p>Active<br>在调用 startAnimation() 、 pauseAnimation() 方法后对象就处于激活状态，直到动画完成或者手动调用 stopAnimation() 结束动画。</p></li><li><p>Stopped<br>在 stopAnimation() 被调用之后动画对象就处于停止状态，并且保留当前的所有属性值。如下图所示，停止状态无法反向回到激活态。</p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/UIVIewPropertyAnimator-state.png" alt=""></p></li></ul></li><li><p>添加新动画<br>UIViewPropertyAnimator 可以在中途加入新的动画。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The duration of the animation will be (1 - delayFactor) * animator.duration seconds.</span></span><br><span class="line"><span class="comment">//delayFactor，不是动画开始执行的绝对值，因为新动画加入时，animator 可能已经运行一段时间了</span></span><br><span class="line"><span class="comment">//默认为 0</span></span><br><span class="line">    animator.addAnimations(&#123;</span><br><span class="line">    <span class="comment">//code...</span></span><br><span class="line">    &#125;, delayFactor: <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>动画结束</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UIViewAnimatingPosition，用于表明动画结束的位置，这个值本身是一个枚举，包含了 starting、end 和 current。通常得到的值是 end。</span></span><br><span class="line">    animator.addCompletion &#123; (<span class="type">UIViewAnimatingPosition</span>) <span class="keyword">in</span></span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>控制动画进度<br>注意，只能在动画处于 inactive 和 active 的时候，可以控制。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">changeAnimator</span><span class="params">(<span class="number">_</span> sender: UISlider)</span></span> &#123;</span><br><span class="line">    animator.fractionComplete = <span class="type">CGFloat</span>(sender.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UIViewPropertyAnimator&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Project V</title>
    <link href="https://skybrim.top/2018/12/12/inbox/v2ray/"/>
    <id>https://skybrim.top/2018/12/12/inbox/v2ray/</id>
    <published>2018-12-11T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.065Z</updated>
    
    <content type="html"><![CDATA[<p>Project V </p><a id="more"></a><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>TCP + TLS 分流器</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><p>根据个人需求，找一些适合自己的VPS服务商。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ul><li><p>Debian 10</p></li><li><p>自行设置 ssh 相关，或者直接使用服务商的后台</p></li></ul><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>根据自身条件，购买一个域名（国内需备案），并在域名商后台添加一个 A 记录指向自己的 vps 地址，dns 服务可能需要一点时间才能生效</p><p>下文使用 domain.me 替代</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ul><li>MacOS系统</li></ul><p>MacOS中，直接打开终端（Terminal），输入命令 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@xxx.xxx.x.x</span><br></pre></td></tr></table></figure><ul><li>Windows系统</li></ul><p>使用一些SSH工具即可。如：Putty。</p><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>中间有一些需要使用 vim 编辑，简单说几个命令</p><p>i 进入编辑模式</p><p>esc 进入普通模式 </p><p>:wq 编辑好后，在普通模式下，保存退出</p><h3 id="v2ray"><a href="#v2ray" class="headerlink" title="v2ray"></a>v2ray</h3><ul><li>执行安装脚本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/20190314154947.png" alt="4"></p><ul><li>配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/v2ray/config.json</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"inbounds"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">            <span class="attr">"listen"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">40001</span>, <span class="comment">/* 自定，记得删除注释*/</span></span><br><span class="line">            <span class="attr">"settings"</span>: &#123;</span><br><span class="line">                <span class="attr">"clients"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"id"</span>: <span class="string">"f2435e5c-9ad9-4367-836a-8341117d0a5f"</span> <span class="comment">/* 自定，记得删除注释*/</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"streamSettings"</span>: &#123;</span><br><span class="line">                <span class="attr">"network"</span>: <span class="string">"tcp"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"outbounds"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"protocol"</span>: <span class="string">"freedom"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TLS-分流器"><a href="#TLS-分流器" class="headerlink" title="TLS 分流器"></a>TLS 分流器</h3><ul><li>安装脚本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://raw.githubusercontent.com/liberal-boy/tls-shunt-proxy/master/dist/install.sh)</span><br></pre></td></tr></table></figure><ul><li>配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/tls-shunt-proxy/config.yaml</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">listen: 0.0.0.0:443</span><br><span class="line">vhosts:</span><br><span class="line"></span><br><span class="line"># 将 domain.me 改为你的域名</span><br><span class="line">- name: domain.me</span><br><span class="line">    tlsoffloading: true</span><br><span class="line">    managedcert: true</span><br><span class="line">    alpn: h2,http&#x2F;1.1</span><br><span class="line">    </span><br><span class="line">    # 如果不需要兼容 tls12, 可改为 tls13</span><br><span class="line">    protocols: tls12,tls13</span><br><span class="line">    http:</span><br><span class="line">    handler: fileServer</span><br><span class="line"></span><br><span class="line">    # &#x2F;var&#x2F;www&#x2F;html 是静态网站目录</span><br><span class="line">    args: &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">    default:</span><br><span class="line">    handler: proxyPass</span><br><span class="line">    args: 127.0.0.1:40001</span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart tls-shunt-proxy</span><br><span class="line">systemctl restart v2ray</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"inbounds"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">1080</span>,</span><br><span class="line">            <span class="attr">"listen"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="attr">"protocol"</span>: <span class="string">"socks"</span>,</span><br><span class="line">            <span class="attr">"sniffing"</span>: &#123;</span><br><span class="line">                <span class="attr">"enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">"destOverride"</span>: [<span class="string">"http"</span>, <span class="string">"tls"</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"settings"</span>: &#123;</span><br><span class="line">                <span class="attr">"auth"</span>: <span class="string">"noauth"</span>  <span class="comment">//socks的认证设置，noauth 代表不认证，由于 socks 通常在客户端使用，所以这里不认证</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"outbounds"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">            <span class="attr">"settings"</span>: &#123;</span><br><span class="line">                <span class="attr">"vnext"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"address"</span>: <span class="string">"domain.me"</span>,</span><br><span class="line">                        <span class="attr">"port"</span>: <span class="number">443</span>,</span><br><span class="line">                        <span class="attr">"users"</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"id"</span>: <span class="string">"f2435e5c-9ad9-4367-836a-8341117d0a5f"</span>,</span><br><span class="line">                                <span class="attr">"security"</span>: <span class="string">"none"</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"streamSettings"</span>: &#123;</span><br><span class="line">                <span class="attr">"network"</span>: <span class="string">"tcp"</span>,</span><br><span class="line">                <span class="attr">"security"</span>: <span class="string">"tls"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GUI-客户端"><a href="#GUI-客户端" class="headerlink" title="GUI 客户端"></a>GUI 客户端</h3><ul><li><p>iOS</p><p>  国区并未上线，去别的区购买，关键词 Gift Card。</p><ul><li><p>Kitsunebi</p></li><li><p>i2Ray</p></li><li><p>Shadowrocket</p></li></ul></li><li><p>Android</p><ul><li><p><a href="https://apkpure.com/bifrostv/com.github.dawndiy.bifrostv" target="_blank" rel="noopener">BifrostV</a></p></li><li><p><a href="https://github.com/2dust/v2rayNG" target="_blank" rel="noopener">V2RayNG</a></p></li></ul></li><li><p>Windows</p><ul><li><p><a href="https://github.com/2dust/v2rayN/releases" target="_blank" rel="noopener">V2RayN</a></p></li><li><p><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">shadowsocks-windows</a></p></li></ul></li><li><p>MacOS</p><ul><li><a href="https://github.com/Cenmrev/V2RayX/releases" target="_blank" rel="noopener">V2RayX</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Project V &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="inbox" scheme="https://skybrim.top/tags/inbox/"/>
    
      <category term="proxy" scheme="https://skybrim.top/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>VIM 基本命令备忘</title>
    <link href="https://skybrim.top/2018/12/12/inbox/vim-command/"/>
    <id>https://skybrim.top/2018/12/12/inbox/vim-command/</id>
    <published>2018-12-11T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.065Z</updated>
    
    <content type="html"><![CDATA[<p>vim command</p><a id="more"></a><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:wq <span class="comment">#保存并退出</span></span><br><span class="line">:q  <span class="comment">#退出</span></span><br><span class="line">:q! <span class="comment">#放弃修改强制退出</span></span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i <span class="comment">#当前位置插入</span></span><br><span class="line">a <span class="comment">#当前位置后插入</span></span><br><span class="line">o <span class="comment">#在当前行下面插入新的一行</span></span><br><span class="line">I <span class="comment">#在当前行行首插入 </span></span><br><span class="line">A <span class="comment">#在当前行行尾插入</span></span><br><span class="line">O <span class="comment">#在当前行上面插入新的一行</span></span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:vs <span class="comment">#竖分屏 vertical split</span></span><br><span class="line">:sp <span class="comment">#横分屏 split</span></span><br><span class="line">:% s/from/to/g <span class="comment">#全局替换</span></span><br><span class="line">v <span class="comment">#可视化选择，选中当前位置</span></span><br><span class="line">V <span class="comment">#选中当前行</span></span><br><span class="line">control+v <span class="comment">#块状选择</span></span><br></pre></td></tr></table></figure><h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><ul><li>删除</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入模式下</span></span><br><span class="line">ctrl+h <span class="comment">#删除一个字符</span></span><br><span class="line">ctrl+w <span class="comment">#删除一个单词</span></span><br><span class="line">ctrl+u <span class="comment">#删除一个行</span></span><br></pre></td></tr></table></figure><ul><li>切换模式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctrl+c <span class="comment">#回到命令模式，可能会中断一些插件</span></span><br><span class="line">ctrl+[ <span class="comment">#回到命令模式</span></span><br><span class="line">gi <span class="comment">#快速回到最后一次进入编辑位置，并进入插入模式</span></span><br></pre></td></tr></table></figure><h2 id="快速移动"><a href="#快速移动" class="headerlink" title="快速移动"></a>快速移动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hjkl</span><br><span class="line">w/W <span class="comment">#移动到下一个 word/WORD 开头</span></span><br><span class="line">e/E <span class="comment">#移动到下一个 word/WORD 尾部</span></span><br><span class="line">b/B <span class="comment">#移动到上一个 word/WORD 开头</span></span><br><span class="line"><span class="comment"># WORD 指用空格分隔的单词</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f+(char) <span class="comment">#快速向后跳转到指定字符</span></span><br><span class="line">F+(char) <span class="comment">#快速先前跳转到指定字符</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 <span class="comment">#移动到行首</span></span><br><span class="line">$ <span class="comment">#移动到行尾</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">() <span class="comment">#句子之间移动</span></span><br><span class="line">[] <span class="comment">#段落之间移动</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gg <span class="comment">#文件开头</span></span><br><span class="line">G  <span class="comment">#文件的结尾</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctrl+u <span class="comment">#向上翻页</span></span><br><span class="line">ctrl+d <span class="comment">#向后翻页</span></span><br><span class="line">zz     <span class="comment">#把当前行放到中间</span></span><br></pre></td></tr></table></figure><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><ul><li>增</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a/i/o/A/I/O</span><br></pre></td></tr></table></figure><ul><li>删</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入模式 </span></span><br><span class="line">backspace </span><br><span class="line">ctrl+h</span><br><span class="line"><span class="comment"># normal模式</span></span><br><span class="line">x     <span class="comment">#向后删除一个字符，数字+命令</span></span><br><span class="line">X<span class="comment">#向前删除一个字符</span></span><br><span class="line">dd<span class="comment">#删除一行，数字+命令</span></span><br><span class="line">d0<span class="comment">#删除到行首</span></span><br><span class="line">d$<span class="comment">#删除到行尾</span></span><br><span class="line">d+(数字)+d  <span class="comment">#删除指定数的行</span></span><br><span class="line">dt+(char)   <span class="comment">#删除到指定字符</span></span><br><span class="line">daw     <span class="comment">#删除单词以及周围空格</span></span><br><span class="line">diw    <span class="comment">#删除单词，不删除空格</span></span><br><span class="line">world worldw world world</span><br></pre></td></tr></table></figure><ul><li>修改</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r(replace)   <span class="comment">#替换一个字符</span></span><br><span class="line">R <span class="comment">#向后连续替换字符</span></span><br><span class="line">s(subsitute) <span class="comment">#删除一个字符，并进入插入模式</span></span><br><span class="line">S <span class="comment">#删除整行，进入插入模式</span></span><br><span class="line">c(change)    <span class="comment">#ct+(char)删除到指定字符，并进入插入模式</span></span><br><span class="line">cw <span class="comment">#删除一个单词，并进入插入模式</span></span><br><span class="line">C <span class="comment">#和 S 一样</span></span><br></pre></td></tr></table></figure><ul><li>查</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/+内容  <span class="comment">#向后搜索匹配</span></span><br><span class="line">?+内容  <span class="comment">#向前搜索匹配</span></span><br><span class="line">n       <span class="comment">#下一个</span></span><br><span class="line">N<span class="comment">#上一个</span></span><br></pre></td></tr></table></figure><h2 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换"></a>搜索替换</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:[range]s[ubstitute]/&#123;pattern&#125;/&#123;string&#125;/[flags]</span><br><span class="line"><span class="comment"># range 范围，:10,20 表示 10-20 行；% 表示全部</span></span><br><span class="line"><span class="comment"># pattern 替换的文本</span></span><br><span class="line"><span class="comment"># string 替换后的文本</span></span><br><span class="line"><span class="comment"># flags 替换标志. g 全局；c 确认；n 报告匹配到的次数，不替换。</span></span><br><span class="line"><span class="comment"># 支持正则表达式</span></span><br><span class="line"></span><br><span class="line">:% s/abc/def/g</span><br><span class="line">:10,20 s/def/abc/g</span><br></pre></td></tr></table></figure><h2 id="多文件操作"><a href="#多文件操作" class="headerlink" title="多文件操作"></a>多文件操作</h2><ul><li>Buffer</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:ls   <span class="comment">#vim中列出所有 buffer</span></span><br><span class="line">:e+(FileName)    <span class="comment">#打开文件 </span></span><br><span class="line">:b+(FileName)/(number) <span class="comment">#跳转buffer</span></span><br></pre></td></tr></table></figure><ul><li>window</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+s / :sp    <span class="comment">#水平分隔窗口</span></span><br><span class="line">ctrl+w+v / :vs  <span class="comment">#竖直分隔窗口</span></span><br><span class="line">ctrl+w+w/h/j/k/l  <span class="comment">#跳转窗口</span></span><br><span class="line">ctrl+w+H/J/K/L    <span class="comment">#移动窗口</span></span><br><span class="line">ctrl+w+q/c  <span class="comment">#关闭窗口</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">## Text Object</span></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">[number]&lt;<span class="built_in">command</span>&gt;[text object]</span><br><span class="line"><span class="comment"># number 次数</span></span><br><span class="line"><span class="comment"># command 命令，d(elete),c(hange),y(ank),v(isual)</span></span><br><span class="line"><span class="comment"># text object，文本对象，w 单词，s 句子，p 段落</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eg</span></span><br><span class="line">c+i+(</span><br><span class="line">v+a+<span class="string">"</span></span><br><span class="line"><span class="string"># i表示 inner，内部</span></span><br><span class="line"><span class="string">ci( #删除小括号内容，不含小括号，并进入插入模式)</span></span><br><span class="line"><span class="string">vi"</span> <span class="comment">#选中引号内容</span></span><br><span class="line">diw <span class="comment">#删除单词</span></span><br><span class="line"><span class="comment"># a表示 around，包围</span></span><br><span class="line">ca( <span class="comment">#选中小括号及括号内的内容</span></span><br></pre></td></tr></table></figure><h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><ul><li>normal</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y    <span class="comment">#复制</span></span><br><span class="line">p    <span class="comment">#粘贴</span></span><br><span class="line">d    <span class="comment">#剪切</span></span><br><span class="line">yy   <span class="comment">#复制一行</span></span><br></pre></td></tr></table></figure><ul><li>insert</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制到系统剪切板</span></span><br><span class="line"><span class="string">"+y</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string"># 粘贴系统剪切板内容</span></span><br><span class="line"><span class="string">"</span>+p</span><br></pre></td></tr></table></figure><h2 id="macro"><a href="#macro" class="headerlink" title="macro"></a>macro</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">q + 寄存器名字 <span class="comment"># 开始录制</span></span><br><span class="line">执行操作</span><br><span class="line">q              <span class="comment"># 退出录制</span></span><br><span class="line">@ + 寄存器名称 <span class="comment"># 使用宏</span></span><br><span class="line">v              <span class="comment"># 选中需要修改的地方</span></span><br><span class="line">:normal @+寄存器名  <span class="comment"># 批量操作</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 批量操作</span></span><br><span class="line">v/V <span class="comment">#选中需要批量的内容</span></span><br><span class="line">:normal + 操作  <span class="comment">#执行操作</span></span><br></pre></td></tr></table></figure><h2 id="补全"><a href="#补全" class="headerlink" title="补全"></a>补全</h2><p>单词补全<br>ctrl + n/p</p><p>文件路径补全<br>ctrl + x + f</p><p>上下选择<br>ctrl + n/p</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vim command&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="inbox" scheme="https://skybrim.top/tags/inbox/"/>
    
      <category term="vim" scheme="https://skybrim.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>VIM Plugin</title>
    <link href="https://skybrim.top/2018/12/12/inbox/vim-plugin/"/>
    <id>https://skybrim.top/2018/12/12/inbox/vim-plugin/</id>
    <published>2018-12-11T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.065Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些 vim 的插件，安装和使用在 github 上查找</p><a id="more"></a><h2 id="美化插件"><a href="#美化插件" class="headerlink" title="美化插件"></a>美化插件</h2><ul><li><p>startify<br>启动界面</p></li><li><p>vim-airline<br>vim 底部添加状态栏</p></li><li><p>indentline<br>显示缩进线</p></li><li><p>vim-hybrid<br>配色方案 1</p></li><li><p>solarized<br>配色方案 2</p></li><li><p>gruvbox<br>配色方案 3</p></li></ul><h2 id="文件、文件目录、文件搜索"><a href="#文件、文件目录、文件搜索" class="headerlink" title="文件、文件目录、文件搜索"></a>文件、文件目录、文件搜索</h2><ul><li><p>nerdtree<br>文件目录树管理</p></li><li><p>ctrlp<br>快速搜索文件，被 fzf.vim 替换</p></li></ul><h2 id="快速定位"><a href="#快速定位" class="headerlink" title="快速定位"></a>快速定位</h2><ul><li>easymotion<br>快速移动</li></ul><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><ul><li><p>vim-surround<br>成对编辑双引号、双括号等</p></li><li><p>fzf 与 fzf.vim<br>模糊搜索</p></li><li><p>far.vim<br>多文件批量查询与替换</p></li></ul><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><ul><li><p>vim-go<br>vim 编写 golang 的辅助插件<br>vim-go-tutorial 文档</p></li><li><p>python-mode<br>vim 编写 python 的辅助插件 </p></li><li><p>tagbar<br>阅读代码，代码大纲</p></li><li><p>vim-interestingwords<br>高亮你感兴趣的单词</p></li><li><p>deoplete.vim<br>代码补全，支持异步补全<br>可以通过安装不同语言模块来扩展</p></li><li><p>coc.vim<br>异步补全，支持 LSP  </p></li><li><p>Neoformat<br>格式化代码</p></li><li><p>vim-autoformat<br>格式化代码</p></li><li><p>neomake<br>静态检查  </p></li><li><p>ale<br>静态检查  </p></li><li><p>vim-commentary<br>快速注释与解注释</p></li><li><p>Fugitive<br>vim 里使用 git</p></li><li><p>vim-gitgutter<br>显示文件的变更</p></li><li><p>gv.vim<br>查看提交记录</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些 vim 的插件，安装和使用在 github 上查找&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="inbox" scheme="https://skybrim.top/tags/inbox/"/>
    
      <category term="vim" scheme="https://skybrim.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>学习VIM</title>
    <link href="https://skybrim.top/2018/12/12/inbox/vim/"/>
    <id>https://skybrim.top/2018/12/12/inbox/vim/</id>
    <published>2018-12-11T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.065Z</updated>
    
    <content type="html"><![CDATA[<p>vim</p><a id="more"></a><h2 id="安装-VIM"><a href="#安装-VIM" class="headerlink" title="安装 VIM"></a>安装 VIM</h2><ul><li>Homebrew 安装</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install <span class="keyword">vim</span></span><br></pre></td></tr></table></figure><ul><li>替换系统 VIM</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">"我使用的是zsh</span></span><br><span class="line"><span class="keyword">vim</span> ~/.zshrc</span><br><span class="line"><span class="comment">"在最后写上</span></span><br><span class="line">export PATH=/usr/local/Cellar/<span class="keyword">vim</span>/<span class="number">8.1</span>.<span class="number">1500</span>:$PATH</span><br></pre></td></tr></table></figure><h2 id="VIM-Tutor-1-7"><a href="#VIM-Tutor-1-7" class="headerlink" title="VIM Tutor 1.7"></a>VIM Tutor 1.7</h2><p>终端输入 vimtutor ，进入教程。<br>下面是中文翻译。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br></pre></td><td class="code"><pre><span class="line">===============================================================================</span><br><span class="line">=      欢     迎     阅     读   《 V I M  教  程 》   ——      版本 <span class="number">1.7</span>       =</span><br><span class="line">===============================================================================</span><br><span class="line"></span><br><span class="line">     Vim 是一个具有很多命令的功能非常强大的编辑器。限于篇幅，在本教程当中</span><br><span class="line">     就不详细介绍了。本教程的设计目标是讲述一些必要的基本命令，而掌握好这</span><br><span class="line">     些命令，您就能够很容易地将 Vim 当作一个通用编辑器来使用了。</span><br><span class="line"></span><br><span class="line">     完成本教程的内容大约需要<span class="number">25</span>-<span class="number">30</span>分钟，取决于您训练的时间。</span><br><span class="line"></span><br><span class="line">     注意：</span><br><span class="line">     每一节的命令操作将会更改本文。推荐您复制本文的一个副本，然后在副本上</span><br><span class="line">     进行训练(如果您是通过<span class="string">"vimtutor"</span>来启动教程的，那么本文就已经是副本了)。</span><br><span class="line"></span><br><span class="line">     切记一点：本教程的设计思路是在使用中进行学习的。也就是说，您需要通过</span><br><span class="line">     执行命令来学习它们本身的正确用法。如果您只是阅读而不操作，那么您可能</span><br><span class="line">     会很快遗忘这些命令的！</span><br><span class="line"></span><br><span class="line">     好了，现在请确定您的Shift-Lock(大小写锁定键)还没有按下，然后按键盘上</span><br><span class="line">     的字母键 <span class="keyword">j</span> 足够多次来移动光标，直到第一节的内容能够完全充满屏幕。</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">第一讲第一节：移动光标</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     ** 要移动光标，请依照说明分别按下 h、<span class="keyword">j</span>、<span class="keyword">k</span>、<span class="keyword">l</span> 键。 **</span><br><span class="line"></span><br><span class="line">     ^</span><br><span class="line">     <span class="keyword">k</span>    提示： h 的键位于左边，每次按下就会向左移动。</span><br><span class="line">       &lt; h <span class="keyword">l</span> &gt;   <span class="keyword">l</span> 的键位于右边，每次按下就会向右移动。</span><br><span class="line">     <span class="keyword">j</span>   <span class="keyword">j</span> 键看起来很象一支尖端方向朝下的箭头。</span><br><span class="line">     v</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 请随意在屏幕内移动光标，直至您觉得舒服为止。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 按下下行键(<span class="keyword">j</span>)，直到出现光标重复下行。</span><br><span class="line"></span><br><span class="line">---&gt; 现在您应该已经学会如何移动到下一讲吧。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 现在请使用下行键，将光标移动到第一讲第二节。</span><br><span class="line"></span><br><span class="line">提示：如果您不敢确定您所按下的字母，请按下<span class="symbol">&lt;ESC&gt;</span>键回到正常(Normal)模式。</span><br><span class="line">      然后再次从键盘输入您想要的命令。</span><br><span class="line"></span><br><span class="line">提示：光标键应当也能正常工作的。但是使用hjkl键，在习惯之后您就能够更快</span><br><span class="line">      地在屏幕内四处移动光标。真的是这样！</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">第一讲第二节：VIM的进入和退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  !! 特别提示：敬请阅读本一节的完整内容，然后再执行以下所讲解的命令。</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 按<span class="symbol">&lt;ESC&gt;</span>键(这是为了确保您处在正常模式)。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 然后输入：:q! &lt;回车&gt;</span><br><span class="line">     这种方式的退出编辑器会丢弃您进入编辑器以来所做的改动。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 如果您看到了命令行提示符，请输入能够带您回到本教程的命令，那就是：</span><br><span class="line">     vimtutor &lt;回车&gt;</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 如果您自信已经牢牢记住了这些步骤的话，请从步骤<span class="number">1</span>执行到步骤<span class="number">3</span>退出，然</span><br><span class="line">     后再次进入编辑器。</span><br><span class="line"></span><br><span class="line">提示： :q! &lt;回车&gt; 会丢弃您所做的任何改动。几讲之后您将学会如何保存改动到文件。</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. 将光标下移到第一讲第三节。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">第一讲第三节：文本编辑之删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ** 在正常(Normal)模式下，可以按下 <span class="keyword">x</span> 键来删除光标所在位置的字符。**</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 为了修正输入错误，请将光标移至准备删除的字符的位置处。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 然后按下 <span class="keyword">x</span> 键将错误字符删除掉。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 重复步骤<span class="number">2</span>到步骤<span class="number">4</span>，直到句子修正为止。</span><br><span class="line"></span><br><span class="line">---&gt; The ccow jumpedd ovverr thhe mooon.</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. 好了，该行已经修正了，下面是第一讲第四节。</span><br><span class="line"></span><br><span class="line">特别提示：在浏览本教程时，不要强行记忆。记住一点：在使用中学习。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">     第一讲第四节：文本编辑之插入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ** 在正常模式下，可以按下 i 键来插入文本。**</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 为了使得第一行内容雷同于第二行，请将光标移至文本第一个准备插入字符</span><br><span class="line">     的位置。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 然后按下 i 键，接着输入必要的文本字符。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 每个错误修正完毕后，请按下 <span class="symbol">&lt;ESC&gt;</span> 键返回正常模式。</span><br><span class="line">     重复步骤<span class="number">2</span>至步骤<span class="number">4</span>以便修正句子。</span><br><span class="line"></span><br><span class="line">---&gt; There <span class="keyword">is</span> text misng this .</span><br><span class="line">---&gt; There <span class="keyword">is</span> some text missing from this <span class="built_in">line</span>.</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. 如果您对文本插入操作已经很满意，请接着阅读下面的第一讲第五节。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">     第一讲第五节：文本编辑之添加</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">** 按 A 键以添加文本。 **</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 移动光标到下面第一个标记有 ---&gt; 的一行。</span><br><span class="line">     光标放在那一行的哪个字符上并不重要。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 按 A 键输入必要的添加内容。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 文本添加完毕后，按 <span class="symbol">&lt;ESC&gt;</span> 键回到正常模式。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 移动光标到下面第二个标记有 ---&gt; 的一行。重复步骤<span class="number">2</span>和步骤<span class="number">3</span>以改正这个句子。</span><br><span class="line"></span><br><span class="line">---&gt; There <span class="keyword">is</span> some text missing from <span class="keyword">th</span></span><br><span class="line">     There <span class="keyword">is</span> some text missing from this <span class="built_in">line</span>.</span><br><span class="line">---&gt; There <span class="keyword">is</span> also some text miss</span><br><span class="line">     There <span class="keyword">is</span> also some text missing here.</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. 当您对添加文本操作感到满意时，请继续学习第一讲第六节。</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">     第一讲第六节：编辑文件</span><br><span class="line"></span><br><span class="line">    ** 使用 :<span class="keyword">wq</span> 以保存文件并退出。 **</span><br><span class="line"></span><br><span class="line">  特别提示：在执行以下步骤之前，请先读完整个小节！</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 如您在第一讲第二节中所做的那样退出本教程： :q!</span><br><span class="line">     或者，如果您可以访问另一个终端，请在那里执行以下操作。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 在 <span class="keyword">shell</span> 的提示符下输入命令： <span class="keyword">vim</span> tutor &lt;回车&gt;</span><br><span class="line">     <span class="string">'vim'</span>是启动 Vim 编辑器的命令，<span class="string">'tutor'</span>是您希望编辑的文件的名字。</span><br><span class="line">     请使用一个可以改动的文件。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 使用您在前面的教程中学到的命令插入删除文本。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 保存改动过的文件并退出 Vim，按这些键： :<span class="keyword">wq</span>  &lt;回车&gt;</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. 如果您在步骤<span class="number">1</span>中已经退出 vimtutor，请重启 vimtutor 移动到下面的小结一节。</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>. 阅读完以上步骤，弄懂它们的意义，然后在实践中进行练习。</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">       第一讲小结</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。</span><br><span class="line"> h (左移)<span class="keyword">j</span> (下行)       <span class="keyword">k</span> (上行)    <span class="keyword">l</span> (右移)</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 欲进入 Vim 编辑器(从命令行提示符)，请输入：<span class="keyword">vim</span> 文件名 &lt;回车&gt;</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 欲退出 Vim 编辑器，请输入 <span class="symbol">&lt;ESC&gt;</span>   :q!   &lt;回车&gt; 放弃所有改动。</span><br><span class="line">                      或者输入 <span class="symbol">&lt;ESC&gt;</span>   :<span class="keyword">wq</span>   &lt;回车&gt; 保存改动。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 在正常模式下删除光标所在位置的字符，请按： <span class="keyword">x</span></span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. 欲插入或添加文本，请输入：</span><br><span class="line"></span><br><span class="line"> i   输入欲插入文本   <span class="symbol">&lt;ESC&gt;</span>在光标前插入文本</span><br><span class="line"> A   输入欲添加文本   <span class="symbol">&lt;ESC&gt;</span>             在一行后添加文本</span><br><span class="line"></span><br><span class="line">特别提示：按下 <span class="symbol">&lt;ESC&gt;</span> 键会带您回到正常模式或者撤消一个不想输入或部分完整</span><br><span class="line">的命令。</span><br><span class="line"></span><br><span class="line">好了，第一讲到此结束。下面接下来继续第二讲的内容。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">第二讲第一节：删除类命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ** 输入 dw 可以从光标处删除至一个单词的末尾。**</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 请按下 <span class="symbol">&lt;ESC&gt;</span> 键确保您处于正常模式。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 请将光标移至准备要删除的单词的起始处。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 接着输入 dw 删除掉该单词。</span><br><span class="line"></span><br><span class="line">  特别提示：当您输入时，字母 d 会同时出现在屏幕的最后一行。Vim 在等待您输入</span><br><span class="line">  字母 <span class="keyword">w</span>。如果您看到的是除 d 外的其他字符，那表明您按错了；请按下 <span class="symbol">&lt;ESC&gt;</span> 键，</span><br><span class="line">  然后重新再来。</span><br><span class="line"></span><br><span class="line">---&gt; There are <span class="keyword">a</span> some words fun that don<span class="string">'t belong paper in this sentence.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  5. 重复步骤3和步骤4，直至句子修正完毕。接着继续第二讲第二节内容。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">      第二讲第二节：更多删除类命令</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   ** 输入 d$ 从当前光标删除到行末。**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. 请按下 &lt;ESC&gt; 键确保您处于正常模式。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  2. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  3. 请将光标移动到该行的尾部(也就是在第一个点号‘.’后面)。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  4. 然后输入 d$ 从光标处删至当前行尾部。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---&gt; Somebody typed the end of this line twice. end of this line twice.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  5. 请继续学习第二讲第三节就知道是怎么回事了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">     第二讲第三节：关于命令和对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  许多改变文本的命令都由一个操作符和一个动作构成。</span></span><br><span class="line"><span class="string">  使用删除操作符 d 的删除命令的格式如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">d   motion</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  其中：</span></span><br><span class="line"><span class="string">    d      - 删除操作符。</span></span><br><span class="line"><span class="string">    motion - 操作符的操作对象(在下面列出)。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  一个简短的动作列表：</span></span><br><span class="line"><span class="string">    w - 从当前光标当前位置直到下一个单词起始处，不包括它的第一个字符。</span></span><br><span class="line"><span class="string">    e - 从当前光标当前位置直到单词末尾，包括最后一个字符。</span></span><br><span class="line"><span class="string">    $ - 从当前光标当前位置直到当前行末。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  因此输入 de 会从当前光标位置删除到单词末尾。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">特别提示：</span></span><br><span class="line"><span class="string">    对于勇于探索者，请在正常模式下面仅按代表相应动作的键而不使用操作符，您</span></span><br><span class="line"><span class="string">    将看到光标的移动正如上面的对象列表所代表的一样。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">     第二讲第四节：使用计数指定动作</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">             ** 在动作前输入数字会使它重复那么多次。 **</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. 移动光标到下面标记有 ---&gt; 的一行的开始。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  2. 输入 2w 使光标向前移动两个单词。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  3. 输入 3e 使光标向前移动到第三个单词的末尾。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  4. 输入 0 (数字零) 移动光标到行首。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  5. 重复步骤2和步骤3，尝试不同的数字。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---&gt; This is just a line with words you can move around in.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  6. 请继续学习第二讲第五节。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">       第二讲第五节：使用计数以删除更多</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       ** 使用操作符时输入数字可以使它重复那么多次。 **</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  上面已经提到过删除操作符和动作的组合，您可以在组合中动作之前插入一个数字以</span></span><br><span class="line"><span class="string">  删除更多：</span></span><br><span class="line"><span class="string"> d   number(数字)   motion</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. 移动光标到下面标记有 ---&gt; 的一行中第一个大写字母单词上。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  2. 输入 d2w 以删除两个大写字母单词。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  3. 重复步骤1和步骤2，使用不同的数字使得用一个命令就能删除全部相邻的大写字母</span></span><br><span class="line"><span class="string">     单词</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---&gt;  this ABC DE line FGHI JK LMN OP of words is Q RS TUV cleaned up.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">    第二讲第六节：操作整行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     ** 输入 dd 可以删除整一个当前行。 **</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  鉴于整行删除的高频度，Vi 的设计者决定要简化整行删除操作，您仅需要在同一行上</span></span><br><span class="line"><span class="string">  击打两次 d 就可以删除掉光标所在的整行了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. 请将光标移动到本节中下面的短句段落中的第二行。</span></span><br><span class="line"><span class="string">  2. 输入 dd 删除该行。</span></span><br><span class="line"><span class="string">  3. 然后移动到第四行。</span></span><br><span class="line"><span class="string">  4. 接着输入 2dd 删除两行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---&gt;  1)  Roses are red,</span></span><br><span class="line"><span class="string">---&gt;  2)  Mud is fun,</span></span><br><span class="line"><span class="string">---&gt;  3)  Violets are blue,</span></span><br><span class="line"><span class="string">---&gt;  4)  I have a car,</span></span><br><span class="line"><span class="string">---&gt;  5)  Clocks tell time,</span></span><br><span class="line"><span class="string">---&gt;  6)  Sugar is sweet</span></span><br><span class="line"><span class="string">---&gt;  7)  And so are you.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">   第二讲第七节：撤消类命令</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">** 输入 u 来撤消最后执行的命令，输入 U 来撤消对整行的修改。 **</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. 请将光标移动到本节中下面标记有 ---&gt; 的那一行，并将其置于第一个错误</span></span><br><span class="line"><span class="string">     处。</span></span><br><span class="line"><span class="string">  2. 输入 x 删除第一个不想保留的字母。</span></span><br><span class="line"><span class="string">  3. 然后输入 u 撤消最后执行的(一次)命令。</span></span><br><span class="line"><span class="string">  4. 这次要使用 x 修正本行的所有错误。</span></span><br><span class="line"><span class="string">  5. 现在输入一个大写的 U ，恢复到该行的原始状态。</span></span><br><span class="line"><span class="string">  6. 接着多次输入 u 以撤消 U 以及更前的命令。</span></span><br><span class="line"><span class="string">  7. 然后多次输入 CTRL-R (先按下 CTRL 键不放开，接着按 R 键)，这样就</span></span><br><span class="line"><span class="string">     可以重做被撤消的命令，也就是撤消掉撤消命令。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---&gt; Fiix the errors oon thhis line and reeplace them witth undo.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  8. 这些都是非常有用的命令。下面是第二讲的小结了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">       第二讲小结</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. 欲从当前光标删除至下一个单词，请输入：dw</span></span><br><span class="line"><span class="string">  2. 欲从当前光标删除至当前行末尾，请输入：d$</span></span><br><span class="line"><span class="string">  3. 欲删除整行，请输入：dd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  4. 欲重复一个动作，请在它前面加上一个数字：2w</span></span><br><span class="line"><span class="string">  5. 在正常模式下修改命令的格式是：</span></span><br><span class="line"><span class="string">               operator   [number]   motion</span></span><br><span class="line"><span class="string">     其中：</span></span><br><span class="line"><span class="string">       operator - 操作符，代表要做的事情，比如 d 代表删除</span></span><br><span class="line"><span class="string">       [number] - 可以附加的数字，代表动作重复的次数</span></span><br><span class="line"><span class="string">       motion   - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)，</span></span><br><span class="line"><span class="string">  $ 代表行末等等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  6. 欲移动光标到行首，请按数字0键：0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  7. 欲撤消以前的操作，请输入：u (小写的u)</span></span><br><span class="line"><span class="string">     欲撤消在一行中所做的改动，请输入：U (大写的U)</span></span><br><span class="line"><span class="string">     欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">   第三讲第一节：置入类命令</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">** 输入 p 将最后一次删除的内容置入光标之后。 **</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. 请将光标移动到本节中下面第一个标记有 ---&gt; 的一行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  2. 输入 dd 将该行删除，这样会将该行保存到 Vim 的一个寄存器中。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  3. 接着将光标移动到 c) 一行，即准备置入的位置的上方。记住：是上方哦。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  4. 然后在正常模式下(&lt;ESC&gt;键进入)输入 p 将该行粘贴置入。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  5. 重复步骤2至步骤4，将所有的行依序放置到正确的位置上。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---&gt; d) Can you learn too?</span></span><br><span class="line"><span class="string">---&gt; b) Violets are blue,</span></span><br><span class="line"><span class="string">---&gt; c) Intelligence is learned,</span></span><br><span class="line"><span class="string">---&gt; a) Roses are red,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">   第三讲第二节：替换类命令</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  ** 输入 r 和一个字符替换光标所在位置的字符。**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  2. 请移动光标到第一个出错的位置。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  3. 接着输入 r 和要替换成的字符，这样就能将错误替换掉了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  4. 重复步骤2和步骤3，直到第一行已经修改完毕。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---&gt;  Whan this lime was tuoed in, someone presswd some wrojg keys!</span></span><br><span class="line"><span class="string">---&gt;  When this line was typed in, someone pressed some wrong keys!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  5. 然后我们继续学习第三讲第三节。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">特别提示：切记您要在使用中学习，而不是在记忆中学习。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">第三讲第三节：更改类命令</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> ** 要改变文本直到一个单词的末尾，请输入 ce **</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  2. 接着把光标放在单词 lubw 的字母 u 的位置那里。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  3. 然后输入 cw 以及正确的单词(在本例中是输入 ine )。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  4. 最后按 &lt;ESC&gt; 键，然后光标定位到下一个错误第一个准备更改的字母处。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  5. 重复步骤3和步骤4，直到第一个句子完全雷同第二个句子。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---&gt; This lubw has a few wptfd that mrrf changing usf the change operator.</span></span><br><span class="line"><span class="string">---&gt; This line has a few words that need changing using the change operator.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">提示：请注意 ce 命令不仅仅是删除了一个单词，它也让您进入插入模式了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">       第三讲第四节：使用c更改更多</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   ** 更改类操作符可以与删除中使用的同样的动作配合使用。 **</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. 更改类操作符的工作方式跟删除类是一致的。操作格式是：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         c    [number]   motion</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  2. 动作参数(motion)也是一样的，比如 w 代表单词，$代表行末等等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  3. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  4. 接着将光标移动到第一个错误处。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  5. 然后输入 c$ 使得该行剩下的部分更正得同第二行一样。最后按 &lt;ESC&gt; 键。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---&gt; The end of this line needs some help to make it like the second.</span></span><br><span class="line"><span class="string">---&gt; The end of this line needs to be corrected using the  c$  command.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">  第三讲小结</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. 要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除</span></span><br><span class="line"><span class="string">     的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置</span></span><br><span class="line"><span class="string">     于当前光标所在行的下一行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  2. 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字</span></span><br><span class="line"><span class="string">     符即可。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  3. 更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。</span></span><br><span class="line"><span class="string">     比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当</span></span><br><span class="line"><span class="string">     前光标到行末的内容。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  4. 更改类命令的格式是：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> c   [number]   motion</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">现在我们继续学习下一讲。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">     第四讲第一节：定位及文件状态</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  ** 输入 CTRL-G 显示当前编辑文件中当前光标所在行位置以及文件状态信息。</span></span><br><span class="line"><span class="string">     输入大写 G 则直接跳转到文件中的某一指定行。**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  提示：切记要先通读本节内容，之后才可以执行以下步骤!!!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. 按下 CTRL 键不放开然后按 g 键。我们称这个键组合为 CTRL-G。</span></span><br><span class="line"><span class="string">     您会看到页面最底部出现一个状态信息行，显示的内容是当前编辑的文件名</span></span><br><span class="line"><span class="string">     和文件中光标位置。请记住行号，它会在步骤3中用到。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">提示：您也许会在屏幕的右下角看到光标位置，这会在 '</span>ruler<span class="string">' 选项设置时发生</span></span><br><span class="line"><span class="string">      (参见 :help '</span>ruler<span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  2. 输入大写 G 可以使得当前光标直接跳转到文件最后一行。</span></span><br><span class="line"><span class="string">     输入 gg 可以使得当前光标直接跳转到文件第一行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  3. 输入您曾停留的行号，然后输入大写 G。这样就可以返回到您第一次按下</span></span><br><span class="line"><span class="string">     CTRL-G 时所在的行了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  4. 如果您觉得没问题的话，请执行步骤1至步骤3的操作进行练习。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">第四讲第二节：搜索类命令</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     ** 输入 / 加上一个字符串可以用以在当前文件中查找该字符串。**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. 在正常模式下输入 / 字符。您此时会注意到该字符和光标都会出现在屏幕底</span></span><br><span class="line"><span class="string">     部，这跟 : 命令是一样的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  2. 接着输入 errroor &lt;回车&gt;。那个errroor就是您要查找的字符串。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  3. 要查找同上一次的字符串，只需要按 n 键。要向相反方向查找同上一次的字</span></span><br><span class="line"><span class="string">     符串，请输入大写 N 即可。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  4. 如果您想逆向查找字符串，请使用 ? 代替 / 进行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  5. 要回到您之前的位置按 CTRL-O (按住 Ctrl 键不放同时按下字母 o)。重复按可以</span></span><br><span class="line"><span class="string">     回退更多步。CTRL-I 会跳转到较新的位置。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---&gt;  "errroor" is not the way to spell error;  errroor is an error.</span></span><br><span class="line"><span class="string">提示：如果查找已经到达文件末尾，查找会自动从文件头部继续查找，除非</span></span><br><span class="line"><span class="string">      '</span>wrapscan<span class="string">' 选项被复位。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">   第四讲第三节：配对括号的查找</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      ** 输入 % 可以查找配对的括号 )、]、&#125;。**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. 把光标放在本节下面标记有 --&gt; 那一行中的任何一个 (、[ 或 &#123; 处。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  2. 接着按 % 字符。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  3. 此时光标的位置应当是在配对的括号处。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  4. 再次按 % 就可以跳回配对的第一个括号处。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  5. 移动光标到另一个 (、)、[、]、&#123; 或 &#125; 处，按 % 查看其所作所为。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---&gt; This ( is a test line with ('</span>s, [<span class="string">'s ] and &#123;'</span>s &#125; in it. ))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：在程序调试时，这个功能用来查找不配对的括号是很有用的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">      第四讲第四节：替换命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">** 输入 :s/old/<span class="keyword">new</span>/g 可以替换 old 为 <span class="keyword">new</span>。**</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 输入 :s/thee/the &lt;回车&gt; 。请注意该命令只改变光标所在行的第一个匹配</span><br><span class="line">     串。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 输入 :s/thee/the/g则是替换全行的匹配串，该行中所有的 <span class="string">"thee"</span> 都会被</span><br><span class="line">     改变。</span><br><span class="line"></span><br><span class="line">---&gt; thee best time <span class="keyword">to</span> see thee flowers <span class="keyword">is</span> in thee spring.</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 要替换两行之间出现的每个匹配串，请</span><br><span class="line">     输入   :#,#s/old/<span class="keyword">new</span>/g   其中 #,# 代表的是替换操作的若干行中</span><br><span class="line">                              首尾两行的行号。</span><br><span class="line">     输入   :%s/old/<span class="keyword">new</span>/g     则是替换整个文件中的每个匹配串。</span><br><span class="line">     输入   :%s/old/<span class="keyword">new</span>/gc    会找到整个文件中的每个匹配串，并且对每个匹配串</span><br><span class="line">                              提示是否进行替换。</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">       第四讲小结</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. CTRL-G 用于显示当前光标所在位置和文件状态信息。</span><br><span class="line">     G 用于将光标跳转至文件最后一行。</span><br><span class="line">     先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。</span><br><span class="line">     gg 用于将光标跳转至文件第一行。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。</span><br><span class="line">     输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。</span><br><span class="line">     完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查</span><br><span class="line">     找下一个匹配字符串所在；或者按大写 <span class="keyword">N</span> 向相反方向查找下一匹配字符串所在。</span><br><span class="line">     CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 如果光标当前位置是括号(、)、[、]、&#123;、&#125;，按 % 会将光标移动到配对的括号上。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 在一行内替换头一个字符串 old 为新的字符串 <span class="keyword">new</span>，请输入  :s/old/<span class="keyword">new</span></span><br><span class="line">     在一行内替换所有的字符串 old 为新的字符串 <span class="keyword">new</span>，请输入  :s/old/<span class="keyword">new</span>/g</span><br><span class="line">     在两行内替换所有的字符串 old 为新的字符串 <span class="keyword">new</span>，请输入  :#,#s/old/<span class="keyword">new</span>/g</span><br><span class="line">     在文件内替换所有的字符串 old 为新的字符串 <span class="keyword">new</span>，请输入  :%s/old/<span class="keyword">new</span>/g</span><br><span class="line">     进行全文替换时询问用户确认每个替换需添加 <span class="keyword">c</span> 标志        :%s/old/<span class="keyword">new</span>/gc</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">第五讲第一节：在 VIM 内执行外部命令的方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ** 输入 :! 然后紧接着输入一个外部命令可以执行该外部命令。**</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 按下我们所熟悉的 : 命令使光标移动到屏幕底部。这样您就可以输入一行命令了。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 接着输入感叹号 ! 这个字符，这样就允许您执行外部的 <span class="keyword">shell</span> 命令了。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 我们以 <span class="keyword">ls</span> 命令为例。输入 !ls &lt;回车&gt; 。该命令就会列举出您当前目录的</span><br><span class="line">     内容，就如同您在命令行提示符下输入 <span class="keyword">ls</span> 命令的结果一样。如果 !ls 没起</span><br><span class="line">     作用，您可以试试 :!dir 看看。</span><br><span class="line"></span><br><span class="line">提示：所有的外部命令都可以以这种方式执行，包括带命令行参数的那些。</span><br><span class="line"></span><br><span class="line">提示：所有的 : 命令都必须以敲 &lt;回车&gt; 键结束。从今以后我们就不会总是提到这一点</span><br><span class="line">      了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">      第五讲第二节：关于保存文件的更多信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     ** 要将对文件的改动保存到文件中，请输入 :<span class="keyword">w</span> FILENAME 。**</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 输入 :!dir 或者 :!ls 获知当前目录的内容。您应当已知道最后还得敲</span><br><span class="line">     &lt;回车&gt; 吧。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 选择一个未被用到的文件名，比如 TEST。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 接着输入 :<span class="keyword">w</span> TEST  (此处 TEST 是您所选择的文件名。)</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 该命令会以 TEST 为文件名保存整个文件 (Vim 教程)。为了验证这一点，</span><br><span class="line">     请再次输入 :!dir 或 :!ls 查看您的目录列表内容。</span><br><span class="line"></span><br><span class="line">请注意：如果您退出 Vim 然后在以命令 <span class="keyword">vim</span> TEST 再次启动 Vim，那么该文件内</span><br><span class="line">     容应该同您保存时的文件内容是完全一样的。</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. 现在您可以删除 TEST 文件了。在 MS-DOS 下，请输入：   :!del TEST</span><br><span class="line">                                 在 Unix 下，请输入：     :!rm TEST</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">    第五讲第三节：一个具有选择性的保存命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ** 要保存文件的部分内容，请输入 v motion :<span class="keyword">w</span> FILENAME **</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 移动光标到本行。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 接着按 v 键，将光标移动至下面第五个条目上。您会注意到之间的文本被高亮了。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 然后按 : 字符。您将看到屏幕底部会出现 :<span class="string">'&lt;,'</span>&gt; 。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 现在请输入 <span class="keyword">w</span> TEST，其中 TEST 是一个未被使用的文件名。确认您看到了</span><br><span class="line">     :<span class="string">'&lt;,'</span>&gt;<span class="keyword">w</span> TEST 之后按 &lt;回车&gt; 键。</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. 这时 Vim 会把选中的行写入到以 TEST 命名的文件中去。使用 :!dir 或 :!ls</span><br><span class="line">     确认文件被正确保存。这次先别删除它！我们在下一讲中会用到它。</span><br><span class="line"></span><br><span class="line">提示：按 v 键使 Vim 进入可视模式进行选取。您可以四处移动光标使选取区域变大或</span><br><span class="line">      变小。接着您可以使用一个操作符对选中文本进行操作。例如，按 d 键会删除</span><br><span class="line">      选中的文本内容。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">   第五讲第四节：提取和合并文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       ** 要向当前文件中插入另外的文件的内容，请输入 :r FILENAME **</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 请把光标移动到本行上面一行。</span><br><span class="line"></span><br><span class="line">特别提示：执行步骤<span class="number">2</span>之后您将看到第五讲第三节的文字，请届时往下移动</span><br><span class="line">          以再次看到本讲内容。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 接着通过命令 :r TEST 将前面创建的名为 TEST 的文件提取进来。</span><br><span class="line">     您所提取进来的文件将从光标所在位置处开始置入。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 为了确认文件已经提取成功，移动光标回到原来的位置就可以注意有两份第</span><br><span class="line">     五讲第三节的内容，一份是原始内容，另外一份是来自文件的副本。</span><br><span class="line"></span><br><span class="line">提示：您还可以读取外部命令的输出。例如， :r !ls 可以读取 <span class="keyword">ls</span> 命令的输出，并</span><br><span class="line">      把它放置在光标下面。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">       第五讲小结</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. :!command 用于执行一个外部命令 <span class="keyword">command</span>。</span><br><span class="line"></span><br><span class="line">     请看一些实际例子：</span><br><span class="line"> (MS-DOS)  (Unix)</span><br><span class="line">  :!dir   :!ls   -  用于显示当前目录的内容。</span><br><span class="line">  :!del FILENAME   :!rm FILENAME   -  用于删除名为 FILENAME 的文件。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. :<span class="keyword">w</span> FILENAME  可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文</span><br><span class="line">     件中。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. v motion :<span class="keyword">w</span> FILENAME 可将当前编辑文件中可视模式下选中的内容保存到文件</span><br><span class="line">     FILENAME 中。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置</span><br><span class="line">     后面。</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. :r !dir 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"> 第六讲第一节：打开类命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ** 输入 <span class="keyword">o</span> 将在光标的下方打开新的一行并进入插入模式。**</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 接着输入小写的 <span class="keyword">o</span> 在光标 *下方* 打开新的一行，这个命令会使您</span><br><span class="line">     进入插入模式。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 然后输入一些文字，之后按 <span class="symbol">&lt;ESC&gt;</span> 键退出插入模式而进入正常模式。</span><br><span class="line"></span><br><span class="line">---&gt; After typing  <span class="keyword">o</span>  the <span class="built_in">cursor</span> <span class="keyword">is</span> placed <span class="keyword">on</span> the <span class="keyword">open</span> <span class="built_in">line</span> in Insert <span class="keyword">mode</span>.</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 为了在光标 *上方* 打开新的一行，只需要输入大写的 O 而不是小写的 <span class="keyword">o</span></span><br><span class="line">     就可以了。请在下行测试一下吧。</span><br><span class="line"></span><br><span class="line">---&gt; Open <span class="keyword">up</span> <span class="keyword">a</span> <span class="built_in">line</span> above this by typing O <span class="keyword">while</span> the <span class="built_in">cursor</span> <span class="keyword">is</span> <span class="keyword">on</span> this <span class="built_in">line</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">第六讲第二节：附加类命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     ** 输入 <span class="keyword">a</span> 将可在光标之后插入文本。 **</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 请在正常模式下将光标移动到本节中下面标记有 ---&gt; 的第一行的行首。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 接着输入 <span class="keyword">e</span> 直到光标位于 li 的末尾。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 输入小写的 <span class="keyword">a</span> 则可在光标之后插入文本了。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 将单词补充完整，就像下一行中的那样。之后按 <span class="symbol">&lt;ESC&gt;</span> 键退出插入模式回到</span><br><span class="line">     正常模式。</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. 使用 <span class="keyword">e</span> 移动光标到下一步不完整的单词，重复步骤<span class="number">3</span>和步骤<span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">---&gt; This li will allow you <span class="keyword">to</span> pract appendi text <span class="keyword">to</span> <span class="keyword">a</span> <span class="built_in">line</span>.</span><br><span class="line">---&gt; This <span class="built_in">line</span> will allow you <span class="keyword">to</span> practice appending text <span class="keyword">to</span> <span class="keyword">a</span> <span class="built_in">line</span>.</span><br><span class="line"></span><br><span class="line">提示：<span class="keyword">a</span>、i 和 A 都会带您进入插入模式，惟一的区别在于字符插入的位置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">    第六讲第三节：另外一个置换类命令的版本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      ** 输入大写的 R 可连续替换多个字符。**</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。移动光标到第一个 xxx 的</span><br><span class="line">     起始位置。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 然后输入大写的 R 开始把第一行中的不同于第二行的剩余字符逐一输入，就</span><br><span class="line">     可以全部替换掉原有的字符而使得第一行完全雷同第二行了。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 接着按 <span class="symbol">&lt;ESC&gt;</span> 键退出替换模式回到正常模式。您可以注意到尚未替换的文本</span><br><span class="line">     仍然保持原状。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 重复以上步骤，将剩余的 xxx 也替换掉。</span><br><span class="line"></span><br><span class="line">---&gt; Adding <span class="number">123</span> <span class="keyword">to</span> xxx gives you xxx.</span><br><span class="line">---&gt; Adding <span class="number">123</span> <span class="keyword">to</span> <span class="number">456</span> gives you <span class="number">579</span>.</span><br><span class="line"></span><br><span class="line">提示：替换模式与插入模式相似，不过每个输入的字符都会删除一个已有的字符。</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">  第六讲第四节：复制粘贴文本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ** 使用操作符 <span class="keyword">y</span> 复制文本，使用 <span class="keyword">p</span> 粘贴文本 **</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 定位到下面标记有 ---&gt; 的一行，将光标移动到 <span class="string">"a)"</span> 之后。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 接着使用 v 进入可视模式，移动光标到 <span class="string">"first"</span> 的前面。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 现在输入 <span class="keyword">y</span> 以抽出(复制)高亮的文本。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 然后移动光标到下一行的末尾：<span class="keyword">j</span>$</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. 接着输入 <span class="keyword">p</span> 以放置(粘贴)复制了的文本。然后输入：<span class="keyword">a</span> second <span class="symbol">&lt;ESC&gt;</span>。</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>. 使用可视模式选中 <span class="string">" item."</span>，用 <span class="keyword">y</span> 复制，再用 <span class="keyword">j</span>$ 将光标移动到下一行末尾，</span><br><span class="line">     用 <span class="keyword">p</span> 将文本粘贴到那里。</span><br><span class="line"></span><br><span class="line">---&gt;  <span class="keyword">a</span>) this <span class="keyword">is</span> the <span class="keyword">first</span> item.</span><br><span class="line">      <span class="keyword">b</span>)</span><br><span class="line"></span><br><span class="line">  提示：您还可以把 <span class="keyword">y</span> 当作操作符来使用；例如 yw 可以用来复制一个单词。</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">    第六讲第五节：设置类命令的选项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ** 设置可使查找或者替换可忽略大小写的选项 **</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 要查找单词 ignore 可在正常模式下输入 /ignore &lt;回车&gt;。</span><br><span class="line">     要重复查找该词，可以重复按 n 键。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 然后设置 ic 选项(Ignore Case，忽略大小写)，请输入： :<span class="keyword">set</span> ic</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 现在可以通过键入 n 键再次查找单词 ignore。注意到 Ignore 和 IGNORE 现在</span><br><span class="line">     也被找到了。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 然后设置 hlsearch 和 incsearch 这两个选项，请输入： :<span class="keyword">set</span> hls <span class="keyword">is</span></span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. 现在可以再次输入查找命令，看看会有什么效果： /ignore &lt;回车&gt;</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>. 要禁用忽略大小写，请输入： :<span class="keyword">set</span> noic</span><br><span class="line"></span><br><span class="line">提示：要移除匹配项的高亮显示，请输入：  :<span class="keyword">nohlsearch</span></span><br><span class="line">提示：如果您想要仅在一次查找时忽略字母大小写，您可以使用 \<span class="keyword">c</span>：</span><br><span class="line">      /ignore\<span class="keyword">c</span> &lt;回车&gt;</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">       第六讲小结</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 输入小写的 <span class="keyword">o</span> 可以在光标下方打开新的一行并进入插入模式。</span><br><span class="line">     输入大写的 O 可以在光标上方打开新的一行。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 输入小写的 <span class="keyword">a</span> 可以在光标所在位置之后插入文本。</span><br><span class="line">     输入大写的 A 可以在光标所在行的行末之后插入文本。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. <span class="keyword">e</span> 命令可以使光标移动到单词末尾。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 操作符 <span class="keyword">y</span> 复制文本，<span class="keyword">p</span> 粘贴先前复制的文本。</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. 输入大写的 R 将进入替换模式，直至按 <span class="symbol">&lt;ESC&gt;</span> 键回到正常模式。</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>. 输入 :<span class="keyword">set</span> xxx 可以设置 xxx 选项。一些有用的选项如下：</span><br><span class="line">  <span class="string">'ic'</span> <span class="string">'ignorecase'</span>查找时忽略字母大小写</span><br><span class="line"><span class="string">'is'</span> <span class="string">'incsearch'</span>查找短语时显示部分匹配</span><br><span class="line"><span class="string">'hls'</span> <span class="string">'hlsearch'</span>高亮显示所有的匹配短语</span><br><span class="line">     选项名可以用完整版本，也可以用缩略版本。</span><br><span class="line"></span><br><span class="line">  <span class="number">7</span>. 在选项前加上 <span class="keyword">no</span> 可以关闭选项：  :<span class="keyword">set</span> noic</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">  第七讲第一节：获取帮助信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      ** 使用在线帮助系统 **</span><br><span class="line"></span><br><span class="line">  Vim 拥有一个细致全面的在线帮助系统。要启动该帮助系统，请选择如下三种方</span><br><span class="line">  法之一：</span><br><span class="line">- 按下 <span class="symbol">&lt;HELP&gt;</span> 键 (如果键盘上有的话)</span><br><span class="line">- 按下 <span class="symbol">&lt;F1&gt;</span> 键 (如果键盘上有的话)</span><br><span class="line">- 输入:<span class="keyword">help</span> &lt;回车&gt;</span><br><span class="line"></span><br><span class="line">  请阅读帮助窗口中的文字以了解帮助是如何工作的。</span><br><span class="line">  输入 CTRL-W CTRL-W   可以使您在窗口之间跳转。</span><br><span class="line">  输入 :q &lt;回车&gt; 可以关闭帮助窗口。</span><br><span class="line"></span><br><span class="line">  提供一个正确的参数给<span class="string">":help"</span>命令，您可以找到关于该主题的帮助。请试验以</span><br><span class="line">  下参数(可别忘了按回车键哦)：</span><br><span class="line"></span><br><span class="line">:<span class="keyword">help</span> <span class="keyword">w</span></span><br><span class="line">:<span class="keyword">help</span> c_CTRL-D</span><br><span class="line">:<span class="keyword">help</span> <span class="keyword">insert</span>-<span class="built_in">index</span></span><br><span class="line">:<span class="keyword">help</span> user-manual</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">  第七讲第二节：创建启动脚本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ** 启用 Vim 的特性 **</span><br><span class="line"></span><br><span class="line">  Vim 的功能特性要比 Vi 多得多，但其中大部分都没有缺省启用。为了使用更多的</span><br><span class="line">  特性，您得创建一个 vimrc 文件。</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 开始编辑 vimrc 文件，具体命令取决于您所使用的操作系统：</span><br><span class="line">        :<span class="keyword">edit</span> ~/.vimrc这是 Unix 系统所使用的命令</span><br><span class="line">        :<span class="keyword">edit</span> $VIM/_vimrc这是 MS-Windows 系统所使用的命令</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 接着读取 vimrc 示例文件的内容：</span><br><span class="line">        :r $VIMRUNTIME/vimrc_example.<span class="keyword">vim</span></span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 保存文件，命令为：</span><br><span class="line">        :<span class="keyword">write</span></span><br><span class="line"></span><br><span class="line">  下次您启动 Vim 时，编辑器就会有了语法高亮的功能。</span><br><span class="line">  您可以把您喜欢的各种设置添加到这个 vimrc 文件中。</span><br><span class="line">  要了解更多信息请输入 :<span class="keyword">help</span> vimrc-<span class="keyword">intro</span></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">    第七讲第三节：补全功能</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      ** 使用 CTRL-D 和 <span class="symbol">&lt;TAB&gt;</span> 可以进行命令行补全 **</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 请确保 Vim 不是在以兼容模式运行： :<span class="keyword">set</span> nocp</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 查看一下当前目录下已经存在哪些文件，输入： :!ls   或者  :!dir</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 现在输入一个目录的起始部分，例如输入： :<span class="keyword">e</span></span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 接着按 CTRL-D 键，Vim 会显示以 <span class="keyword">e</span> 开始的命令的列表。</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. 然后按 <span class="symbol">&lt;TAB&gt;</span> 键，Vim 会补全命令为 :<span class="keyword">edit</span> 。</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>. 现在添加一个空格，以及一个已有文件的文件名的起始部分，例如： :<span class="keyword">edit</span> FIL</span><br><span class="line"></span><br><span class="line">  <span class="number">7</span>. 接着按 <span class="symbol">&lt;TAB&gt;</span> 键，Vim 会补全文件名(如果它是惟一匹配的)。</span><br><span class="line"></span><br><span class="line">提示：补全对于许多命令都有效。您只需尝试按 CTRL-D 和 <span class="symbol">&lt;TAB&gt;</span>。</span><br><span class="line">      它对于 :<span class="keyword">help</span> 命令非常有用。</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">  第七讲小结</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. 输入 :<span class="keyword">help</span> 或者按 <span class="symbol">&lt;F1&gt;</span> 键或 <span class="symbol">&lt;Help&gt;</span> 键可以打开帮助窗口。</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>. 输入 :<span class="keyword">help</span> cmd 可以找到关于 cmd 命令的帮助。</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. 输入 CTRL-W CTRL-W  可以使您在窗口之间跳转。</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>. 输入 :q 以关闭帮助窗口</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>. 您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>. 当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。</span><br><span class="line">     按 <span class="symbol">&lt;TAB&gt;</span> 可以使用一个补全。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line">  <span class="keyword">vim</span> 教程到此就结束了。本教程只是为了简明地介绍一下 Vim 编辑器，但已足以让您</span><br><span class="line">  很容易使用这个编辑器了。毋庸质疑，<span class="keyword">vim</span>还有很多很多的命令，本教程所介</span><br><span class="line">  绍的距离完整的差得很远。所以您要精通的话，还望继续努力哦。下一步您可以阅读</span><br><span class="line">  Vim 的用户手册，使用的命令是： :<span class="keyword">help</span> user-manual</span><br><span class="line"></span><br><span class="line">  下面这本书值得推荐用于更进一步的阅读和学习：</span><br><span class="line">Vim - Vi Improved - 作者：Steve Oualline</span><br><span class="line">出版社：New Riders</span><br><span class="line">  这是第一本完全讲解 Vim 的书籍。它对于初学者特别有用。其中包含有大量实例</span><br><span class="line">  和图示。</span><br><span class="line">  欲知详情，请访问 http://iccf-holland.org/click5.html</span><br><span class="line"></span><br><span class="line">  以下这本书比较老了而且内容更多是关于 Vi 而非 Vim，但是也值得推荐：</span><br><span class="line">Learning the Vi Editor - 作者：Linda Lamb</span><br><span class="line">出版社：O<span class="string">'Reilly &amp; Associates Inc.</span></span><br><span class="line"><span class="string">  这是一本不错的书，通过它您几乎能够了解到任何您想要使用 Vi 做的事情。</span></span><br><span class="line"><span class="string">  此书的第六个版本也包含了一些关于 Vim 的信息。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  本教程是由来自 Calorado School of Mines 的 Michael C. Pierce 和</span></span><br><span class="line"><span class="string">  Robert K. Ware 所编写的，其中很多创意由来自 Colorado State University 的</span></span><br><span class="line"><span class="string">  Charles Smith 提供。编者的电子邮箱是：bware@mines.colorado.edu</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  本教程已由 Bram Moolenaar 专为 Vim 进行修订。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  译制者附言：</span></span><br><span class="line"><span class="string">  ===========</span></span><br><span class="line"><span class="string">      简体中文教程翻译版之译制者为梁昌泰 &lt;beos@turbolinux.com.cn&gt;，还有</span></span><br><span class="line"><span class="string">      另外一个联系地址：linuxrat@gnuchina.org。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      繁体中文教程是从简体中文教程翻译版使用 Debian GNU/Linux 中文项目小</span></span><br><span class="line"><span class="string">      组的于广辉先生编写的中文汉字转码器  autoconvert 转换而成的，并对转</span></span><br><span class="line"><span class="string">      换的结果做了一些细节的改动。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  变更记录：</span></span><br><span class="line"><span class="string">  =========</span></span><br><span class="line"><span class="string">      2012年10月01日 赵涛 &lt;alick9188@gmail.com&gt;</span></span><br><span class="line"><span class="string">      将 vimtutor 中译版从 1.5 升级到 1.7。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      2002年08月30日 梁昌泰 &lt;beos@turbolinux.com.cn&gt;</span></span><br><span class="line"><span class="string">      感谢 RMS@SMTH 的指正，将多处错误修正。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      2002年04月22日 梁昌泰 &lt;linuxrat@gnuchina.org&gt;</span></span><br><span class="line"><span class="string">      感谢 xuandong@sh163.net 的指正，将两处错别字修正。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      2002年03月18日 梁昌泰 &lt;linuxrat@gnuchina.org&gt;</span></span><br><span class="line"><span class="string">      根据Bram Moolenaar先生在2002年03月16日的来信要求，将vimtutor1.4中译</span></span><br><span class="line"><span class="string">      版升级到vimtutor1.5。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      2001年11月15日 梁昌泰 &lt;linuxrat@gnuchina.org&gt;</span></span><br><span class="line"><span class="string">      将vimtutor1.4中译版提交给Bram Moolenaar和Sven Guckes。</span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br></pre></td></tr></table></figure><h2 id="安装Vundke"><a href="#安装Vundke" class="headerlink" title="安装Vundke"></a>安装Vundke</h2><ul><li><p>1 下载Vundle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;gmarik&#x2F;Vundle.vim.git ~&#x2F;.vim&#x2F;bundle&#x2F;Vundle.vim</span><br></pre></td></tr></table></figure></li><li><p>2 配置<br>将下列内容，粘贴到 ~/.vimrc 的顶部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">set nocompatible              &quot; be iMproved, required</span><br><span class="line">filetype off                  &quot; required</span><br><span class="line"></span><br><span class="line">&quot; set the runtime path to include Vundle and initialize</span><br><span class="line">set rtp+&#x3D;~&#x2F;.vim&#x2F;bundle&#x2F;Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">&quot; alternatively, pass a path where Vundle should install plugins</span><br><span class="line">&quot;call vundle#begin(&#39;~&#x2F;some&#x2F;path&#x2F;here&#39;)</span><br><span class="line"></span><br><span class="line">&quot; let Vundle manage Vundle, required</span><br><span class="line">Plugin &#39;VundleVim&#x2F;Vundle.vim&#39;</span><br><span class="line"></span><br><span class="line">&quot; The following are examples of different formats supported.</span><br><span class="line">&quot; Keep Plugin commands between vundle#begin&#x2F;end.</span><br><span class="line">&quot; plugin on GitHub repo</span><br><span class="line">&quot; Plugin &#39;tpope&#x2F;vim-fugitive&#39;</span><br><span class="line">&quot; plugin from http:&#x2F;&#x2F;vim-scripts.org&#x2F;vim&#x2F;scripts.html</span><br><span class="line">&quot; Plugin &#39;L9&#39;</span><br><span class="line">&quot; Git plugin not hosted on GitHub</span><br><span class="line">&quot; Plugin &#39;git:&#x2F;&#x2F;git.wincent.com&#x2F;command-t.git&#39;</span><br><span class="line">&quot; git repos on your local machine (i.e. when working on your own plugin)</span><br><span class="line">&quot; Plugin &#39;file:&#x2F;&#x2F;&#x2F;home&#x2F;gmarik&#x2F;path&#x2F;to&#x2F;plugin&#39;</span><br><span class="line">&quot; The sparkup vim script is in a subdirectory of this repo called vim.</span><br><span class="line">&quot; Pass the path to set the runtimepath properly.</span><br><span class="line">&quot; Plugin &#39;rstacruz&#x2F;sparkup&#39;, &#123;&#39;rtp&#39;: &#39;vim&#x2F;&#39;&#125;</span><br><span class="line">&quot; Install L9 and avoid a Naming conflict if you&#39;ve already installed a</span><br><span class="line">&quot; different version somewhere else.</span><br><span class="line">&quot; Plugin &#39;ascenator&#x2F;L9&#39;, &#123;&#39;name&#39;: &#39;newL9&#39;&#125;</span><br><span class="line"></span><br><span class="line">&quot; All of your Plugins must be added before the following line</span><br><span class="line">call vundle#end()            &quot; required</span><br><span class="line">filetype plugin indent on    &quot; required</span><br><span class="line">&quot; To ignore plugin indent changes, instead use:</span><br><span class="line">&quot;filetype plugin on</span><br><span class="line">&quot;</span><br><span class="line">&quot; Brief help</span><br><span class="line">&quot; :PluginList       - lists configured plugins</span><br><span class="line">&quot; :PluginInstall    - installs plugins; append &#96;!&#96; to update or just :PluginUpdate</span><br><span class="line">&quot; :PluginSearch foo - searches for foo; append &#96;!&#96; to refresh local cache</span><br><span class="line">&quot; :PluginClean      - confirms removal of unused plugins; append &#96;!&#96; to auto-approve removal</span><br><span class="line">&quot;</span><br><span class="line">&quot; see :h vundle for more details or wiki for FAQ</span><br><span class="line">&quot; Put your non-Plugin stuff after this line</span><br></pre></td></tr></table></figure></li><li><p>3 打开vim，输入</p></li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:PluginInstall</span><br></pre></td></tr></table></figure><h2 id="取消自动备份"><a href="#取消自动备份" class="headerlink" title="取消自动备份"></a>取消自动备份</h2><p>完整的完成了 VIM Tutor 的教程后，使用 vim 编辑，每次编辑后，会出现一个带 ～ 后缀的备份文件，按照以下步骤，可以关闭自动备份。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> ~/.vimrc</span><br><span class="line"><span class="comment">"搜索 backup</span></span><br><span class="line"><span class="comment">"注释下面两行代码</span></span><br><span class="line"><span class="comment">"else</span></span><br><span class="line"><span class="comment">"  set back</span></span><br></pre></td></tr></table></figure><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vim&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="inbox" scheme="https://skybrim.top/tags/inbox/"/>
    
      <category term="vim" scheme="https://skybrim.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>语音播报</title>
    <link href="https://skybrim.top/2018/11/24/ios/voice-push/"/>
    <id>https://skybrim.top/2018/11/24/ios/voice-push/</id>
    <published>2018-11-23T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.069Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 12 及以上，需要使用本地音频拼接，或者申请VoIP。<br>iOS 10 及以上，使用 Notification Service Extension 实现远程推送语音播报。<br>iOS 10 以下，只能播放固定音频。</p><a id="more"></a><p>需求：无论应用在前台、后台还是完全杀死，都能语音播放通知带来的文本。</p><p>原理：在收到远程推送的时候，Service Extension将远程推送的信息拦截下来，此时将文字信息转换为语音，进行播报，播报完毕之后再展示弹框信息。<br>UNNotificationServiceExtension，可以拦截到远程推送的信息，调用self.contentHandler(self.bestAttemptContent); 之后，就会进行弹框显示了，此时UNNotificationServiceExtension的结束。</p><h2 id="添加-Notification-Service-Extension"><a href="#添加-Notification-Service-Extension" class="headerlink" title="添加 Notification Service Extension"></a>添加 Notification Service Extension</h2><p>打开 Xcode ，File -&gt; New -&gt; Target<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/Screen%20Shot%202019-06-20%20at%2014.05.54.png" alt=""><br>自定 Product Name<br>Xcode会为你的项目生成新的 target。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/Screen%20Shot%202019-06-20%20at%2014.07.00.png" alt=""><br>在NotificationService 中，-didReceiveNotificationRequest:withContentHandler:,此方法可以获取到推送相关信息。<br>注意，需要在推送的格式中，写入参数 mutable-content ，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;aps&quot;:&#123;</span><br><span class="line">  &quot;alert&quot;:&#123;</span><br><span class="line">   &quot;title&quot;:&quot;title&quot;,</span><br><span class="line">   &quot;subtitle&quot;:&quot;subtitle&quot;,</span><br><span class="line">   &quot;body&quot;:&quot;body&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line"> &quot;category&quot;:&quot;category&quot;,</span><br><span class="line"> &quot;mutable-content&quot;:1,</span><br><span class="line"> &quot;badge&quot;:1,</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加文字转语音功能"><a href="#添加文字转语音功能" class="headerlink" title="添加文字转语音功能"></a>添加文字转语音功能</h2><p>方法有很多，系统自带的文字转语音功能、科大讯发的SDK等等第三方。<br>我这里使用系统自带的文字转语音功能：AVSpeechSynthesizer ，相关方法以及设置可以参考 <a href="https://github.com/skybrim/VoicePush" target="_blank" rel="noopener">demo</a> 。 </p><h2 id="真机运行"><a href="#真机运行" class="headerlink" title="真机运行"></a>真机运行</h2><p>真机运行时，请注意，除了运行原工程 target ，也要选择新的 target 重新运行一遍。<br><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/Screen%20Shot%202019-06-20%20at%2014.15.49.png" alt=""></p><h2 id="iOS-12-1-及之后版本"><a href="#iOS-12-1-及之后版本" class="headerlink" title="iOS 12.1 及之后版本"></a>iOS 12.1 及之后版本</h2><p>iOS 12.1 apple官方给出说明，推送扩展无法在后台进行播放。  </p><ul><li><p>申请VoIP<br>VoIP 会唤醒 app ，然后进行语音播报。<br>缺点是审核需要提供相关演示，表示需要申请 VoIP 。  </p></li><li><p>播放本地音频<br>本地存放拆分好的音频文件，接受到远程通知是，利用本地通知来播放，缺点是本地通知每通知播放一次就会震动一次。  </p></li></ul><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>打包时，需要给新的 target 设置好证书和 profile 文件，同 app 打包类似。<br>Developer 网站，Certificates,Identifiers &amp; Profiles ，app 和 extension 都需要AppID，通过 App Groups 进行关联。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 12 及以上，需要使用本地音频拼接，或者申请VoIP。&lt;br&gt;iOS 10 及以上，使用 Notification Service Extension 实现远程推送语音播报。&lt;br&gt;iOS 10 以下，只能播放固定音频。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>hexo 搭建 blog</title>
    <link href="https://skybrim.top/2018/11/11/inbox/hexo-blog/"/>
    <id>https://skybrim.top/2018/11/11/inbox/hexo-blog/</id>
    <published>2018-11-10T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.064Z</updated>
    
    <content type="html"><![CDATA[<p>方案：Hexo + Next + GitHub Pages</p><a id="more"></a><p>环境：macOS Mojave 10.14.4  时间：2019-05-13</p><!--more--><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><ul><li>安装git</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><ul><li>安装nvm</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO-https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh |bash</span><br></pre></td></tr></table></figure><ul><li>安装Node.js</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install stable</span><br></pre></td></tr></table></figure><ul><li>安装hexo</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><ul><li>安装next  </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog目录  </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li><p>配置站点<br>  打开 blog 目录下的 _config.yml 文件</p></li><li><p>基本设置</p><blockquote><p>title: 标题<br>subtitle: 副标题<br>description:<br>keywords:<br>author: 作者<br>language: zh-Hans<br>timezone:  </p></blockquote></li><li><p>主题设置</p><blockquote><p>theme: next</p></blockquote></li><li><p>部署设置</p><blockquote><p>deploy:<br>type: git<br>repo: repo仓库地址<br>branch: repo的分支  </p></blockquote></li><li><p>配置主题<br>  打开 blog 目录,themes -&gt; next -&gt; _config.yml 文件</p><blockquote><p>since: 2018 #copyright起始时间<br>menu,根据个人需求，我使用了首页home和标签页tag<br>Schemes,next主题的不同样式，我选择 Pisces<br>avatar，个人头像设置，头像图片放在主题的 image 文件夹里面，/images/Avatar.png<br>disqus，评论插件，需要去申请一个shortname<br>google_analytics，谷歌网页分析，需要申请一个ID<br>busuanzi_count,浏览量等统计插件，next当前这个版本有bug，需要自己去修改一下配置  </p></blockquote></li><li><p>使用过的第三方插件：  </p><blockquote><p>hexo-filter-mermaid-diagrams，配合markdown生成流程图<br>hexo-blog-encrypt，加密插件  </p></blockquote></li></ul><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><ul><li><p>tag<br>新建tag页面</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></li><li><p>设置页面类型</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br></pre></td></tr></table></figure></li><li><p>生成文章</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post 文章标题</span><br></pre></td></tr></table></figure></li><li><p>生成文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></li><li><p>部署<br>如果已经在站点配置文件设置好，可以直接部署到 github pages 上</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>  本地查看</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;方案：Hexo + Next + GitHub Pages&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="inbox" scheme="https://skybrim.top/tags/inbox/"/>
    
      <category term="hexo" scheme="https://skybrim.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 实现 Mermaid 流程图</title>
    <link href="https://skybrim.top/2018/11/11/inbox/hexo-mermaid/"/>
    <id>https://skybrim.top/2018/11/11/inbox/hexo-mermaid/</id>
    <published>2018-11-10T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.064Z</updated>
    
    <content type="html"><![CDATA[<p>hexo-filter-mermaid-diagrams,这个插件可以帮助 Hexo 实现各种 mermaid 流程图。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p>进入Blog目录</p><p>  yarn 安装</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure><p>  npm 安装</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure></li><li><p>Step2 Edit Config</p><p>  打开站点配置文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span><br><span class="line">mermaid: <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">    version: <span class="string">"7.1.2"</span> <span class="comment"># default v7.1.2</span></span><br><span class="line">    options:  <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span><br><span class="line">        <span class="comment">#startOnload: true  // default true</span></span><br></pre></td></tr></table></figure><p>  <strong>注意: 如果你想使用 ‘Class diagram’ , 请编辑 **站点配置文件</strong> 文件, 设置 external_link: false。hexo的bug.**</p></li><li><p>Step3 include mermaid.js in pug or ejs</p><p>  找到主题里面的页脚文件，也即 themes/主题/layout/_partials， after_footer.pug , after-footer.ejs 或者 .swig</p><p>  after_footer.pug</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.mermaid.enable == <span class="literal">true</span></span><br><span class="line">    script(<span class="built_in">type</span>=<span class="string">'text/javascript'</span>, id=<span class="string">'maid-script'</span> mermaidoptioins=theme.mermaid.options src=<span class="string">'https://unpkg.com/mermaid@'</span>+ theme.mermaid.version + <span class="string">'/dist/mermaid.min.js'</span> + <span class="string">'?v='</span> + theme.version)</span><br><span class="line">    script.</span><br><span class="line">        <span class="keyword">if</span> (window.mermaid) &#123;</span><br><span class="line">            var options = JSON.parse(document.getElementById(<span class="string">'maid-script'</span>).getAttribute(<span class="string">'mermaidoptioins'</span>));</span><br><span class="line">            mermaid.initialize(options);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>  after-footer.ejs</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.mermaid.enable) &#123; %&gt;</span><br><span class="line">&lt;script src=<span class="string">'https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js'</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">if</span> (window.mermaid) &#123;</span><br><span class="line">    mermaid.initialize(&#123;theme: <span class="string">'forest'</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>  .swig</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.mermaid.enable %&#125;</span><br><span class="line">    &lt;script src=<span class="string">'https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js'</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span> (window.mermaid) &#123;</span><br><span class="line">        mermaid.initialize(&#123;&#123; JSON.stringify(theme.mermaid.options) &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="mermaid-演示"><a href="#mermaid-演示" class="headerlink" title="mermaid 演示"></a>mermaid 演示</h2><h3 id="Flowchart"><a href="#Flowchart" class="headerlink" title="Flowchart"></a>Flowchart</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">A--&gt;B;</span><br><span class="line">A--&gt;C;</span><br><span class="line">B--&gt;D;</span><br><span class="line">C--&gt;D;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/flow.png" alt="1"></p><h3 id="Sequence-diagram"><a href="#Sequence-diagram" class="headerlink" title="Sequence diagram"></a>Sequence diagram</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant Alice</span><br><span class="line">participant Bob</span><br><span class="line">Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">loop Healthcheck</span><br><span class="line">John-&gt;&gt;John: Fight against hypochondria</span><br><span class="line">end</span><br><span class="line">Note right of John: Rational thoughts &lt;br/&gt;prevail...</span><br><span class="line">John--&gt;&gt;Alice: Great!</span><br><span class="line">John-&gt;&gt;Bob: How about you?</span><br><span class="line">Bob--&gt;&gt;John: Jolly good!</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/sequence.png" alt="2"></p><h3 id="Gantt-diagram"><a href="#Gantt-diagram" class="headerlink" title="Gantt diagram"></a>Gantt diagram</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">dateFormat  YYYY-MM-DD</span><br><span class="line">title Adding GANTT diagram to mermaid</span><br><span class="line"></span><br><span class="line">section A section</span><br><span class="line">Completed task            :<span class="keyword">done</span>,    des1, 2014-01-06,2014-01-08</span><br><span class="line">Active task               :active,  des2, 2014-01-09, 3d</span><br><span class="line">Future task               :         des3, after des2, 5d</span><br><span class="line">Future task2               :         des4, after des3, 5d</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/gantt.png" alt="3"></p><h3 id="Class-diagram-exclamation-experimental"><a href="#Class-diagram-exclamation-experimental" class="headerlink" title="Class diagram - :exclamation: experimental"></a>Class diagram - :exclamation: experimental</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Class01 &lt;|-- AveryLongClass : Cool</span><br><span class="line">Class03 *-- Class04</span><br><span class="line">Class05 o-- Class06</span><br><span class="line">Class07 .. Class08</span><br><span class="line">Class09 --&gt; C2 : Where am i?</span><br><span class="line">Class09 --* C3</span><br><span class="line">Class09 --|&gt; Class07</span><br><span class="line">Class07 : equals()</span><br><span class="line">Class07 : Object[] elementData</span><br><span class="line">Class01 : size()</span><br><span class="line">Class01 : int chimp</span><br><span class="line">Class01 : int gorilla</span><br><span class="line">Class08 &lt;--&gt; C2: Cool label</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/class.png" alt="4"></p><h3 id="Git-graph-exclamation-experimental"><a href="#Git-graph-exclamation-experimental" class="headerlink" title="Git graph - :exclamation: experimental"></a>Git graph - :exclamation: experimental</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gitGraph:</span><br><span class="line">options</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"nodeSpacing"</span>: 150,</span><br><span class="line"><span class="string">"nodeRadius"</span>: 10</span><br><span class="line">&#125;</span><br><span class="line">end</span><br><span class="line">commit</span><br><span class="line">branch newbranch</span><br><span class="line">checkout newbranch</span><br><span class="line">commit</span><br><span class="line">commit</span><br><span class="line">checkout master</span><br><span class="line">commit</span><br><span class="line">commit</span><br><span class="line">merge newbranch</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/git.png" alt="5"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo-filter-mermaid-diagrams,这个插件可以帮助 Hexo 实现各种 mermaid 流程图。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="inbox" scheme="https://skybrim.top/tags/inbox/"/>
    
      <category term="hexo" scheme="https://skybrim.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C runloop</title>
    <link href="https://skybrim.top/2017/09/01/ios/runloop/"/>
    <id>https://skybrim.top/2017/09/01/ios/runloop/</id>
    <published>2017-09-01T03:10:28.000Z</published>
    <updated>2020-12-10T02:48:42.067Z</updated>
    
    <content type="html"><![CDATA[<p>RunLoop</p><a id="more"></a><h2 id="获取-RunLoop"><a href="#获取-RunLoop" class="headerlink" title="获取 RunLoop"></a>获取 RunLoop</h2><p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。</p><p>线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。</p><p>RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。</p><p>你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> loopsDic;</span><br><span class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFSpinLock_t</span> loopsLock;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class="line">        loopsDic = <span class="built_in">CFDictionaryCreateMutable</span>();</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> mainLoop = _CFRunLoopCreate();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = <span class="built_in">CFDictionaryGetValue</span>(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">/// 取不到时，创建一个</span></span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, thread, loop);</span><br><span class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="runloop-的相关类"><a href="#runloop-的相关类" class="headerlink" title="runloop 的相关类"></a>runloop 的相关类</h3><p>CFRunLoopRef</p><p>CFRunLoopModeRef</p><p>CFRunLoopSourceRef</p><p>CFRunLoopTimerRef</p><p>CFRunLoopObserverRef</p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/RunLoop_0.png" alt=""></p><h3 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个 Mode，通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中，来标记自己为 common。</p><p>每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p><p>所以 common 并不是一个真正的 mode。</p><h2 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h2><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/RunLoop_1.png" alt=""></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用DefaultMode启动</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// RunLoop的实现</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunSpecific</span>(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(runloop, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 内部函数，进入loop</span></span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            <span class="comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line">            <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></span><br><span class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line">            <span class="comment">/// • 一个基于 port 的Source 的事件。</span></span><br><span class="line">            <span class="comment">/// • 一个 Timer 到时间了</span></span><br><span class="line">            <span class="comment">/// • RunLoop 自身的超时时间到了</span></span><br><span class="line">            <span class="comment">/// • 被其他什么调用者手动唤醒</span></span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 收到消息，处理消息。</span></span><br><span class="line">            handle_msg:</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></span><br><span class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSourceRef</span> source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 执行加入到Loop的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                <span class="comment">/// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="comment">/// 超出传入参数标记的超时时间了</span></span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                <span class="comment">/// 被外部调用者强制停止了</span></span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                <span class="comment">/// source/timer/observer一个都没有了</span></span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="apple-使用-runloop"><a href="#apple-使用-runloop" class="headerlink" title="apple 使用 runloop"></a>apple 使用 runloop</h2><h3 id="apple-注册的-runloop-mode"><a href="#apple-注册的-runloop-mode" class="headerlink" title="apple 注册的 runloop mode"></a>apple 注册的 runloop mode</h3><p>app 启动后的 runloop 状态</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoop</span> &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        <span class="built_in">UITrackingRunLoopMode</span></span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    common mode items = &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// source0 (manual)</span></span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// source1 (mach port)</span></span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">17923</span>&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">12039</span>&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">16647</span>&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">2407</span>,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>b03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">1</span>, &#123;port = <span class="number">1903</span>,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Ovserver</span></span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">-2147483647</span>, activities = <span class="number">0x1</span>, <span class="comment">// Entry</span></span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">0</span>, activities = <span class="number">0x20</span>,          <span class="comment">// BeforeWaiting</span></span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">1999000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">2000000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">2147483647</span>, activities = <span class="number">0xa0</span>, <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Timer</span></span><br><span class="line">        <span class="built_in">CFRunLoopTimer</span> &#123;firing = No, interval = <span class="number">3.1536e+09</span>, tolerance = <span class="number">0</span>,</span><br><span class="line">            next fire date = <span class="number">453098071</span> (<span class="number">-4421.76019</span> @ <span class="number">96223387169499</span>),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            timers =    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            timers =    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopObserver</span> &gt;&#123;activities = <span class="number">0xa0</span>, order = <span class="number">2000000</span>,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">-1</span>, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">-1</span>, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统默认注册了5个Mode:</p><ol><li><p>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</p></li><li><p>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</p></li><li><p>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p></li><li><p>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</p></li><li><p>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</p></li></ol><h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p><p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p><p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p><h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p><p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p><p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p><h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。</p><h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。</p><p>但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p><h2 id="RunLoop-的运用"><a href="#RunLoop-的运用" class="headerlink" title="RunLoop 的运用"></a>RunLoop 的运用</h2><h3 id="创建一个长时间存活的线程"><a href="#创建一个长时间存活的线程" class="headerlink" title="创建一个长时间存活的线程"></a>创建一个长时间存活的线程</h3><p>我们会经常把一些耗费时间的操作放在子线程处理，不影响主线程 UI 更新。</p><p>子线程会在处理完任务后进行销毁</p><p>如果需要经常在子线程里执行任务，创建销毁线程会造成资源浪费，使用 RunLoop 来创建一个常驻的子线程会更高效。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AFNetworking 2.0</span></span><br><span class="line"><span class="comment">// NSURLConnection</span></span><br><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="界面滑动时保证-NSTimer-正常运行"><a href="#界面滑动时保证-NSTimer-正常运行" class="headerlink" title="界面滑动时保证 NSTimer 正常运行"></a>界面滑动时保证 NSTimer 正常运行</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 NSTimer 加入 NSRunLoopCommonModes</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(foo) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">[timer fire];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 NSTimer 加入子线程，子线程开启 runloop</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="保证界面流畅"><a href="#保证界面流畅" class="headerlink" title="保证界面流畅"></a>保证界面流畅</h3><p>AsyncDisplayKit</p><p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：</p><p>在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p><h3 id="RunLoop-监测主线程卡顿"><a href="#RunLoop-监测主线程卡顿" class="headerlink" title="RunLoop 监测主线程卡顿"></a>RunLoop 监测主线程卡顿</h3><p>在主线程的 RunLoop 中添加一个 observer，检测 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting 的时间并记录。</p><p>连续3次超时80ms认为卡顿</p><p><a href="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/GCDFetchFeed/Lib/SMLagMonitor/SMLagMonitor.m" target="_blank" rel="noopener">戴铭-GCDFetchFeed</a></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SMLagMonitor</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> timeoutCount;</span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> runLoopObserver;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    dispatch_semaphore_t dispatchSemaphore;</span><br><span class="line">    <span class="built_in">CFRunLoopActivity</span> runLoopActivity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *cpuMonitorTimer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SMLagMonitor</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Interface</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shareInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> instance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> dispatchOnce;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;dispatchOnce, ^&#123;</span><br><span class="line">        instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)beginMonitor &#123;</span><br><span class="line">    <span class="keyword">self</span>.isMonitoring = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">//监测 CPU 消耗</span></span><br><span class="line">    <span class="keyword">self</span>.cpuMonitorTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">3</span></span><br><span class="line">                                                             target:<span class="keyword">self</span></span><br><span class="line">                                                           selector:<span class="keyword">@selector</span>(updateCPUInfo)</span><br><span class="line">                                                           userInfo:<span class="literal">nil</span></span><br><span class="line">                                                            repeats:<span class="literal">YES</span>];</span><br><span class="line">    <span class="comment">//监测卡顿</span></span><br><span class="line">    <span class="keyword">if</span> (runLoopObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatchSemaphore = dispatch_semaphore_create(<span class="number">0</span>); <span class="comment">//Dispatch Semaphore保证同步</span></span><br><span class="line">    <span class="comment">//创建一个观察者</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>,(__bridge <span class="keyword">void</span>*)<span class="keyword">self</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    runLoopObserver = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</span><br><span class="line">                                              kCFRunLoopAllActivities,</span><br><span class="line">                                              <span class="literal">YES</span>,</span><br><span class="line">                                              <span class="number">0</span>,</span><br><span class="line">                                              &amp;runLoopObserverCallBack,</span><br><span class="line">                                              &amp;context);</span><br><span class="line">    <span class="comment">//将观察者添加到主线程runloop的common模式下的观察中</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), runLoopObserver, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建子线程监控</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">//子线程开启一个持续的loop用来进行监控</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, STUCKMONITORRATE * <span class="built_in">NSEC_PER_MSEC</span>));</span><br><span class="line">            <span class="keyword">if</span> (semaphoreWait != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!runLoopObserver) &#123;</span><br><span class="line">                    timeoutCount = <span class="number">0</span>;</span><br><span class="line">                    dispatchSemaphore = <span class="number">0</span>;</span><br><span class="line">                    runLoopActivity = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//两个runloop的状态，BeforeSources和AfterWaiting这两个状态区间时间能够检测到是否卡顿</span></span><br><span class="line">                <span class="keyword">if</span> (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    <span class="comment">//出现三次出结果</span></span><br><span class="line">                    <span class="keyword">if</span> (++timeoutCount &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//                    NSLog(@"monitor trigger");</span></span><br><span class="line">                    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">                        <span class="built_in">NSString</span> *stackStr = [SMCallStack callStackWithType:SMCallStackTypeMain];</span><br><span class="line">                        SMCallStackModel *model = [[SMCallStackModel alloc] init];</span><br><span class="line">                        model.stackStr = stackStr;</span><br><span class="line">                        model.isStuck = <span class="literal">YES</span>;</span><br><span class="line">                        [[[SMLagDB shareInstance] increaseWithStackModel:model] subscribeNext:^(<span class="keyword">id</span> x) &#123;&#125;];</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="comment">//end activity</span></span><br><span class="line">            &#125;<span class="comment">// end semaphore wait</span></span><br><span class="line">            timeoutCount = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="comment">// end while</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)endMonitor &#123;</span><br><span class="line">    <span class="keyword">self</span>.isMonitoring = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span>.cpuMonitorTimer invalidate];</span><br><span class="line">    <span class="keyword">if</span> (!runLoopObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), runLoopObserver, kCFRunLoopCommonModes);</span><br><span class="line">    <span class="built_in">CFRelease</span>(runLoopObserver);</span><br><span class="line">    runLoopObserver = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Private</span></span><br><span class="line">- (<span class="keyword">void</span>)updateCPUInfo &#123;</span><br><span class="line">    [SMCPUMonitor updateCPU];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> runLoopObserverCallBack(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info)&#123;</span><br><span class="line">    SMLagMonitor *lagMonitor = (__bridge SMLagMonitor*)info;</span><br><span class="line">    lagMonitor-&gt;runLoopActivity = activity;</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_t semaphore = lagMonitor-&gt;dispatchSemaphore;</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop by:ibireme</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RunLoop&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>autorelease</title>
    <link href="https://skybrim.top/2017/06/01/ios/autorelease/"/>
    <id>https://skybrim.top/2017/06/01/ios/autorelease/</id>
    <published>2017-06-01T05:40:30.000Z</published>
    <updated>2020-12-10T02:48:42.066Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a></p><a id="more"></a><h2 id="autorelease-对象释放时机"><a href="#autorelease-对象释放时机" class="headerlink" title="autorelease 对象释放时机"></a>autorelease 对象释放时机</h2><p>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</p><h2 id="autorelease-原理"><a href="#autorelease-原理" class="headerlink" title="autorelease 原理"></a>autorelease 原理</h2><h3 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h3><p>ARC下，我们使用@autoreleasepool{}来使用一个AutoreleasePool，随后编译器将其改写成下面的样子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *context = objc_autoreleasePoolPush();</span><br><span class="line"><span class="comment">// &#123;&#125;中的代码</span></span><br><span class="line">objc_autoreleasePoolPop(context);</span><br></pre></td></tr></table></figure><p>AutoreleasePoolPage是一个C++实现的类</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECT_AUTORELEASEPOOL 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AutoreleasePoolPage </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_SENTINEL 0</span></span><br><span class="line">    <span class="keyword">static</span> pthread_key_t <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    <span class="keyword">static</span> uint8_t <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">    <span class="keyword">static</span> size_t <span class="keyword">const</span> SIZE = </span><br><span class="line"></span><br><span class="line">    <span class="comment">// AutoreleasePoolPage 每个对象会开辟4096字节内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        <span class="number">4096</span>;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="number">4096</span>;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">static</span> size_t <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(<span class="keyword">id</span>);</span><br><span class="line"></span><br><span class="line">    magic_t <span class="keyword">const</span> magic;</span><br><span class="line">    <span class="keyword">id</span> *next;                               <span class="comment">// 指向栈顶最新add进来的autorelease对象的下一个位置</span></span><br><span class="line">    pthread_t <span class="keyword">const</span> thread;                 <span class="comment">// 当前线程</span></span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;     <span class="comment">// 双向链表，pre 指针</span></span><br><span class="line">    AutoreleasePoolPage *child;             <span class="comment">// 双向链表，next 指针</span></span><br><span class="line">    uint32_t <span class="keyword">const</span> depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他相关方法</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/autorelease_0.jpg" alt=""></p><p>向一个对象发送- autorelease消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置</p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><ul><li>objc_autoreleasePoolPush()</li></ul><p>每当进行一次 objc_autoreleasePoolPush 调用时，runtime向当前的AutoreleasePoolPage中add进一个哨兵对象，值为0（也就是个nil）</p><p>objc_autoreleasePoolPush的返回值正是这个哨兵对象的地址</p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/autorelease_1.jpg" alt=""></p><ul><li>objc_autoreleasePoolPop(哨兵对象)</li></ul><ol><li><p>根据传入的哨兵对象地址找到哨兵对象所处的page</p></li><li><p>在当前page中，将晚于哨兵对象插入的所有 autorelease 对象都发送一次 - release 消息，并向回移动next指针到正确位置</p></li><li><p>补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/autorelease_2.jpg" alt=""></p><h3 id="嵌套的-AutoreleasePool"><a href="#嵌套的-AutoreleasePool" class="headerlink" title="嵌套的 AutoreleasePool"></a>嵌套的 AutoreleasePool</h3><p>pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://blog.sunnyxx.com/2014/10/15/behind-autorelease/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;黑幕背后的Autorelease&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 事件传递与响应链</title>
    <link href="https://skybrim.top/2017/05/18/ios/responder-chain/"/>
    <id>https://skybrim.top/2017/05/18/ios/responder-chain/</id>
    <published>2017-05-18T07:09:51.000Z</published>
    <updated>2020-12-10T02:48:42.067Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 事件响应链<br>事件的传递与响应</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="UIResponder"><a href="#UIResponder" class="headerlink" title="UIResponder"></a>UIResponder</h3><ul><li>在 iOS 中，只有继承了 <strong>UIResponder</strong> 的对象才能接受并处理事件</li></ul><p>UIApplication (NSObject -&gt; UIResponder -&gt; UIApplication)<br>UIViewController (NSObject -&gt; UIResponder -&gt; UIViewController)<br>UIView (NSObject -&gt; UIResponder -&gt; UIView)<br>UIWindow (NSObject -&gt; UIResponder -&gt; UIView -&gt; UIWindow)<br>UIButton (NSObject -&gt; UIResponder -&gt; UIView -&gt; UIControl -&gt; UIButton)</p><ul><li>UIResponder 提供以下方法，来处理事件</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UIResponder内部提供了以下方法来处理事件触摸事件</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line"><span class="comment">// 加速计事件</span></span><br><span class="line">- (<span class="keyword">void</span>)motionBegan:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)motionEnded:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)motionCancelled:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line"><span class="comment">// 远程控制事件</span></span><br><span class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure><h3 id="UITouch"><a href="#UITouch" class="headerlink" title="UITouch"></a>UITouch</h3><p>当用户用一根手指触摸屏幕时，会创建一个与手指相关的UITouch对象</p><p>一根手指对应一个UITouch对象</p><p>如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象</p><p>如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触摸产生时所处的窗口</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) <span class="built_in">UIWindow</span> *window;</span><br><span class="line"><span class="comment">//触摸产生时所处的视图</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) <span class="built_in">UIView</span> *view;</span><br><span class="line"><span class="comment">//短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> tapCount;</span><br><span class="line"><span class="comment">//记录了触摸事件产生或变化时的时间，单位是秒</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSTimeInterval</span> timestamp;</span><br><span class="line"><span class="comment">//当前触摸事件所处的状态</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UITouchPhase</span> phase;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值表示触摸在view上的位置</span></span><br><span class="line"><span class="comment">// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）</span></span><br><span class="line"><span class="comment">// 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置</span></span><br><span class="line">-(<span class="built_in">CGPoint</span>)locationInView:(<span class="built_in">UIView</span> *)view;</span><br><span class="line"><span class="comment">// 该方法记录了前一个触摸点的位置</span></span><br><span class="line">-(<span class="built_in">CGPoint</span>)previousLocationInView:(<span class="built_in">UIView</span> *)view;</span><br></pre></td></tr></table></figure><h3 id="以-UIView-为例，重写-UIResponder-方法，说明事件的处理"><a href="#以-UIView-为例，重写-UIResponder-方法，说明事件的处理" class="headerlink" title="以 UIView 为例，重写 UIResponder 方法，说明事件的处理"></a>以 UIView 为例，重写 UIResponder 方法，说明事件的处理</h3><ul><li>重写以下 4 个方法，处理不同的触摸事件</li></ul><p>注意，直接在 UIViewController 的.m文件中重写，重写的是 VC 的方法，并非 VC.view 的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// touches中存放的都是UITouch对象</span></span><br><span class="line"><span class="comment">// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line"><span class="comment">// 一根或者多根手指在view上移动，随着手指的移动，会持续调用该方法</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line"><span class="comment">// 一根或者多根手指离开view，系统会自动调用view的下面方法</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line"><span class="comment">// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure><h2 id="事件的产生与传递"><a href="#事件的产生与传递" class="headerlink" title="事件的产生与传递"></a>事件的产生与传递</h2><h3 id="事件的产生与传递-1"><a href="#事件的产生与传递-1" class="headerlink" title="事件的产生与传递"></a>事件的产生与传递</h3><ol><li><p>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列（先进先出）中。</p></li><li><p>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）</p></li><li><p>主窗口会在视图层次结构中<strong>找到一个最合适的视图来处理触摸事件</strong></p></li></ol><p>触摸事件的传递是从父控件传递到子控件,也就是UIApplication-&gt;window-&gt;寻找处理事件最合适的view。</p><p><strong>如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件</strong></p><ol start="4"><li>找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理。</li></ol><h3 id="寻找最合适的控件处理触摸事件"><a href="#寻找最合适的控件处理触摸事件" class="headerlink" title="寻找最合适的控件处理触摸事件"></a>寻找最合适的控件处理触摸事件</h3><p>通过 hitTest:withEvent: 来找到最合适的控件，处理事件。</p><ol><li><p>首先判断主窗口（keyWindow）自己是否能接受触摸事件</p><p>以下情况不能接收触摸事件</p><ul><li><p>不允许交互：userInteractionEnabled = NO</p></li><li><p>隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件</p></li><li><p>透明度：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明</p></li></ul></li><li><p>判断触摸点是否在自己身上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure></li><li><p>子控件数组中从后往前遍历子控件，重复前面的两个步骤</p><p>从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤</p></li><li><p>view，比如叫做fitView，那么会把这个事件交给这个fitView，再遍历这个fitView的子控件，直至没有更合适的view为止。</p></li><li><p>如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。</p></li></ol><p>无论控件能否处理事件，只要点击了就会产生事件，区别是最终由哪个控件来处理事件。</p><p>综上，hitTest:withEvent: 的实现大致如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Returns the farthest descendant of the receiver in the view hierarchy (including itself) that contains a specified point</span></span><br><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.判断当前控件能否接收事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.userInteractionEnabled == <span class="literal">NO</span> || <span class="keyword">self</span>.hidden == <span class="literal">YES</span> || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 判断点在不在当前控件</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> pointInside:point withEvent:event] == <span class="literal">NO</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.从后往前遍历自己的子控件</span></span><br><span class="line">    <span class="built_in">NSInteger</span> count = <span class="keyword">self</span>.subviews.count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">UIView</span> *childView = <span class="keyword">self</span>.subviews[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把当前控件上的坐标系转换成子控件上的坐标系</span></span><br><span class="line">        <span class="built_in">CGPoint</span> childP = [<span class="keyword">self</span> convertPoint:point toView:childView];</span><br><span class="line">        <span class="comment">// 如果 fitView 为 nil，即 hitTest:withEvent: 返回 nil，当前的 view 及其 subviews 不是合适的view</span></span><br><span class="line">        <span class="built_in">UIView</span> *fitView = [childView hitTest:childP withEvent:event];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到最合适的view</span></span><br><span class="line">        <span class="keyword">if</span> (fitView) &#123; </span><br><span class="line">            <span class="keyword">return</span> fitView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环结束,表示没有比自己更合适的view，返回自身</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/responder-chain-1.png" alt=""></p><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><p>可以通过重写 hitTest:withEvent 来修改响应事件的 view</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [<span class="keyword">super</span> hitTest:point withEvent:event];</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h2><h3 id="responder-chain-（响应者链条）"><a href="#responder-chain-（响应者链条）" class="headerlink" title="responder chain （响应者链条）"></a>responder chain （响应者链条）</h3><p>在iOS程序中无论是最后面的UIWindow还是最前面的某个按钮，它们的摆放是有前后关系的，一个控件可以放到另一个控件上面或下面。</p><p>这种先后关系构成一个链条就叫“响应者链”。</p><p>也可以说，响应者链是由多个响应者对象连接起来的链条。</p><p><img src="https://cdn.jsdelivr.net/gh/skybrim/AllImages@dev/responder-chain-2.png" alt=""></p><h3 id="响应链的传递过程"><a href="#响应链的传递过程" class="headerlink" title="响应链的传递过程"></a>响应链的传递过程</h3><ol><li><p>如果当前view是控制器的view，那么控制器就是上一个响应者，事件就传递给控制器；如果当前view不是控制器的view，那么父视图就是当前view的上一个响应者，事件就传递给它的父视图</p></li><li><p>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</p></li><li><p>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</p></li><li><p>如果UIApplication也不能处理该事件或消息，则将其丢弃</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="iOS-事件处理的完整流程"><a href="#iOS-事件处理的完整流程" class="headerlink" title="iOS 事件处理的完整流程"></a>iOS 事件处理的完整流程</h3><ol><li><p>触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中。</p></li><li><p>UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keyWindow）。</p></li><li><p>主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，完成事件的传递)</p></li><li><p>最合适的view会调用自己的touches方法处理事件，touches默认做法是把事件顺着响应者链条向上抛。（开始响应链传递）</p></li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123; </span><br><span class="line">    [<span class="keyword">super</span> touchesBegan:touches withEvent:event]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何做到一个事件多个对象处理："><a href="#如何做到一个事件多个对象处理：" class="headerlink" title="如何做到一个事件多个对象处理："></a>如何做到一个事件多个对象处理：</h3><p>通过重写 touches 相关方法和父控件的touches方法，来达到一个事件多个对象处理的目的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123; </span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="comment">// responder chain</span></span><br><span class="line">    [<span class="keyword">super</span> touchesBegan:touches withEvent:event]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.jianshu.com/p/2e074db792ba" target="_blank" rel="noopener">史上最详细的iOS之事件的传递和响应机制-原理篇</a><br>文／VV木公子（简书作者）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 事件响应链&lt;br&gt;事件的传递与响应&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>View</title>
    <link href="https://skybrim.top/2017/01/01/ios/view/"/>
    <id>https://skybrim.top/2017/01/01/ios/view/</id>
    <published>2016-12-31T16:00:00.000Z</published>
    <updated>2020-12-10T02:48:42.068Z</updated>
    
    <content type="html"><![CDATA[<p>记录</p><a id="more"></a><ul><li><p>storyboard 分模块使用，尽量一个模块一个 storyboard， 不要整个工程混杂在一个里面。不仅可以尽量减少冲突，也有助于清晰整个工程的结构。</p></li><li><p>勾选 Is Initial View Controller 确定 storyboard 的主VC入口，主入口的左侧会有一个箭头</p></li><li><p>三大容器（container view controller，Tab Bar Controller，Navigation Controller，Split View Controller）。</p></li><li><p>容器与其他VC关联： relationship segue。</p></li><li><p>TableViewController 中 Dynamic Propotype 与 Static Cells 混用：<br>在 Storyboard 中，设置类型为 Static Cells ，在需要使用 Dynamic Propotype 的 section 中，留一个 cell ，并设置好 Identifier 。<br>代码中需要实现 UITableView 的代理方法。<br>以下方法必须实现。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tableView(tableView: <span class="type">UITableView</span>, cellForRowAtIndexPath indexPath: <span class="type">NSIndexPath</span>) -&gt; <span class="type">UITableViewCell</span>  </span><br><span class="line">tableView(tableView: <span class="type">UITableView</span>, numberOfRowsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span>  </span><br><span class="line">tableView(tableView: <span class="type">UITableView</span>, heightForRowAtIndexPath indexPath: <span class="type">NSIndexPath</span>) -&gt; <span class="type">CGFloat</span>  </span><br><span class="line"><span class="comment">// *** ***</span></span><br><span class="line">tableView(tableView: <span class="type">UITableView</span>, indentationLevelForRowAtIndexPath indexPath: <span class="type">NSIndexPath</span>) -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure></li><li><p>Static Cell，不重用cell，比如个人信息页面。可以直接在 storyboard 里设置，更方便。</p></li><li><p>Dynamic Prototypes，可重用cell。需要确定 cell 的 identifier，并在在代码中设置代理。</p></li><li><p>Selection Segue 的意思是当用户点击table view cell的任何部分，都会产生反应。<br>Accessory Action 的意思是只有当用户点击table view cell右边的圆圈箭头按钮时，才会产生的反应。</p></li><li><p>apple建议使用segue来进行跳转，项较于push等操作，支持形式更多，并且在不同设备（iPad和iPhone），会有更好的体验。<br>  Segue的类型  </p><ul><li>Show  <blockquote><p>使用方法 showViewController: sender:<br>该方法为VC提供了自适应、灵活的呈现方式；<br>用在 UINavigationController 堆栈视图时，presentedViewController 进入时由右向左，退出时由左向右。新压入的VC有返回按钮，单击可以返回；<br>用在 UIViewController 实例时，和 presentViewController: animated: completion: 效果一致。  </p></blockquote></li><li>Show Detail   <blockquote><p>使用方法 showDetailViewController: sender:；<br>只适用于嵌入在 UISplitViewController 对象内的VC，分割控制器用以替换详细控制器（DetailViewController)；<br>不提供返回按钮；<br>用于 UISplitViewController 以外的控制器时，和 showViewController:sender用法一样。  </p></blockquote></li><li>Present Modally  <blockquote><p>使用方法 presentViewController: animated: completion:；<br>有多种不同呈现方式，可根据需要设置。在 iPhone 中，一般以动画的形式自下向上覆盖整个屏幕，用户无法与上一个VC交互，除非关闭当前VC；在 iPad 中，常见呈现为一个中心框，中心框以动画形式自下向上弹出，同时使底层VC变暗；<br>不提供返回按钮。  </p></blockquote></li><li>Present as Popover  <blockquote><p>在 iPad 中，目标VC以浮动窗样式呈现，点击目标VC以外区域，目标VC消失；在 iPhone 中，默认目标VC以模态覆盖整个屏幕。  </p></blockquote></li><li>Exit Segue  <blockquote><p>在需要返回到的界面实现方法 @IBAction func xxxx(segue: UIStoryboardSegue)，方法名字任意，参数类型必须为 UIStoryboardSegue，一定要加上 @IBAction 关键字。<br>右键返回界面上方的 Exit，弹出菜单中可以看到刚才在返回到的界面中加的那个方法的名称；<br>连线，选择实现动作的控件，或者连接到当前界面选择手动代码实现返回（需要指定 identifier）；<br>使用 exit segue 的好处是可以跳转到任意打开过的界面比如从3-&gt;1，而不是只能返回上级界面从2-&gt;1。</p></blockquote></li><li>Embed Segue<blockquote><p>Container View，将容器 MVC 的 View 放入到另一个 MVC 中。</p></blockquote></li></ul></li><li><p>获取 storyboard 的实例：UIStoryboard(name: &lt;#T##String#&gt;, bundle: &lt;#T##Bundle?#&gt;)。</p></li><li><p>获取 storyboard 中 VC 的实例，通过 VC 的 Storyboard ID：  </p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="literal">nil</span>).instantiateViewController(withIdentifier: <span class="string">""</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过 storyboard reference，可以拆分成多个 storyboard，方便开发。<br>选中需要拆分的 VC，菜单栏干中 Editor-&gt;Refactor to Storyboard。</p></li><li><p>加载其他 storyboard 的指定 VC：<br>拖入控件 Storyboard Reference；<br>填写 storyboard 的名字；<br>填写 Reference ID，即目标 storyboard 中目标VC的 Storyboard ID。  </p></li><li><p>UIStackView，快速进行水平或者垂直布局。</p></li><li><p>如何对两个已经和边界拉好约束的相邻控件进行约束：<br>先设置约束距离为0，然后设置约束  greater than or equal。</p></li><li><p>关键字 IBDesignable，可以将 code 实现的 view 显示到 storyboard 上。<br>如果有 image，需要使用下面的方法，才能正确显示  </p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIImage</span>(named: <span class="string">"xxx"</span>, <span class="keyword">in</span>: <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="keyword">self</span>.classForCoder), compatibleWith: traitCollection);</span><br></pre></td></tr></table></figure></li><li><p>关键字 IBInspectable，可以将代码写好的 property 显示到 storyboard 右边的 inspect 上。</p></li><li><p>setNeedsDisplay()，当需要重新绘制的时候，需要主动调用这个方法，不要调用 UIView 的 draw() 方法。</p></li><li><p>setNeedsLayout()，当需要 subView 重新布局的时候，调用这个方法。</p></li><li><p>如果 UIView 需要重新绘制，content mode 需要设置为 Redraw 。</p></li><li><p>当 UITraitCollection 改变时，系统会调用此方法，用来更新UI。在方法里实现 setNeedsDisplay() 和 setNeedsLayout()。  </p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//To be overridden as needed to provide custom behavior when the environment's traits change.</span></span><br><span class="line">-(<span class="keyword">void</span>)traitCollectionDidChange:(<span class="keyword">nullable</span> <span class="built_in">UITraitCollection</span> *)previousTraitCollection;</span><br></pre></td></tr></table></figure><p>  e.g. UIImage(named: “name”, in: Bundle(for: self.classForCoder), compatibleWith: traitCollection)，并使用draw绘制图片，此时屏幕翻转，需要重新绘制，系统会调用上面方法。</p></li><li><p>子视图的布局写在此方法中，当视图需要重新绘制布局时，调用 setNeedsLayout()，会自动调用此方法。  </p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//override point. called by layoutIfNeeded automatically.</span></span><br><span class="line"><span class="comment">// As of iOS 6.0, when constraints-based layout is used the base implementation applies the constraints-based layout, otherwise it does nothing.</span></span><br><span class="line">-(<span class="keyword">void</span>)layoutSubviews;</span><br></pre></td></tr></table></figure></li><li><p>自定义绘制实现的方法，当视图需要重新绘制（Redraw）的时候调用 setNeedsDisplay()，会自动调用此方法。</p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect;</span><br></pre></td></tr></table></figure></li><li><p>Core Graphics属于更底层<br>  UIKit依赖于Core Graphics框架<br>  UIBezierPath属于UIKit，是对Core Graphics框架中的CGPath的封装<br>  补充：UIGraphicsGetCurrentContext()画出的线，被使用了就被消耗掉。</p></li><li><p>三种动画方式：  </p><ul><li>UIViewPropertyAnimator(iOS 10.0)  <blockquote><p>iOS 10.0，apple 封装好的动画API，更精细的控制动画，可以通过 startAnimation、 pauseAnimation 和 stopAnimation 控制动画。</p></blockquote></li><li>Transitions  </li><li>Dynamic Animator  <blockquote><p>给对象添加各种物理属性（重力、加速度等）  </p></blockquote></li></ul></li><li><p>Auto Layout</p><ul><li>通过 Interface Builder 来实现是好的选择；  </li><li>通过代码实现 Auto Layout；  <blockquote><p>在 -init 或者 -viewDidLoad 方法中，实现固定不变的约束<br>在 -updateConstraints 中，实现程序运行时可能改变的约束<br>当需要改变约束的时候，按顺序调用下面方法  </p></blockquote><pre><code class="swift">setNeedsUpdateConstraints()  updateConstraintsIfNeeded()  </code></pre></li><li>view 的子类布局同理</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://skybrim.top/tags/iOS/"/>
    
  </entry>
  
</feed>
