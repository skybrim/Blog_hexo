---
title: 预处理指令
date: 2019/10/13
tags: c
comments: true
---

define
<!--more-->

C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释(比如之前使用的#include文件包含指令)，产生一个新的源程序(这个过程称为编译预处理),之后再进行通常的编译  
为了区分预处理指令和一般的C语句，所有预处理指令都以符号"#"开头，并且结尾不用分号  
预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。习惯上我们尽可能将预处理指令写在源程序开头，这种情况下，它的作用范围就是整个源程序文件  
C语言提供的预处理指令主要有：宏定义、文件包含、条件编译  

## 宏定义

* 形式  
#define 宏名 字符串  

* 作用  
将源程序中所有"宏名"替换成右边的"字符串"，常用来定义常量。  

```C
#include <stdio.h>
// 源程序中所有的宏名PI在编译预处理的时候都会被3.14所代替
#define PI 3.14

// 根据圆的半径计radius算周长
float girth(float radius) {
    return 2 * PI *radius;
}
int main (int argc, char *argv[]) {
    float g = girth(2);
    printf("周长为：%f", g);
    return 0;
}
```

* 注意点  
宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误。  
对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作。  
在编译预处理用字符串替换宏名时，不作语法检查，只是简单的字符串替换。  
只有在编译的时候才对已经展开宏名的源程序进行语法检查。  
宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令。  
定义一个宏时可以引用已经定义的宏名  

```C
#define R 3.0
#define PI 3.14
#define L 2*PI*R
#define S PI*R*R
```

* 带参数的宏定义  
#define 宏名(参数列表) 字符串

```C
#include <stdio.h>

#define average(a, b) (a+b)/2

int main (int argc, char *argv[]) {
    int a = average(10, 4);
    printf("平均值：%d", a);
    return 0;
}
```

* 带参数的宏定义 使用注意  

 宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串  
 带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。  

 * 与函数的区别  

宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题  
函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率  

## 条件编译

* 基本用法

```C
#if 条件1
 ...code1...
#elif 条件2
 ...code2...
#else
 ...code3...
#endif
```

* #if defined() 和 #if !defined()  

#if 和 #elif 后面的条件不仅仅可以用来判断宏的值，还可以判断是否定义过某个宏  
如果前面已经定义过MAX这个宏，就将code编译进去。它不会管MAX的值是多少，只要定义过MAX，条件就成立。  

```C
// 判断是否定义过某个宏
#if defined(MAX)
    ...code...
#endif
//条件取反
#if !defined(MAX)
    ...code...
#endif
```

* #ifdef 和 #ifndef

#ifdef的使用和#if defined()的用法基本一致  
#ifndef又和#if !defined()的用法基本一致  

```C
//
#ifdef MAX
    ...code...
#endif
//
#ifndef MAX
    ...code...
#endif
```

## 文件包含

* 形式  

#include　<文件名>  
直接到C语言库函数头文件所在的目录中寻找文件  

#include　"文件名"  
系统会先在源程序当前目录下寻找，若找不到，再到操作系统的path路径中查找，最后才到C语言库函数头文件所在目录中查找  

* 使用注意  
#include 指令允许嵌套包含，但是不允许递归包含  
使用#include指令可能导致多次包含同一个头文件，降低编译效率  
解决这种重复包含同一个头文件的问题的方式：  

```C
#ifndef _NAME_H_
#define _NAME_H_
    code
#endif
```

当我们第一次 #include "name.h"时，因为没有定义 _NAME_H_ ，所以条件成立。  
接着在定义了 _NAME_H_ 这个宏，然后在编写代码，最后结束条件编译。  
当第二次#include "name.h"，因为之前已经定义过 _NAME_H_ 这个宏，所以条件不成立，直接跳到#endif，结束条件编译。  

