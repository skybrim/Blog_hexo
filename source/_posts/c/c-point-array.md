---
title: C语言指针与数组
date: 2019/10/13
tags: c
comments: true
---

point 与 array
<!--more-->

## 指针与一维数组

```C
// 定义一个int类型的数组
int a[2];
// 定义一个int类型的指针
int *p;
// 让指针指向数组的第0个元素
p = &a[0];
// 修改所指向元素的值
*p = 10;
// 打印第一个元素的值
printf("a[0] = %d", a[0]); //< a[0] = 10
```

说明已经通过指针间接修改了数组元素的值，跟指向一个普通int类型变量是一样的。  
由于数组名代表着数组的首地址，即 a == &a[0]  
即 p = &a[0] <==> p = a  

## 用指针遍历数组

* for 循环遍历  
略  
* 指针遍历数组  

```C
// 定义一个int类型的数组
int a[4] = {1, 2, 3, 4};
// 定义一个int类型的指针，并指向数组的第0个元素
int *p = a;

int i;
for (i = 0; i < 4; i++) {
    //利用指针运算符*取出数组元素的值
    //*(p+i)代表根据p+i的值(其实就是第i个数组元素的地址)访问对应的存储空间
    int value = *(p+i);
    printf("a[%d] = %d \n", i, value);
}
```

**p+1不一定代表p的值加2，也可能是加1、加4或者加8。究竟加多少，这跟指针的类型有关。**  
**遍历完毕后，指针变量p还是指向a[0]，因为p值一直没有变过，一直都是a[0]的地址ffc3。**  

相同原理的其他方式
```C
//数组名代表数组的首地址，也可以用于遍历
int value = *(a+i);
//利用指针运算符*取出数组元素的值，遍历后 p 没有指向任何数组元素，会指向数组后面的地址
int value = *(p++);
//这种做法， **错误**，数组名是常量，不能修改赋值
int value = *(a++);
```

## 数组、指针与函数参数

用数组名作为函数实参时，是把实参数组的首地址传递给形参数组，两个数组共同占用同一段内存空间。  
这样形参数组中的元素值发生变化就会使实参数组的元素值也同时变化  

```C
void change(int b[]) {
    b[0] = 10;
}
int main(int argc, char *argv[]) {
    // 定义一个int类型的数组
    int a[4] = {1, 2, 3, 4};
    // 将数组名a传入change函数中
    change(a);
    // 查看a[0]
    printf("a[0]=%d", a[0]);
    return 0;
}
```

函数的实参和形参都可以分别使用数组或指针  

```C
void change(int b[]) {
    b[0] = 10;
}
int main(int argc, char *argv[]) {
    // 定义一个int类型的数组
    int a[4] = {1, 2, 3, 4};
    int *p = a;
    // 将数组名a传入change函数中
    change(p);
    // 查看a[0]
    printf("a[0]=%d", a[0]);
    return 0;
}
```

如果一个函数的形参类型是一个指针变量，调用函数时，你可以传入数组名或者指针变量。

```C
void change(int *b) {
    b[0] = 10;
    // 或者*b = 10;
}

int main(int argc, char *argv[]) {
    // 定义一个int类型的数组
    int a[4] = {1, 2, 3, 4};
    // 将数组名a传入change函数中
    change(a);
    // 查看a[0]
    printf("a[0]=%d", a[0]);
    return 0;
}
```

指针和数组是可以相互切换使用的。但是，**并不能说指针就等于数组**。